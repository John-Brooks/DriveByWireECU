
DriveByWireECU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004820  00000000  00000000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000094  20000000  00004820  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  00020094  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00020094  2**0
                  CONTENTS
  4 .bss          000016b0  200000a0  000048c0  00020094  2**5
                  ALLOC
  5 .stack        00010000  20001750  00005f70  00020094  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00020094  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  000200c2  2**0
                  CONTENTS, READONLY
  8 .debug_info   00038c2f  00000000  00000000  0002011b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00004663  00000000  00000000  00058d4a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000fa49  00000000  00000000  0005d3ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00001bb0  00000000  00000000  0006cdf6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001990  00000000  00000000  0006e9a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0003bede  00000000  00000000  00070336  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0001ec45  00000000  00000000  000ac214  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0012e7bf  00000000  00000000  000cae59  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00007980  00000000  00000000  001f9618  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
       0:	50 17 01 20 f1 02 00 00 8d 03 00 00 8d 03 00 00     P.. ............
      10:	8d 03 00 00 8d 03 00 00 8d 03 00 00 00 00 00 00     ................
	...
      2c:	9d 37 00 00 8d 03 00 00 00 00 00 00 c1 37 00 00     .7...........7..
      3c:	25 38 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     %8..............
      4c:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      5c:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      6c:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      7c:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      8c:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      9c:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      ac:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      bc:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      cc:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
      dc:	8d 03 00 00 8d 03 00 00 8d 03 00 00 00 00 00 00     ................
	...
      f4:	25 2d 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     %-..............
     104:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     114:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     124:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     134:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     144:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     154:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     164:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     174:	8d 03 00 00 8d 03 00 00 1d 23 00 00 8d 03 00 00     .........#......
     184:	8d 03 00 00 8d 03 00 00 8d 03 00 00 a9 29 00 00     .............)..
     194:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     1a4:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     1b4:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     1c4:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     1d4:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     1e4:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     1f4:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     204:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     214:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     224:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     234:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     244:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................
     254:	8d 03 00 00 8d 03 00 00 8d 03 00 00 8d 03 00 00     ................

00000264 <__do_global_dtors_aux>:
     264:	b510      	push	{r4, lr}
     266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
     268:	7823      	ldrb	r3, [r4, #0]
     26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
     26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
     26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
     270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
     272:	f3af 8000 	nop.w
     276:	2301      	movs	r3, #1
     278:	7023      	strb	r3, [r4, #0]
     27a:	bd10      	pop	{r4, pc}
     27c:	200000a0 	.word	0x200000a0
     280:	00000000 	.word	0x00000000
     284:	00004820 	.word	0x00004820

00000288 <frame_dummy>:
     288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
     28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
     28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
     28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
     290:	b510      	push	{r4, lr}
     292:	f3af 8000 	nop.w
     296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
     298:	6803      	ldr	r3, [r0, #0]
     29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
     29c:	bd10      	pop	{r4, pc}
     29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
     2a0:	6803      	ldr	r3, [r0, #0]
     2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
     2a4:	4770      	bx	lr
     2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
     2a8:	2b00      	cmp	r3, #0
     2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
     2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     2b0:	4718      	bx	r3
     2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
     2b4:	2b00      	cmp	r3, #0
     2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
     2b8:	4718      	bx	r3
     2ba:	bf00      	nop
     2bc:	00000000 	.word	0x00000000
     2c0:	00004820 	.word	0x00004820
     2c4:	200000a4 	.word	0x200000a4
     2c8:	00004820 	.word	0x00004820
     2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
     2d0:	b580      	push	{r7, lr}
     2d2:	af00      	add	r7, sp, #0
	system_init();
     2d4:	4b03      	ldr	r3, [pc, #12]	; (2e4 <atmel_start_init+0x14>)
     2d6:	4798      	blx	r3
	ethernet_phys_init();
     2d8:	4b03      	ldr	r3, [pc, #12]	; (2e8 <atmel_start_init+0x18>)
     2da:	4798      	blx	r3
	stdio_redirect_init();
     2dc:	4b03      	ldr	r3, [pc, #12]	; (2ec <atmel_start_init+0x1c>)
     2de:	4798      	blx	r3
}
     2e0:	bf00      	nop
     2e2:	bd80      	pop	{r7, pc}
     2e4:	00000ec5 	.word	0x00000ec5
     2e8:	0000109d 	.word	0x0000109d
     2ec:	000036e1 	.word	0x000036e1

000002f0 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
     2f0:	b580      	push	{r7, lr}
     2f2:	b082      	sub	sp, #8
     2f4:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
     2f6:	4b1c      	ldr	r3, [pc, #112]	; (368 <Reset_Handler+0x78>)
     2f8:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
     2fa:	4b1c      	ldr	r3, [pc, #112]	; (36c <Reset_Handler+0x7c>)
     2fc:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
     2fe:	687a      	ldr	r2, [r7, #4]
     300:	683b      	ldr	r3, [r7, #0]
     302:	429a      	cmp	r2, r3
     304:	d00c      	beq.n	320 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
     306:	e007      	b.n	318 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
     308:	683b      	ldr	r3, [r7, #0]
     30a:	1d1a      	adds	r2, r3, #4
     30c:	603a      	str	r2, [r7, #0]
     30e:	687a      	ldr	r2, [r7, #4]
     310:	1d11      	adds	r1, r2, #4
     312:	6079      	str	r1, [r7, #4]
     314:	6812      	ldr	r2, [r2, #0]
     316:	601a      	str	r2, [r3, #0]
                for (; pDest < &_erelocate;) {
     318:	683b      	ldr	r3, [r7, #0]
     31a:	4a15      	ldr	r2, [pc, #84]	; (370 <Reset_Handler+0x80>)
     31c:	4293      	cmp	r3, r2
     31e:	d3f3      	bcc.n	308 <Reset_Handler+0x18>
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
     320:	4b14      	ldr	r3, [pc, #80]	; (374 <Reset_Handler+0x84>)
     322:	603b      	str	r3, [r7, #0]
     324:	e004      	b.n	330 <Reset_Handler+0x40>
                *pDest++ = 0;
     326:	683b      	ldr	r3, [r7, #0]
     328:	1d1a      	adds	r2, r3, #4
     32a:	603a      	str	r2, [r7, #0]
     32c:	2200      	movs	r2, #0
     32e:	601a      	str	r2, [r3, #0]
        for (pDest = &_szero; pDest < &_ezero;) {
     330:	683b      	ldr	r3, [r7, #0]
     332:	4a11      	ldr	r2, [pc, #68]	; (378 <Reset_Handler+0x88>)
     334:	4293      	cmp	r3, r2
     336:	d3f6      	bcc.n	326 <Reset_Handler+0x36>
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
     338:	4b10      	ldr	r3, [pc, #64]	; (37c <Reset_Handler+0x8c>)
     33a:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     33c:	4a10      	ldr	r2, [pc, #64]	; (380 <Reset_Handler+0x90>)
     33e:	687b      	ldr	r3, [r7, #4]
     340:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
     344:	6093      	str	r3, [r2, #8]

#if __FPU_USED
        /* Enable FPU */
        SCB->CPACR |=  (0xFu << 20);
     346:	4a0e      	ldr	r2, [pc, #56]	; (380 <Reset_Handler+0x90>)
     348:	4b0d      	ldr	r3, [pc, #52]	; (380 <Reset_Handler+0x90>)
     34a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     34e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     352:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     356:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     35a:	f3bf 8f6f 	isb	sy
        __DSB();
        __ISB();
#endif

        /* Initialize the C library */
        __libc_init_array();
     35e:	4b09      	ldr	r3, [pc, #36]	; (384 <Reset_Handler+0x94>)
     360:	4798      	blx	r3

        /* Branch to main function */
        main();
     362:	4b09      	ldr	r3, [pc, #36]	; (388 <Reset_Handler+0x98>)
     364:	4798      	blx	r3

        /* Infinite loop */
        while (1);
     366:	e7fe      	b.n	366 <Reset_Handler+0x76>
     368:	00004820 	.word	0x00004820
     36c:	20000000 	.word	0x20000000
     370:	20000094 	.word	0x20000094
     374:	200000a0 	.word	0x200000a0
     378:	20001750 	.word	0x20001750
     37c:	00000000 	.word	0x00000000
     380:	e000ed00 	.word	0xe000ed00
     384:	00003e6d 	.word	0x00003e6d
     388:	00003511 	.word	0x00003511

0000038c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     38c:	b480      	push	{r7}
     38e:	af00      	add	r7, sp, #0
        while (1) {
     390:	e7fe      	b.n	390 <Dummy_Handler+0x4>

00000392 <LinarlyInterpolate>:
 const float steering_voltages[] = {0, 1.65, 3.3};
 int steering_table_size = sizeof(steering_positions) / sizeof(float);
 

 float LinarlyInterpolate(float val_x, float left_x, float right_x, float left_y, float right_y)
 {
     392:	b480      	push	{r7}
     394:	b087      	sub	sp, #28
     396:	af00      	add	r7, sp, #0
     398:	60f8      	str	r0, [r7, #12]
     39a:	60b9      	str	r1, [r7, #8]
     39c:	607a      	str	r2, [r7, #4]
     39e:	603b      	str	r3, [r7, #0]
	float delta_x = right_x - left_x;
     3a0:	ed97 7a01 	vldr	s14, [r7, #4]
     3a4:	edd7 7a02 	vldr	s15, [r7, #8]
     3a8:	ee77 7a67 	vsub.f32	s15, s14, s15
     3ac:	edc7 7a05 	vstr	s15, [r7, #20]
	float percent_x = (val_x - left_x) / delta_x;
     3b0:	ed97 7a03 	vldr	s14, [r7, #12]
     3b4:	edd7 7a02 	vldr	s15, [r7, #8]
     3b8:	ee77 6a67 	vsub.f32	s13, s14, s15
     3bc:	ed97 7a05 	vldr	s14, [r7, #20]
     3c0:	eec6 7a87 	vdiv.f32	s15, s13, s14
     3c4:	edc7 7a04 	vstr	s15, [r7, #16]
	return left_y + (percent_x * (right_y - left_y));
     3c8:	ed97 7a08 	vldr	s14, [r7, #32]
     3cc:	edd7 7a00 	vldr	s15, [r7]
     3d0:	ee37 7a67 	vsub.f32	s14, s14, s15
     3d4:	edd7 7a04 	vldr	s15, [r7, #16]
     3d8:	ee27 7a27 	vmul.f32	s14, s14, s15
     3dc:	edd7 7a00 	vldr	s15, [r7]
     3e0:	ee77 7a27 	vadd.f32	s15, s14, s15
     3e4:	ee17 3a90 	vmov	r3, s15
 }
     3e8:	4618      	mov	r0, r3
     3ea:	371c      	adds	r7, #28
     3ec:	46bd      	mov	sp, r7
     3ee:	f85d 7b04 	ldr.w	r7, [sp], #4
     3f2:	4770      	bx	lr

000003f4 <ReadSteeringPosition>:

 float ReadSteeringPosition()
 {
     3f4:	b590      	push	{r4, r7, lr}
     3f6:	b087      	sub	sp, #28
     3f8:	af02      	add	r7, sp, #8
	//TODO: determine voltage mapping between linear potentiometer and steering angle.
	//fill out linear interpolation table above
	if( steering_table_size < 2 )
     3fa:	4b35      	ldr	r3, [pc, #212]	; (4d0 <ReadSteeringPosition+0xdc>)
     3fc:	681b      	ldr	r3, [r3, #0]
     3fe:	2b01      	cmp	r3, #1
     400:	dc02      	bgt.n	408 <ReadSteeringPosition+0x14>
		return 0.0f;
     402:	f04f 0300 	mov.w	r3, #0
     406:	e05f      	b.n	4c8 <ReadSteeringPosition+0xd4>

	//Read the steering position
	adc_val_t adc_val;
	adc_sync_read_channel(&ADC_0, 0, adc_val.ADC_Read_8, 2);
     408:	1d3a      	adds	r2, r7, #4
     40a:	2302      	movs	r3, #2
     40c:	2100      	movs	r1, #0
     40e:	4831      	ldr	r0, [pc, #196]	; (4d4 <ReadSteeringPosition+0xe0>)
     410:	4c31      	ldr	r4, [pc, #196]	; (4d8 <ReadSteeringPosition+0xe4>)
     412:	47a0      	blx	r4
	float steering_voltage = ((float)adc_val.ADC_Read / (float)0xFFF) * 3.3f;
     414:	88bb      	ldrh	r3, [r7, #4]
     416:	ee07 3a90 	vmov	s15, r3
     41a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
     41e:	eddf 6a2f 	vldr	s13, [pc, #188]	; 4dc <ReadSteeringPosition+0xe8>
     422:	eec7 7a26 	vdiv.f32	s15, s14, s13
     426:	ed9f 7a2e 	vldr	s14, [pc, #184]	; 4e0 <ReadSteeringPosition+0xec>
     42a:	ee67 7a87 	vmul.f32	s15, s15, s14
     42e:	edc7 7a02 	vstr	s15, [r7, #8]
	for(int i = 0; i < steering_table_size; ++i)
     432:	2300      	movs	r3, #0
     434:	60fb      	str	r3, [r7, #12]
     436:	e040      	b.n	4ba <ReadSteeringPosition+0xc6>
	{
		//maximum value
		if( i == steering_table_size - 1 )
     438:	4b25      	ldr	r3, [pc, #148]	; (4d0 <ReadSteeringPosition+0xdc>)
     43a:	681b      	ldr	r3, [r3, #0]
     43c:	1e5a      	subs	r2, r3, #1
     43e:	68fb      	ldr	r3, [r7, #12]
     440:	429a      	cmp	r2, r3
     442:	d105      	bne.n	450 <ReadSteeringPosition+0x5c>
			return steering_positions[i];
     444:	4a27      	ldr	r2, [pc, #156]	; (4e4 <ReadSteeringPosition+0xf0>)
     446:	68fb      	ldr	r3, [r7, #12]
     448:	009b      	lsls	r3, r3, #2
     44a:	4413      	add	r3, r2
     44c:	681b      	ldr	r3, [r3, #0]
     44e:	e03b      	b.n	4c8 <ReadSteeringPosition+0xd4>

		if( steering_voltage <= steering_voltages[i+1] )
     450:	68fb      	ldr	r3, [r7, #12]
     452:	3301      	adds	r3, #1
     454:	4a24      	ldr	r2, [pc, #144]	; (4e8 <ReadSteeringPosition+0xf4>)
     456:	009b      	lsls	r3, r3, #2
     458:	4413      	add	r3, r2
     45a:	ed93 7a00 	vldr	s14, [r3]
     45e:	edd7 7a02 	vldr	s15, [r7, #8]
     462:	eeb4 7ae7 	vcmpe.f32	s14, s15
     466:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
     46a:	db23      	blt.n	4b4 <ReadSteeringPosition+0xc0>
		{
			//minimum value
			if( i == 0 )
     46c:	68fb      	ldr	r3, [r7, #12]
     46e:	2b00      	cmp	r3, #0
     470:	d102      	bne.n	478 <ReadSteeringPosition+0x84>
				return steering_positions[0];
     472:	f04f 0300 	mov.w	r3, #0
     476:	e027      	b.n	4c8 <ReadSteeringPosition+0xd4>

			//some intermediate value
			return LinarlyInterpolate(steering_voltage, steering_voltages[i], steering_voltages[i+1], steering_positions[i], steering_positions[i+1]);
     478:	4a1b      	ldr	r2, [pc, #108]	; (4e8 <ReadSteeringPosition+0xf4>)
     47a:	68fb      	ldr	r3, [r7, #12]
     47c:	009b      	lsls	r3, r3, #2
     47e:	4413      	add	r3, r2
     480:	6819      	ldr	r1, [r3, #0]
     482:	68fb      	ldr	r3, [r7, #12]
     484:	3301      	adds	r3, #1
     486:	4a18      	ldr	r2, [pc, #96]	; (4e8 <ReadSteeringPosition+0xf4>)
     488:	009b      	lsls	r3, r3, #2
     48a:	4413      	add	r3, r2
     48c:	6818      	ldr	r0, [r3, #0]
     48e:	4a15      	ldr	r2, [pc, #84]	; (4e4 <ReadSteeringPosition+0xf0>)
     490:	68fb      	ldr	r3, [r7, #12]
     492:	009b      	lsls	r3, r3, #2
     494:	4413      	add	r3, r2
     496:	681c      	ldr	r4, [r3, #0]
     498:	68fb      	ldr	r3, [r7, #12]
     49a:	3301      	adds	r3, #1
     49c:	4a11      	ldr	r2, [pc, #68]	; (4e4 <ReadSteeringPosition+0xf0>)
     49e:	009b      	lsls	r3, r3, #2
     4a0:	4413      	add	r3, r2
     4a2:	681b      	ldr	r3, [r3, #0]
     4a4:	9300      	str	r3, [sp, #0]
     4a6:	4623      	mov	r3, r4
     4a8:	4602      	mov	r2, r0
     4aa:	68b8      	ldr	r0, [r7, #8]
     4ac:	4c0f      	ldr	r4, [pc, #60]	; (4ec <ReadSteeringPosition+0xf8>)
     4ae:	47a0      	blx	r4
     4b0:	4603      	mov	r3, r0
     4b2:	e009      	b.n	4c8 <ReadSteeringPosition+0xd4>
	for(int i = 0; i < steering_table_size; ++i)
     4b4:	68fb      	ldr	r3, [r7, #12]
     4b6:	3301      	adds	r3, #1
     4b8:	60fb      	str	r3, [r7, #12]
     4ba:	4b05      	ldr	r3, [pc, #20]	; (4d0 <ReadSteeringPosition+0xdc>)
     4bc:	681b      	ldr	r3, [r3, #0]
     4be:	68fa      	ldr	r2, [r7, #12]
     4c0:	429a      	cmp	r2, r3
     4c2:	dbb9      	blt.n	438 <ReadSteeringPosition+0x44>
		}
	}
	//if execution reaches here, then the above code is broken
	return 0.0f;
     4c4:	f04f 0300 	mov.w	r3, #0
 }
     4c8:	4618      	mov	r0, r3
     4ca:	3714      	adds	r7, #20
     4cc:	46bd      	mov	sp, r7
     4ce:	bd90      	pop	{r4, r7, pc}
     4d0:	20000000 	.word	0x20000000
     4d4:	200016dc 	.word	0x200016dc
     4d8:	00001141 	.word	0x00001141
     4dc:	457ff000 	.word	0x457ff000
     4e0:	40533333 	.word	0x40533333
     4e4:	00004634 	.word	0x00004634
     4e8:	00004640 	.word	0x00004640
     4ec:	00000393 	.word	0x00000393

000004f0 <ProcessCurrentInputs>:

 void ProcessCurrentInputs(double time_elapsed)
 {
     4f0:	b580      	push	{r7, lr}
     4f2:	b082      	sub	sp, #8
     4f4:	af00      	add	r7, sp, #0
     4f6:	e9c7 0100 	strd	r0, r1, [r7]
	inputs.steering_position = ReadSteeringPosition();
     4fa:	4b04      	ldr	r3, [pc, #16]	; (50c <ProcessCurrentInputs+0x1c>)
     4fc:	4798      	blx	r3
     4fe:	4602      	mov	r2, r0
     500:	4b03      	ldr	r3, [pc, #12]	; (510 <ProcessCurrentInputs+0x20>)
     502:	609a      	str	r2, [r3, #8]
	
 }
     504:	bf00      	nop
     506:	3708      	adds	r7, #8
     508:	46bd      	mov	sp, r7
     50a:	bd80      	pop	{r7, pc}
     50c:	000003f5 	.word	0x000003f5
     510:	20001684 	.word	0x20001684

00000514 <GetCurrentInputs>:

 dbw_inputs_t* GetCurrentInputs()
 {
     514:	b480      	push	{r7}
     516:	af00      	add	r7, sp, #0
	return &inputs;
     518:	4b02      	ldr	r3, [pc, #8]	; (524 <GetCurrentInputs+0x10>)
 }
     51a:	4618      	mov	r0, r3
     51c:	46bd      	mov	sp, r7
     51e:	f85d 7b04 	ldr.w	r7, [sp], #4
     522:	4770      	bx	lr
     524:	20001684 	.word	0x20001684

00000528 <ProcessCurrentOutputs>:

 void ProcessCurrentOutputs(double time_elapsed)
 {
     528:	b480      	push	{r7}
     52a:	b083      	sub	sp, #12
     52c:	af00      	add	r7, sp, #0
     52e:	e9c7 0100 	strd	r0, r1, [r7]

 }
     532:	bf00      	nop
     534:	370c      	adds	r7, #12
     536:	46bd      	mov	sp, r7
     538:	f85d 7b04 	ldr.w	r7, [sp], #4
     53c:	4770      	bx	lr

0000053e <SendUpdateToPC>:
 void SendUpdateToPC()
 {
     53e:	b480      	push	{r7}
     540:	af00      	add	r7, sp, #0

 }
     542:	bf00      	nop
     544:	46bd      	mov	sp, r7
     546:	f85d 7b04 	ldr.w	r7, [sp], #4
     54a:	4770      	bx	lr

0000054c <SetReverseDrive>:

 }

 //Puts the vehicle in reverse if value is non-zero.
 void SetReverseDrive(int reverse)
 {
     54c:	b480      	push	{r7}
     54e:	b083      	sub	sp, #12
     550:	af00      	add	r7, sp, #0
     552:	6078      	str	r0, [r7, #4]
 
 }
     554:	bf00      	nop
     556:	370c      	adds	r7, #12
     558:	46bd      	mov	sp, r7
     55a:	f85d 7b04 	ldr.w	r7, [sp], #4
     55e:	4770      	bx	lr

00000560 <hri_gclk_write_PCHCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
     560:	b480      	push	{r7}
     562:	b085      	sub	sp, #20
     564:	af00      	add	r7, sp, #0
     566:	60f8      	str	r0, [r7, #12]
     568:	460b      	mov	r3, r1
     56a:	607a      	str	r2, [r7, #4]
     56c:	72fb      	strb	r3, [r7, #11]
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
     56e:	7afa      	ldrb	r2, [r7, #11]
     570:	68fb      	ldr	r3, [r7, #12]
     572:	3220      	adds	r2, #32
     574:	6879      	ldr	r1, [r7, #4]
     576:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	GCLK_CRITICAL_SECTION_LEAVE();
}
     57a:	bf00      	nop
     57c:	3714      	adds	r7, #20
     57e:	46bd      	mov	sp, r7
     580:	f85d 7b04 	ldr.w	r7, [sp], #4
     584:	4770      	bx	lr

00000586 <hri_mclk_set_AHBMASK_GMAC_bit>:
	((Mclk *)hw)->AHBMASK.reg ^= MCLK_AHBMASK_QSPI;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_AHBMASK_GMAC_bit(const void *const hw)
{
     586:	b480      	push	{r7}
     588:	b083      	sub	sp, #12
     58a:	af00      	add	r7, sp, #0
     58c:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_GMAC;
     58e:	687b      	ldr	r3, [r7, #4]
     590:	691b      	ldr	r3, [r3, #16]
     592:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
     596:	687b      	ldr	r3, [r7, #4]
     598:	611a      	str	r2, [r3, #16]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     59a:	bf00      	nop
     59c:	370c      	adds	r7, #12
     59e:	46bd      	mov	sp, r7
     5a0:	f85d 7b04 	ldr.w	r7, [sp], #4
     5a4:	4770      	bx	lr

000005a6 <hri_mclk_set_AHBMASK_CAN1_bit>:
	((Mclk *)hw)->AHBMASK.reg ^= MCLK_AHBMASK_CAN0;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_AHBMASK_CAN1_bit(const void *const hw)
{
     5a6:	b480      	push	{r7}
     5a8:	b083      	sub	sp, #12
     5aa:	af00      	add	r7, sp, #0
     5ac:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_CAN1;
     5ae:	687b      	ldr	r3, [r7, #4]
     5b0:	691b      	ldr	r3, [r3, #16]
     5b2:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
     5b6:	687b      	ldr	r3, [r7, #4]
     5b8:	611a      	str	r2, [r3, #16]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     5ba:	bf00      	nop
     5bc:	370c      	adds	r7, #12
     5be:	46bd      	mov	sp, r7
     5c0:	f85d 7b04 	ldr.w	r7, [sp], #4
     5c4:	4770      	bx	lr

000005c6 <hri_mclk_set_APBBMASK_SERCOM2_bit>:
	((Mclk *)hw)->APBBMASK.reg ^= MCLK_APBBMASK_EVSYS;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBBMASK_SERCOM2_bit(const void *const hw)
{
     5c6:	b480      	push	{r7}
     5c8:	b083      	sub	sp, #12
     5ca:	af00      	add	r7, sp, #0
     5cc:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
     5ce:	687b      	ldr	r3, [r7, #4]
     5d0:	699b      	ldr	r3, [r3, #24]
     5d2:	f443 7200 	orr.w	r2, r3, #512	; 0x200
     5d6:	687b      	ldr	r3, [r7, #4]
     5d8:	619a      	str	r2, [r3, #24]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     5da:	bf00      	nop
     5dc:	370c      	adds	r7, #12
     5de:	46bd      	mov	sp, r7
     5e0:	f85d 7b04 	ldr.w	r7, [sp], #4
     5e4:	4770      	bx	lr

000005e6 <hri_mclk_set_APBBMASK_TCC1_bit>:
	((Mclk *)hw)->APBBMASK.reg ^= MCLK_APBBMASK_TCC0;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBBMASK_TCC1_bit(const void *const hw)
{
     5e6:	b480      	push	{r7}
     5e8:	b083      	sub	sp, #12
     5ea:	af00      	add	r7, sp, #0
     5ec:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TCC1;
     5ee:	687b      	ldr	r3, [r7, #4]
     5f0:	699b      	ldr	r3, [r3, #24]
     5f2:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
     5f6:	687b      	ldr	r3, [r7, #4]
     5f8:	619a      	str	r2, [r3, #24]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     5fa:	bf00      	nop
     5fc:	370c      	adds	r7, #12
     5fe:	46bd      	mov	sp, r7
     600:	f85d 7b04 	ldr.w	r7, [sp], #4
     604:	4770      	bx	lr

00000606 <hri_mclk_set_APBCMASK_GMAC_bit>:
{
	return ((Mclk *)hw)->APBBMASK.reg;
}

static inline void hri_mclk_set_APBCMASK_GMAC_bit(const void *const hw)
{
     606:	b480      	push	{r7}
     608:	b083      	sub	sp, #12
     60a:	af00      	add	r7, sp, #0
     60c:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_GMAC;
     60e:	687b      	ldr	r3, [r7, #4]
     610:	69db      	ldr	r3, [r3, #28]
     612:	f043 0204 	orr.w	r2, r3, #4
     616:	687b      	ldr	r3, [r7, #4]
     618:	61da      	str	r2, [r3, #28]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     61a:	bf00      	nop
     61c:	370c      	adds	r7, #12
     61e:	46bd      	mov	sp, r7
     620:	f85d 7b04 	ldr.w	r7, [sp], #4
     624:	4770      	bx	lr

00000626 <hri_mclk_set_APBDMASK_ADC1_bit>:
	((Mclk *)hw)->APBDMASK.reg ^= MCLK_APBDMASK_ADC0;
	MCLK_CRITICAL_SECTION_LEAVE();
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
     626:	b480      	push	{r7}
     628:	b083      	sub	sp, #12
     62a:	af00      	add	r7, sp, #0
     62c:	6078      	str	r0, [r7, #4]
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
     62e:	687b      	ldr	r3, [r7, #4]
     630:	6a1b      	ldr	r3, [r3, #32]
     632:	f443 7280 	orr.w	r2, r3, #256	; 0x100
     636:	687b      	ldr	r3, [r7, #4]
     638:	621a      	str	r2, [r3, #32]
	MCLK_CRITICAL_SECTION_LEAVE();
}
     63a:	bf00      	nop
     63c:	370c      	adds	r7, #12
     63e:	46bd      	mov	sp, r7
     640:	f85d 7b04 	ldr.w	r7, [sp], #4
     644:	4770      	bx	lr

00000646 <hri_port_set_DIR_reg>:
{
	((Port *)hw)->Group[submodule_index].DIRTGL.reg = PORT_DIR_DIR(mask);
}

static inline void hri_port_set_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
     646:	b480      	push	{r7}
     648:	b085      	sub	sp, #20
     64a:	af00      	add	r7, sp, #0
     64c:	60f8      	str	r0, [r7, #12]
     64e:	460b      	mov	r3, r1
     650:	607a      	str	r2, [r7, #4]
     652:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
     654:	7afb      	ldrb	r3, [r7, #11]
     656:	68fa      	ldr	r2, [r7, #12]
     658:	01db      	lsls	r3, r3, #7
     65a:	4413      	add	r3, r2
     65c:	3308      	adds	r3, #8
     65e:	687a      	ldr	r2, [r7, #4]
     660:	601a      	str	r2, [r3, #0]
}
     662:	bf00      	nop
     664:	3714      	adds	r7, #20
     666:	46bd      	mov	sp, r7
     668:	f85d 7b04 	ldr.w	r7, [sp], #4
     66c:	4770      	bx	lr

0000066e <hri_port_clear_DIR_reg>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = data;
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
     66e:	b480      	push	{r7}
     670:	b085      	sub	sp, #20
     672:	af00      	add	r7, sp, #0
     674:	60f8      	str	r0, [r7, #12]
     676:	460b      	mov	r3, r1
     678:	607a      	str	r2, [r7, #4]
     67a:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
     67c:	7afb      	ldrb	r3, [r7, #11]
     67e:	68fa      	ldr	r2, [r7, #12]
     680:	01db      	lsls	r3, r3, #7
     682:	4413      	add	r3, r2
     684:	3304      	adds	r3, #4
     686:	687a      	ldr	r2, [r7, #4]
     688:	601a      	str	r2, [r3, #0]
}
     68a:	bf00      	nop
     68c:	3714      	adds	r7, #20
     68e:	46bd      	mov	sp, r7
     690:	f85d 7b04 	ldr.w	r7, [sp], #4
     694:	4770      	bx	lr

00000696 <hri_port_set_OUT_reg>:
{
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
     696:	b480      	push	{r7}
     698:	b085      	sub	sp, #20
     69a:	af00      	add	r7, sp, #0
     69c:	60f8      	str	r0, [r7, #12]
     69e:	460b      	mov	r3, r1
     6a0:	607a      	str	r2, [r7, #4]
     6a2:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
     6a4:	7afb      	ldrb	r3, [r7, #11]
     6a6:	68fa      	ldr	r2, [r7, #12]
     6a8:	01db      	lsls	r3, r3, #7
     6aa:	4413      	add	r3, r2
     6ac:	3318      	adds	r3, #24
     6ae:	687a      	ldr	r2, [r7, #4]
     6b0:	601a      	str	r2, [r3, #0]
}
     6b2:	bf00      	nop
     6b4:	3714      	adds	r7, #20
     6b6:	46bd      	mov	sp, r7
     6b8:	f85d 7b04 	ldr.w	r7, [sp], #4
     6bc:	4770      	bx	lr

000006be <hri_port_clear_OUT_reg>:
	((Port *)hw)->Group[submodule_index].OUTSET.reg = data;
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
     6be:	b480      	push	{r7}
     6c0:	b085      	sub	sp, #20
     6c2:	af00      	add	r7, sp, #0
     6c4:	60f8      	str	r0, [r7, #12]
     6c6:	460b      	mov	r3, r1
     6c8:	607a      	str	r2, [r7, #4]
     6ca:	72fb      	strb	r3, [r7, #11]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
     6cc:	7afb      	ldrb	r3, [r7, #11]
     6ce:	68fa      	ldr	r2, [r7, #12]
     6d0:	01db      	lsls	r3, r3, #7
     6d2:	4413      	add	r3, r2
     6d4:	3314      	adds	r3, #20
     6d6:	687a      	ldr	r2, [r7, #4]
     6d8:	601a      	str	r2, [r3, #0]
}
     6da:	bf00      	nop
     6dc:	3714      	adds	r7, #20
     6de:	46bd      	mov	sp, r7
     6e0:	f85d 7b04 	ldr.w	r7, [sp], #4
     6e4:	4770      	bx	lr

000006e6 <hri_port_write_PMUX_PMUXE_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXE_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
     6e6:	b480      	push	{r7}
     6e8:	b085      	sub	sp, #20
     6ea:	af00      	add	r7, sp, #0
     6ec:	6078      	str	r0, [r7, #4]
     6ee:	4608      	mov	r0, r1
     6f0:	4611      	mov	r1, r2
     6f2:	461a      	mov	r2, r3
     6f4:	4603      	mov	r3, r0
     6f6:	70fb      	strb	r3, [r7, #3]
     6f8:	460b      	mov	r3, r1
     6fa:	70bb      	strb	r3, [r7, #2]
     6fc:	4613      	mov	r3, r2
     6fe:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     700:	78fa      	ldrb	r2, [r7, #3]
     702:	78bb      	ldrb	r3, [r7, #2]
     704:	6879      	ldr	r1, [r7, #4]
     706:	01d2      	lsls	r2, r2, #7
     708:	440a      	add	r2, r1
     70a:	4413      	add	r3, r2
     70c:	3330      	adds	r3, #48	; 0x30
     70e:	781b      	ldrb	r3, [r3, #0]
     710:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
     712:	7bfb      	ldrb	r3, [r7, #15]
     714:	f023 030f 	bic.w	r3, r3, #15
     718:	73fb      	strb	r3, [r7, #15]
	tmp |= PORT_PMUX_PMUXE(data);
     71a:	787b      	ldrb	r3, [r7, #1]
     71c:	f003 030f 	and.w	r3, r3, #15
     720:	b2da      	uxtb	r2, r3
     722:	7bfb      	ldrb	r3, [r7, #15]
     724:	4313      	orrs	r3, r2
     726:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     728:	78fa      	ldrb	r2, [r7, #3]
     72a:	78bb      	ldrb	r3, [r7, #2]
     72c:	6879      	ldr	r1, [r7, #4]
     72e:	01d2      	lsls	r2, r2, #7
     730:	440a      	add	r2, r1
     732:	4413      	add	r3, r2
     734:	3330      	adds	r3, #48	; 0x30
     736:	7bfa      	ldrb	r2, [r7, #15]
     738:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     73a:	bf00      	nop
     73c:	3714      	adds	r7, #20
     73e:	46bd      	mov	sp, r7
     740:	f85d 7b04 	ldr.w	r7, [sp], #4
     744:	4770      	bx	lr

00000746 <hri_port_write_PMUX_PMUXO_bf>:
	return tmp;
}

static inline void hri_port_write_PMUX_PMUXO_bf(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                hri_port_pmux_reg_t data)
{
     746:	b480      	push	{r7}
     748:	b085      	sub	sp, #20
     74a:	af00      	add	r7, sp, #0
     74c:	6078      	str	r0, [r7, #4]
     74e:	4608      	mov	r0, r1
     750:	4611      	mov	r1, r2
     752:	461a      	mov	r2, r3
     754:	4603      	mov	r3, r0
     756:	70fb      	strb	r3, [r7, #3]
     758:	460b      	mov	r3, r1
     75a:	70bb      	strb	r3, [r7, #2]
     75c:	4613      	mov	r3, r2
     75e:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
     760:	78fa      	ldrb	r2, [r7, #3]
     762:	78bb      	ldrb	r3, [r7, #2]
     764:	6879      	ldr	r1, [r7, #4]
     766:	01d2      	lsls	r2, r2, #7
     768:	440a      	add	r2, r1
     76a:	4413      	add	r3, r2
     76c:	3330      	adds	r3, #48	; 0x30
     76e:	781b      	ldrb	r3, [r3, #0]
     770:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
     772:	7bfb      	ldrb	r3, [r7, #15]
     774:	f003 030f 	and.w	r3, r3, #15
     778:	73fb      	strb	r3, [r7, #15]
	tmp |= PORT_PMUX_PMUXO(data);
     77a:	787b      	ldrb	r3, [r7, #1]
     77c:	011b      	lsls	r3, r3, #4
     77e:	b2da      	uxtb	r2, r3
     780:	7bfb      	ldrb	r3, [r7, #15]
     782:	4313      	orrs	r3, r2
     784:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
     786:	78fa      	ldrb	r2, [r7, #3]
     788:	78bb      	ldrb	r3, [r7, #2]
     78a:	6879      	ldr	r1, [r7, #4]
     78c:	01d2      	lsls	r2, r2, #7
     78e:	440a      	add	r2, r1
     790:	4413      	add	r3, r2
     792:	3330      	adds	r3, #48	; 0x30
     794:	7bfa      	ldrb	r2, [r7, #15]
     796:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     798:	bf00      	nop
     79a:	3714      	adds	r7, #20
     79c:	46bd      	mov	sp, r7
     79e:	f85d 7b04 	ldr.w	r7, [sp], #4
     7a2:	4770      	bx	lr

000007a4 <hri_port_write_PINCFG_PMUXEN_bit>:
	return (bool)tmp;
}

static inline void hri_port_write_PINCFG_PMUXEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index,
                                                    bool value)
{
     7a4:	b480      	push	{r7}
     7a6:	b085      	sub	sp, #20
     7a8:	af00      	add	r7, sp, #0
     7aa:	6078      	str	r0, [r7, #4]
     7ac:	4608      	mov	r0, r1
     7ae:	4611      	mov	r1, r2
     7b0:	461a      	mov	r2, r3
     7b2:	4603      	mov	r3, r0
     7b4:	70fb      	strb	r3, [r7, #3]
     7b6:	460b      	mov	r3, r1
     7b8:	70bb      	strb	r3, [r7, #2]
     7ba:	4613      	mov	r3, r2
     7bc:	707b      	strb	r3, [r7, #1]
	uint8_t tmp;
	PORT_CRITICAL_SECTION_ENTER();
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
     7be:	78fa      	ldrb	r2, [r7, #3]
     7c0:	78bb      	ldrb	r3, [r7, #2]
     7c2:	6879      	ldr	r1, [r7, #4]
     7c4:	01d2      	lsls	r2, r2, #7
     7c6:	440a      	add	r2, r1
     7c8:	4413      	add	r3, r2
     7ca:	3340      	adds	r3, #64	; 0x40
     7cc:	781b      	ldrb	r3, [r3, #0]
     7ce:	73fb      	strb	r3, [r7, #15]
	tmp &= ~PORT_PINCFG_PMUXEN;
     7d0:	7bfb      	ldrb	r3, [r7, #15]
     7d2:	f023 0301 	bic.w	r3, r3, #1
     7d6:	73fb      	strb	r3, [r7, #15]
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
     7d8:	787a      	ldrb	r2, [r7, #1]
     7da:	7bfb      	ldrb	r3, [r7, #15]
     7dc:	4313      	orrs	r3, r2
     7de:	73fb      	strb	r3, [r7, #15]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
     7e0:	78fa      	ldrb	r2, [r7, #3]
     7e2:	78bb      	ldrb	r3, [r7, #2]
     7e4:	6879      	ldr	r1, [r7, #4]
     7e6:	01d2      	lsls	r2, r2, #7
     7e8:	440a      	add	r2, r1
     7ea:	4413      	add	r3, r2
     7ec:	3340      	adds	r3, #64	; 0x40
     7ee:	7bfa      	ldrb	r2, [r7, #15]
     7f0:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     7f2:	bf00      	nop
     7f4:	3714      	adds	r7, #20
     7f6:	46bd      	mov	sp, r7
     7f8:	f85d 7b04 	ldr.w	r7, [sp], #4
     7fc:	4770      	bx	lr

000007fe <hri_port_set_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg ^= PORT_PINCFG_INEN;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_set_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
     7fe:	b490      	push	{r4, r7}
     800:	b082      	sub	sp, #8
     802:	af00      	add	r7, sp, #0
     804:	6078      	str	r0, [r7, #4]
     806:	460b      	mov	r3, r1
     808:	70fb      	strb	r3, [r7, #3]
     80a:	4613      	mov	r3, r2
     80c:	70bb      	strb	r3, [r7, #2]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
     80e:	78fa      	ldrb	r2, [r7, #3]
     810:	78bb      	ldrb	r3, [r7, #2]
     812:	78f8      	ldrb	r0, [r7, #3]
     814:	78b9      	ldrb	r1, [r7, #2]
     816:	687c      	ldr	r4, [r7, #4]
     818:	01c0      	lsls	r0, r0, #7
     81a:	4420      	add	r0, r4
     81c:	4401      	add	r1, r0
     81e:	3140      	adds	r1, #64	; 0x40
     820:	7809      	ldrb	r1, [r1, #0]
     822:	b2c9      	uxtb	r1, r1
     824:	f041 0104 	orr.w	r1, r1, #4
     828:	b2c8      	uxtb	r0, r1
     82a:	6879      	ldr	r1, [r7, #4]
     82c:	01d2      	lsls	r2, r2, #7
     82e:	440a      	add	r2, r1
     830:	4413      	add	r3, r2
     832:	3340      	adds	r3, #64	; 0x40
     834:	4602      	mov	r2, r0
     836:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     838:	bf00      	nop
     83a:	3708      	adds	r7, #8
     83c:	46bd      	mov	sp, r7
     83e:	bc90      	pop	{r4, r7}
     840:	4770      	bx	lr

00000842 <hri_port_clear_PINCFG_PULLEN_bit>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
	PORT_CRITICAL_SECTION_LEAVE();
}

static inline void hri_port_clear_PINCFG_PULLEN_bit(const void *const hw, uint8_t submodule_index, uint8_t index)
{
     842:	b490      	push	{r4, r7}
     844:	b082      	sub	sp, #8
     846:	af00      	add	r7, sp, #0
     848:	6078      	str	r0, [r7, #4]
     84a:	460b      	mov	r3, r1
     84c:	70fb      	strb	r3, [r7, #3]
     84e:	4613      	mov	r3, r2
     850:	70bb      	strb	r3, [r7, #2]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
     852:	78fa      	ldrb	r2, [r7, #3]
     854:	78bb      	ldrb	r3, [r7, #2]
     856:	78f8      	ldrb	r0, [r7, #3]
     858:	78b9      	ldrb	r1, [r7, #2]
     85a:	687c      	ldr	r4, [r7, #4]
     85c:	01c0      	lsls	r0, r0, #7
     85e:	4420      	add	r0, r4
     860:	4401      	add	r1, r0
     862:	3140      	adds	r1, #64	; 0x40
     864:	7809      	ldrb	r1, [r1, #0]
     866:	b2c9      	uxtb	r1, r1
     868:	f021 0104 	bic.w	r1, r1, #4
     86c:	b2c8      	uxtb	r0, r1
     86e:	6879      	ldr	r1, [r7, #4]
     870:	01d2      	lsls	r2, r2, #7
     872:	440a      	add	r2, r1
     874:	4413      	add	r3, r2
     876:	3340      	adds	r3, #64	; 0x40
     878:	4602      	mov	r2, r0
     87a:	701a      	strb	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     87c:	bf00      	nop
     87e:	3708      	adds	r7, #8
     880:	46bd      	mov	sp, r7
     882:	bc90      	pop	{r4, r7}
     884:	4770      	bx	lr

00000886 <hri_port_write_WRCONFIG_reg>:
	return ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
}

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
     886:	b480      	push	{r7}
     888:	b085      	sub	sp, #20
     88a:	af00      	add	r7, sp, #0
     88c:	60f8      	str	r0, [r7, #12]
     88e:	460b      	mov	r3, r1
     890:	607a      	str	r2, [r7, #4]
     892:	72fb      	strb	r3, [r7, #11]
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
     894:	7afb      	ldrb	r3, [r7, #11]
     896:	68fa      	ldr	r2, [r7, #12]
     898:	01db      	lsls	r3, r3, #7
     89a:	4413      	add	r3, r2
     89c:	3328      	adds	r3, #40	; 0x28
     89e:	687a      	ldr	r2, [r7, #4]
     8a0:	601a      	str	r2, [r3, #0]
	PORT_CRITICAL_SECTION_LEAVE();
}
     8a2:	bf00      	nop
     8a4:	3714      	adds	r7, #20
     8a6:	46bd      	mov	sp, r7
     8a8:	f85d 7b04 	ldr.w	r7, [sp], #4
     8ac:	4770      	bx	lr
	...

000008b0 <_gpio_set_direction>:
/**
 * \brief Set direction on port with mask
 */
static inline void _gpio_set_direction(const enum gpio_port port, const uint32_t mask,
                                       const enum gpio_direction direction)
{
     8b0:	b580      	push	{r7, lr}
     8b2:	b082      	sub	sp, #8
     8b4:	af00      	add	r7, sp, #0
     8b6:	4603      	mov	r3, r0
     8b8:	6039      	str	r1, [r7, #0]
     8ba:	71fb      	strb	r3, [r7, #7]
     8bc:	4613      	mov	r3, r2
     8be:	71bb      	strb	r3, [r7, #6]
	switch (direction) {
     8c0:	79bb      	ldrb	r3, [r7, #6]
     8c2:	2b01      	cmp	r3, #1
     8c4:	d01c      	beq.n	900 <_gpio_set_direction+0x50>
     8c6:	2b02      	cmp	r3, #2
     8c8:	d037      	beq.n	93a <_gpio_set_direction+0x8a>
     8ca:	2b00      	cmp	r3, #0
     8cc:	d14e      	bne.n	96c <_gpio_set_direction+0xbc>
	case GPIO_DIRECTION_OFF:
		hri_port_clear_DIR_reg(PORT, port, mask);
     8ce:	79fb      	ldrb	r3, [r7, #7]
     8d0:	683a      	ldr	r2, [r7, #0]
     8d2:	4619      	mov	r1, r3
     8d4:	482a      	ldr	r0, [pc, #168]	; (980 <_gpio_set_direction+0xd0>)
     8d6:	4b2b      	ldr	r3, [pc, #172]	; (984 <_gpio_set_direction+0xd4>)
     8d8:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
     8da:	683b      	ldr	r3, [r7, #0]
     8dc:	b29b      	uxth	r3, r3
     8de:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
     8e2:	79fb      	ldrb	r3, [r7, #7]
     8e4:	4619      	mov	r1, r3
     8e6:	4826      	ldr	r0, [pc, #152]	; (980 <_gpio_set_direction+0xd0>)
     8e8:	4b27      	ldr	r3, [pc, #156]	; (988 <_gpio_set_direction+0xd8>)
     8ea:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
     8ec:	683b      	ldr	r3, [r7, #0]
     8ee:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
     8f0:	f043 4240 	orr.w	r2, r3, #3221225472	; 0xc0000000
     8f4:	79fb      	ldrb	r3, [r7, #7]
     8f6:	4619      	mov	r1, r3
     8f8:	4821      	ldr	r0, [pc, #132]	; (980 <_gpio_set_direction+0xd0>)
     8fa:	4b23      	ldr	r3, [pc, #140]	; (988 <_gpio_set_direction+0xd8>)
     8fc:	4798      	blx	r3
		break;
     8fe:	e03a      	b.n	976 <_gpio_set_direction+0xc6>

	case GPIO_DIRECTION_IN:
		hri_port_clear_DIR_reg(PORT, port, mask);
     900:	79fb      	ldrb	r3, [r7, #7]
     902:	683a      	ldr	r2, [r7, #0]
     904:	4619      	mov	r1, r3
     906:	481e      	ldr	r0, [pc, #120]	; (980 <_gpio_set_direction+0xd0>)
     908:	4b1e      	ldr	r3, [pc, #120]	; (984 <_gpio_set_direction+0xd4>)
     90a:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
     90c:	683b      	ldr	r3, [r7, #0]
     90e:	b29b      	uxth	r3, r3
     910:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
     914:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     918:	79f9      	ldrb	r1, [r7, #7]
     91a:	461a      	mov	r2, r3
     91c:	4818      	ldr	r0, [pc, #96]	; (980 <_gpio_set_direction+0xd0>)
     91e:	4b1a      	ldr	r3, [pc, #104]	; (988 <_gpio_set_direction+0xd8>)
     920:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT,
		                            port,
		                            PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN
		                                | ((mask & 0xffff0000) >> 16));
     922:	683b      	ldr	r3, [r7, #0]
     924:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(PORT,
     926:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
     92a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
     92e:	79f9      	ldrb	r1, [r7, #7]
     930:	461a      	mov	r2, r3
     932:	4813      	ldr	r0, [pc, #76]	; (980 <_gpio_set_direction+0xd0>)
     934:	4b14      	ldr	r3, [pc, #80]	; (988 <_gpio_set_direction+0xd8>)
     936:	4798      	blx	r3
		break;
     938:	e01d      	b.n	976 <_gpio_set_direction+0xc6>

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT, port, mask);
     93a:	79fb      	ldrb	r3, [r7, #7]
     93c:	683a      	ldr	r2, [r7, #0]
     93e:	4619      	mov	r1, r3
     940:	480f      	ldr	r0, [pc, #60]	; (980 <_gpio_set_direction+0xd0>)
     942:	4b12      	ldr	r3, [pc, #72]	; (98c <_gpio_set_direction+0xdc>)
     944:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
     946:	683b      	ldr	r3, [r7, #0]
     948:	b29b      	uxth	r3, r3
     94a:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
     94e:	79fb      	ldrb	r3, [r7, #7]
     950:	4619      	mov	r1, r3
     952:	480b      	ldr	r0, [pc, #44]	; (980 <_gpio_set_direction+0xd0>)
     954:	4b0c      	ldr	r3, [pc, #48]	; (988 <_gpio_set_direction+0xd8>)
     956:	4798      	blx	r3
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
     958:	683b      	ldr	r3, [r7, #0]
     95a:	0c1b      	lsrs	r3, r3, #16
		hri_port_write_WRCONFIG_reg(
     95c:	f043 4240 	orr.w	r2, r3, #3221225472	; 0xc0000000
     960:	79fb      	ldrb	r3, [r7, #7]
     962:	4619      	mov	r1, r3
     964:	4806      	ldr	r0, [pc, #24]	; (980 <_gpio_set_direction+0xd0>)
     966:	4b08      	ldr	r3, [pc, #32]	; (988 <_gpio_set_direction+0xd8>)
     968:	4798      	blx	r3
		break;
     96a:	e004      	b.n	976 <_gpio_set_direction+0xc6>

	default:
		ASSERT(false);
     96c:	2246      	movs	r2, #70	; 0x46
     96e:	4908      	ldr	r1, [pc, #32]	; (990 <_gpio_set_direction+0xe0>)
     970:	2000      	movs	r0, #0
     972:	4b08      	ldr	r3, [pc, #32]	; (994 <_gpio_set_direction+0xe4>)
     974:	4798      	blx	r3
	}
}
     976:	bf00      	nop
     978:	3708      	adds	r7, #8
     97a:	46bd      	mov	sp, r7
     97c:	bd80      	pop	{r7, pc}
     97e:	bf00      	nop
     980:	41008000 	.word	0x41008000
     984:	0000066f 	.word	0x0000066f
     988:	00000887 	.word	0x00000887
     98c:	00000647 	.word	0x00000647
     990:	0000464c 	.word	0x0000464c
     994:	0000168d 	.word	0x0000168d

00000998 <_gpio_set_level>:

/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
     998:	b580      	push	{r7, lr}
     99a:	b082      	sub	sp, #8
     99c:	af00      	add	r7, sp, #0
     99e:	4603      	mov	r3, r0
     9a0:	6039      	str	r1, [r7, #0]
     9a2:	71fb      	strb	r3, [r7, #7]
     9a4:	4613      	mov	r3, r2
     9a6:	71bb      	strb	r3, [r7, #6]
	if (level) {
     9a8:	79bb      	ldrb	r3, [r7, #6]
     9aa:	2b00      	cmp	r3, #0
     9ac:	d006      	beq.n	9bc <_gpio_set_level+0x24>
		hri_port_set_OUT_reg(PORT, port, mask);
     9ae:	79fb      	ldrb	r3, [r7, #7]
     9b0:	683a      	ldr	r2, [r7, #0]
     9b2:	4619      	mov	r1, r3
     9b4:	4806      	ldr	r0, [pc, #24]	; (9d0 <_gpio_set_level+0x38>)
     9b6:	4b07      	ldr	r3, [pc, #28]	; (9d4 <_gpio_set_level+0x3c>)
     9b8:	4798      	blx	r3
	} else {
		hri_port_clear_OUT_reg(PORT, port, mask);
	}
}
     9ba:	e005      	b.n	9c8 <_gpio_set_level+0x30>
		hri_port_clear_OUT_reg(PORT, port, mask);
     9bc:	79fb      	ldrb	r3, [r7, #7]
     9be:	683a      	ldr	r2, [r7, #0]
     9c0:	4619      	mov	r1, r3
     9c2:	4803      	ldr	r0, [pc, #12]	; (9d0 <_gpio_set_level+0x38>)
     9c4:	4b04      	ldr	r3, [pc, #16]	; (9d8 <_gpio_set_level+0x40>)
     9c6:	4798      	blx	r3
}
     9c8:	bf00      	nop
     9ca:	3708      	adds	r7, #8
     9cc:	46bd      	mov	sp, r7
     9ce:	bd80      	pop	{r7, pc}
     9d0:	41008000 	.word	0x41008000
     9d4:	00000697 	.word	0x00000697
     9d8:	000006bf 	.word	0x000006bf

000009dc <_gpio_set_pin_pull_mode>:
/**
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
     9dc:	b580      	push	{r7, lr}
     9de:	b082      	sub	sp, #8
     9e0:	af00      	add	r7, sp, #0
     9e2:	4603      	mov	r3, r0
     9e4:	71fb      	strb	r3, [r7, #7]
     9e6:	460b      	mov	r3, r1
     9e8:	71bb      	strb	r3, [r7, #6]
     9ea:	4613      	mov	r3, r2
     9ec:	717b      	strb	r3, [r7, #5]
	switch (pull_mode) {
     9ee:	797b      	ldrb	r3, [r7, #5]
     9f0:	2b01      	cmp	r3, #1
     9f2:	d00a      	beq.n	a0a <_gpio_set_pin_pull_mode+0x2e>
     9f4:	2b02      	cmp	r3, #2
     9f6:	d01f      	beq.n	a38 <_gpio_set_pin_pull_mode+0x5c>
     9f8:	2b00      	cmp	r3, #0
     9fa:	d134      	bne.n	a66 <_gpio_set_pin_pull_mode+0x8a>
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
     9fc:	79ba      	ldrb	r2, [r7, #6]
     9fe:	79fb      	ldrb	r3, [r7, #7]
     a00:	4619      	mov	r1, r3
     a02:	481e      	ldr	r0, [pc, #120]	; (a7c <_gpio_set_pin_pull_mode+0xa0>)
     a04:	4b1e      	ldr	r3, [pc, #120]	; (a80 <_gpio_set_pin_pull_mode+0xa4>)
     a06:	4798      	blx	r3
		break;
     a08:	e033      	b.n	a72 <_gpio_set_pin_pull_mode+0x96>

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
     a0a:	79bb      	ldrb	r3, [r7, #6]
     a0c:	2201      	movs	r2, #1
     a0e:	409a      	lsls	r2, r3
     a10:	79fb      	ldrb	r3, [r7, #7]
     a12:	4619      	mov	r1, r3
     a14:	4819      	ldr	r0, [pc, #100]	; (a7c <_gpio_set_pin_pull_mode+0xa0>)
     a16:	4b1b      	ldr	r3, [pc, #108]	; (a84 <_gpio_set_pin_pull_mode+0xa8>)
     a18:	4798      	blx	r3
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
     a1a:	79ba      	ldrb	r2, [r7, #6]
     a1c:	79fb      	ldrb	r3, [r7, #7]
     a1e:	4619      	mov	r1, r3
     a20:	4816      	ldr	r0, [pc, #88]	; (a7c <_gpio_set_pin_pull_mode+0xa0>)
     a22:	4b19      	ldr	r3, [pc, #100]	; (a88 <_gpio_set_pin_pull_mode+0xac>)
     a24:	4798      	blx	r3
		hri_port_set_OUT_reg(PORT, port, 1U << pin);
     a26:	79bb      	ldrb	r3, [r7, #6]
     a28:	2201      	movs	r2, #1
     a2a:	409a      	lsls	r2, r3
     a2c:	79fb      	ldrb	r3, [r7, #7]
     a2e:	4619      	mov	r1, r3
     a30:	4812      	ldr	r0, [pc, #72]	; (a7c <_gpio_set_pin_pull_mode+0xa0>)
     a32:	4b16      	ldr	r3, [pc, #88]	; (a8c <_gpio_set_pin_pull_mode+0xb0>)
     a34:	4798      	blx	r3
		break;
     a36:	e01c      	b.n	a72 <_gpio_set_pin_pull_mode+0x96>

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
     a38:	79bb      	ldrb	r3, [r7, #6]
     a3a:	2201      	movs	r2, #1
     a3c:	409a      	lsls	r2, r3
     a3e:	79fb      	ldrb	r3, [r7, #7]
     a40:	4619      	mov	r1, r3
     a42:	480e      	ldr	r0, [pc, #56]	; (a7c <_gpio_set_pin_pull_mode+0xa0>)
     a44:	4b0f      	ldr	r3, [pc, #60]	; (a84 <_gpio_set_pin_pull_mode+0xa8>)
     a46:	4798      	blx	r3
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
     a48:	79ba      	ldrb	r2, [r7, #6]
     a4a:	79fb      	ldrb	r3, [r7, #7]
     a4c:	4619      	mov	r1, r3
     a4e:	480b      	ldr	r0, [pc, #44]	; (a7c <_gpio_set_pin_pull_mode+0xa0>)
     a50:	4b0d      	ldr	r3, [pc, #52]	; (a88 <_gpio_set_pin_pull_mode+0xac>)
     a52:	4798      	blx	r3
		hri_port_clear_OUT_reg(PORT, port, 1U << pin);
     a54:	79bb      	ldrb	r3, [r7, #6]
     a56:	2201      	movs	r2, #1
     a58:	409a      	lsls	r2, r3
     a5a:	79fb      	ldrb	r3, [r7, #7]
     a5c:	4619      	mov	r1, r3
     a5e:	4807      	ldr	r0, [pc, #28]	; (a7c <_gpio_set_pin_pull_mode+0xa0>)
     a60:	4b0b      	ldr	r3, [pc, #44]	; (a90 <_gpio_set_pin_pull_mode+0xb4>)
     a62:	4798      	blx	r3
		break;
     a64:	e005      	b.n	a72 <_gpio_set_pin_pull_mode+0x96>

	default:
		ASSERT(false);
     a66:	2289      	movs	r2, #137	; 0x89
     a68:	490a      	ldr	r1, [pc, #40]	; (a94 <_gpio_set_pin_pull_mode+0xb8>)
     a6a:	2000      	movs	r0, #0
     a6c:	4b0a      	ldr	r3, [pc, #40]	; (a98 <_gpio_set_pin_pull_mode+0xbc>)
     a6e:	4798      	blx	r3
		break;
     a70:	bf00      	nop
	}
}
     a72:	bf00      	nop
     a74:	3708      	adds	r7, #8
     a76:	46bd      	mov	sp, r7
     a78:	bd80      	pop	{r7, pc}
     a7a:	bf00      	nop
     a7c:	41008000 	.word	0x41008000
     a80:	00000843 	.word	0x00000843
     a84:	0000066f 	.word	0x0000066f
     a88:	000007ff 	.word	0x000007ff
     a8c:	00000697 	.word	0x00000697
     a90:	000006bf 	.word	0x000006bf
     a94:	0000464c 	.word	0x0000464c
     a98:	0000168d 	.word	0x0000168d

00000a9c <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
     a9c:	b590      	push	{r4, r7, lr}
     a9e:	b085      	sub	sp, #20
     aa0:	af00      	add	r7, sp, #0
     aa2:	6078      	str	r0, [r7, #4]
     aa4:	6039      	str	r1, [r7, #0]
	uint8_t port = GPIO_PORT(gpio);
     aa6:	687b      	ldr	r3, [r7, #4]
     aa8:	095b      	lsrs	r3, r3, #5
     aaa:	73fb      	strb	r3, [r7, #15]
	uint8_t pin  = GPIO_PIN(gpio);
     aac:	687b      	ldr	r3, [r7, #4]
     aae:	b2db      	uxtb	r3, r3
     ab0:	f003 031f 	and.w	r3, r3, #31
     ab4:	73bb      	strb	r3, [r7, #14]

	if (function == GPIO_PIN_FUNCTION_OFF) {
     ab6:	683b      	ldr	r3, [r7, #0]
     ab8:	f1b3 3fff 	cmp.w	r3, #4294967295
     abc:	d106      	bne.n	acc <_gpio_set_pin_function+0x30>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, false);
     abe:	7bba      	ldrb	r2, [r7, #14]
     ac0:	7bf9      	ldrb	r1, [r7, #15]
     ac2:	2300      	movs	r3, #0
     ac4:	4812      	ldr	r0, [pc, #72]	; (b10 <_gpio_set_pin_function+0x74>)
     ac6:	4c13      	ldr	r4, [pc, #76]	; (b14 <_gpio_set_pin_function+0x78>)
     ac8:	47a0      	blx	r4
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
     aca:	e01d      	b.n	b08 <_gpio_set_pin_function+0x6c>
		hri_port_write_PINCFG_PMUXEN_bit(PORT, port, pin, true);
     acc:	7bba      	ldrb	r2, [r7, #14]
     ace:	7bf9      	ldrb	r1, [r7, #15]
     ad0:	2301      	movs	r3, #1
     ad2:	480f      	ldr	r0, [pc, #60]	; (b10 <_gpio_set_pin_function+0x74>)
     ad4:	4c0f      	ldr	r4, [pc, #60]	; (b14 <_gpio_set_pin_function+0x78>)
     ad6:	47a0      	blx	r4
		if (pin & 1) {
     ad8:	7bbb      	ldrb	r3, [r7, #14]
     ada:	f003 0301 	and.w	r3, r3, #1
     ade:	2b00      	cmp	r3, #0
     ae0:	d009      	beq.n	af6 <_gpio_set_pin_function+0x5a>
			hri_port_write_PMUX_PMUXO_bf(PORT, port, pin >> 1, function & 0xffff);
     ae2:	7bbb      	ldrb	r3, [r7, #14]
     ae4:	085b      	lsrs	r3, r3, #1
     ae6:	b2da      	uxtb	r2, r3
     ae8:	683b      	ldr	r3, [r7, #0]
     aea:	b2db      	uxtb	r3, r3
     aec:	7bf9      	ldrb	r1, [r7, #15]
     aee:	4808      	ldr	r0, [pc, #32]	; (b10 <_gpio_set_pin_function+0x74>)
     af0:	4c09      	ldr	r4, [pc, #36]	; (b18 <_gpio_set_pin_function+0x7c>)
     af2:	47a0      	blx	r4
}
     af4:	e008      	b.n	b08 <_gpio_set_pin_function+0x6c>
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
     af6:	7bbb      	ldrb	r3, [r7, #14]
     af8:	085b      	lsrs	r3, r3, #1
     afa:	b2da      	uxtb	r2, r3
     afc:	683b      	ldr	r3, [r7, #0]
     afe:	b2db      	uxtb	r3, r3
     b00:	7bf9      	ldrb	r1, [r7, #15]
     b02:	4803      	ldr	r0, [pc, #12]	; (b10 <_gpio_set_pin_function+0x74>)
     b04:	4c05      	ldr	r4, [pc, #20]	; (b1c <_gpio_set_pin_function+0x80>)
     b06:	47a0      	blx	r4
}
     b08:	bf00      	nop
     b0a:	3714      	adds	r7, #20
     b0c:	46bd      	mov	sp, r7
     b0e:	bd90      	pop	{r4, r7, pc}
     b10:	41008000 	.word	0x41008000
     b14:	000007a5 	.word	0x000007a5
     b18:	00000747 	.word	0x00000747
     b1c:	000006e7 	.word	0x000006e7

00000b20 <gpio_set_pin_pull_mode>:
 * \param[in] pull_mode GPIO_PULL_DOWN = Pull pin low with internal resistor
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
     b20:	b580      	push	{r7, lr}
     b22:	b082      	sub	sp, #8
     b24:	af00      	add	r7, sp, #0
     b26:	4603      	mov	r3, r0
     b28:	460a      	mov	r2, r1
     b2a:	71fb      	strb	r3, [r7, #7]
     b2c:	4613      	mov	r3, r2
     b2e:	71bb      	strb	r3, [r7, #6]
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
     b30:	79fb      	ldrb	r3, [r7, #7]
     b32:	095b      	lsrs	r3, r3, #5
     b34:	b2d8      	uxtb	r0, r3
     b36:	79fb      	ldrb	r3, [r7, #7]
     b38:	f003 031f 	and.w	r3, r3, #31
     b3c:	b2db      	uxtb	r3, r3
     b3e:	79ba      	ldrb	r2, [r7, #6]
     b40:	4619      	mov	r1, r3
     b42:	4b03      	ldr	r3, [pc, #12]	; (b50 <gpio_set_pin_pull_mode+0x30>)
     b44:	4798      	blx	r3
}
     b46:	bf00      	nop
     b48:	3708      	adds	r7, #8
     b4a:	46bd      	mov	sp, r7
     b4c:	bd80      	pop	{r7, pc}
     b4e:	bf00      	nop
     b50:	000009dd 	.word	0x000009dd

00000b54 <gpio_set_pin_function>:
 * \param[in] function  The pin function is given by a 32-bit wide bitfield
 *                      found in the header files for the device
 *
 */
static inline void gpio_set_pin_function(const uint32_t pin, uint32_t function)
{
     b54:	b580      	push	{r7, lr}
     b56:	b082      	sub	sp, #8
     b58:	af00      	add	r7, sp, #0
     b5a:	6078      	str	r0, [r7, #4]
     b5c:	6039      	str	r1, [r7, #0]
	_gpio_set_pin_function(pin, function);
     b5e:	6839      	ldr	r1, [r7, #0]
     b60:	6878      	ldr	r0, [r7, #4]
     b62:	4b03      	ldr	r3, [pc, #12]	; (b70 <gpio_set_pin_function+0x1c>)
     b64:	4798      	blx	r3
}
     b66:	bf00      	nop
     b68:	3708      	adds	r7, #8
     b6a:	46bd      	mov	sp, r7
     b6c:	bd80      	pop	{r7, pc}
     b6e:	bf00      	nop
     b70:	00000a9d 	.word	0x00000a9d

00000b74 <gpio_set_pin_direction>:
 *                      GPIO_DIRECTION_OUT = Data direction out
 *                      GPIO_DIRECTION_OFF = Disables the pin
 *                      (low power state)
 */
static inline void gpio_set_pin_direction(const uint8_t pin, const enum gpio_direction direction)
{
     b74:	b580      	push	{r7, lr}
     b76:	b082      	sub	sp, #8
     b78:	af00      	add	r7, sp, #0
     b7a:	4603      	mov	r3, r0
     b7c:	460a      	mov	r2, r1
     b7e:	71fb      	strb	r3, [r7, #7]
     b80:	4613      	mov	r3, r2
     b82:	71bb      	strb	r3, [r7, #6]
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
     b84:	79fb      	ldrb	r3, [r7, #7]
     b86:	095b      	lsrs	r3, r3, #5
     b88:	b2d8      	uxtb	r0, r3
     b8a:	79fb      	ldrb	r3, [r7, #7]
     b8c:	f003 031f 	and.w	r3, r3, #31
     b90:	2201      	movs	r2, #1
     b92:	fa02 f303 	lsl.w	r3, r2, r3
     b96:	79ba      	ldrb	r2, [r7, #6]
     b98:	4619      	mov	r1, r3
     b9a:	4b03      	ldr	r3, [pc, #12]	; (ba8 <gpio_set_pin_direction+0x34>)
     b9c:	4798      	blx	r3
}
     b9e:	bf00      	nop
     ba0:	3708      	adds	r7, #8
     ba2:	46bd      	mov	sp, r7
     ba4:	bd80      	pop	{r7, pc}
     ba6:	bf00      	nop
     ba8:	000008b1 	.word	0x000008b1

00000bac <gpio_set_pin_level>:
 * \param[in] pin       The pin number for device
 * \param[in] level true  = Pin level set to "high" state
 *                  false = Pin level set to "low" state
 */
static inline void gpio_set_pin_level(const uint8_t pin, const bool level)
{
     bac:	b580      	push	{r7, lr}
     bae:	b082      	sub	sp, #8
     bb0:	af00      	add	r7, sp, #0
     bb2:	4603      	mov	r3, r0
     bb4:	460a      	mov	r2, r1
     bb6:	71fb      	strb	r3, [r7, #7]
     bb8:	4613      	mov	r3, r2
     bba:	71bb      	strb	r3, [r7, #6]
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
     bbc:	79fb      	ldrb	r3, [r7, #7]
     bbe:	095b      	lsrs	r3, r3, #5
     bc0:	b2d8      	uxtb	r0, r3
     bc2:	79fb      	ldrb	r3, [r7, #7]
     bc4:	f003 031f 	and.w	r3, r3, #31
     bc8:	2201      	movs	r2, #1
     bca:	fa02 f303 	lsl.w	r3, r2, r3
     bce:	79ba      	ldrb	r2, [r7, #6]
     bd0:	4619      	mov	r1, r3
     bd2:	4b03      	ldr	r3, [pc, #12]	; (be0 <gpio_set_pin_level+0x34>)
     bd4:	4798      	blx	r3
}
     bd6:	bf00      	nop
     bd8:	3708      	adds	r7, #8
     bda:	46bd      	mov	sp, r7
     bdc:	bd80      	pop	{r7, pc}
     bde:	bf00      	nop
     be0:	00000999 	.word	0x00000999

00000be4 <init_mcu>:
 * This function calls the various initialization functions.
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
     be4:	b580      	push	{r7, lr}
     be6:	af00      	add	r7, sp, #0
	_init_chip();
     be8:	4b01      	ldr	r3, [pc, #4]	; (bf0 <init_mcu+0xc>)
     bea:	4798      	blx	r3
}
     bec:	bf00      	nop
     bee:	bd80      	pop	{r7, pc}
     bf0:	000025ad 	.word	0x000025ad

00000bf4 <ADC_0_PORT_init>:
struct usart_sync_descriptor TARGET_IO;

struct mac_async_descriptor COMMUNICATION_IO;

void ADC_0_PORT_init(void)
{
     bf4:	b580      	push	{r7, lr}
     bf6:	af00      	add	r7, sp, #0
	// Disable digital pin circuitry
	gpio_set_pin_direction(SteeringPosition, GPIO_DIRECTION_OFF);
     bf8:	2100      	movs	r1, #0
     bfa:	2028      	movs	r0, #40	; 0x28
     bfc:	4b03      	ldr	r3, [pc, #12]	; (c0c <ADC_0_PORT_init+0x18>)
     bfe:	4798      	blx	r3
	gpio_set_pin_function(SteeringPosition, PINMUX_PB08B_ADC1_AIN0);
     c00:	4903      	ldr	r1, [pc, #12]	; (c10 <ADC_0_PORT_init+0x1c>)
     c02:	2028      	movs	r0, #40	; 0x28
     c04:	4b03      	ldr	r3, [pc, #12]	; (c14 <ADC_0_PORT_init+0x20>)
     c06:	4798      	blx	r3
}
     c08:	bf00      	nop
     c0a:	bd80      	pop	{r7, pc}
     c0c:	00000b75 	.word	0x00000b75
     c10:	00280001 	.word	0x00280001
     c14:	00000b55 	.word	0x00000b55

00000c18 <ADC_0_CLOCK_init>:

void ADC_0_CLOCK_init(void)
{
     c18:	b580      	push	{r7, lr}
     c1a:	af00      	add	r7, sp, #0
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
     c1c:	4804      	ldr	r0, [pc, #16]	; (c30 <ADC_0_CLOCK_init+0x18>)
     c1e:	4b05      	ldr	r3, [pc, #20]	; (c34 <ADC_0_CLOCK_init+0x1c>)
     c20:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     c22:	2240      	movs	r2, #64	; 0x40
     c24:	2129      	movs	r1, #41	; 0x29
     c26:	4804      	ldr	r0, [pc, #16]	; (c38 <ADC_0_CLOCK_init+0x20>)
     c28:	4b04      	ldr	r3, [pc, #16]	; (c3c <ADC_0_CLOCK_init+0x24>)
     c2a:	4798      	blx	r3
}
     c2c:	bf00      	nop
     c2e:	bd80      	pop	{r7, pc}
     c30:	40000800 	.word	0x40000800
     c34:	00000627 	.word	0x00000627
     c38:	40001c00 	.word	0x40001c00
     c3c:	00000561 	.word	0x00000561

00000c40 <ADC_0_init>:

void ADC_0_init(void)
{
     c40:	b580      	push	{r7, lr}
     c42:	af00      	add	r7, sp, #0
	ADC_0_CLOCK_init();
     c44:	4b07      	ldr	r3, [pc, #28]	; (c64 <ADC_0_init+0x24>)
     c46:	4798      	blx	r3
	ADC_0_PORT_init();
     c48:	4b07      	ldr	r3, [pc, #28]	; (c68 <ADC_0_init+0x28>)
     c4a:	4798      	blx	r3
	adc_sync_init(&ADC_0, ADC1, (void *)NULL);
     c4c:	2200      	movs	r2, #0
     c4e:	4907      	ldr	r1, [pc, #28]	; (c6c <ADC_0_init+0x2c>)
     c50:	4807      	ldr	r0, [pc, #28]	; (c70 <ADC_0_init+0x30>)
     c52:	4b08      	ldr	r3, [pc, #32]	; (c74 <ADC_0_init+0x34>)
     c54:	4798      	blx	r3
	adc_sync_enable_channel(&ADC_0, 0);
     c56:	2100      	movs	r1, #0
     c58:	4805      	ldr	r0, [pc, #20]	; (c70 <ADC_0_init+0x30>)
     c5a:	4b07      	ldr	r3, [pc, #28]	; (c78 <ADC_0_init+0x38>)
     c5c:	4798      	blx	r3
}
     c5e:	bf00      	nop
     c60:	bd80      	pop	{r7, pc}
     c62:	bf00      	nop
     c64:	00000c19 	.word	0x00000c19
     c68:	00000bf5 	.word	0x00000bf5
     c6c:	43002000 	.word	0x43002000
     c70:	200016dc 	.word	0x200016dc
     c74:	000010ad 	.word	0x000010ad
     c78:	000010fd 	.word	0x000010fd

00000c7c <TARGET_IO_PORT_init>:

void TARGET_IO_PORT_init(void)
{
     c7c:	b580      	push	{r7, lr}
     c7e:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);
     c80:	4904      	ldr	r1, [pc, #16]	; (c94 <TARGET_IO_PORT_init+0x18>)
     c82:	2039      	movs	r0, #57	; 0x39
     c84:	4b04      	ldr	r3, [pc, #16]	; (c98 <TARGET_IO_PORT_init+0x1c>)
     c86:	4798      	blx	r3

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
     c88:	4904      	ldr	r1, [pc, #16]	; (c9c <TARGET_IO_PORT_init+0x20>)
     c8a:	2038      	movs	r0, #56	; 0x38
     c8c:	4b02      	ldr	r3, [pc, #8]	; (c98 <TARGET_IO_PORT_init+0x1c>)
     c8e:	4798      	blx	r3
}
     c90:	bf00      	nop
     c92:	bd80      	pop	{r7, pc}
     c94:	00390003 	.word	0x00390003
     c98:	00000b55 	.word	0x00000b55
     c9c:	00380003 	.word	0x00380003

00000ca0 <TARGET_IO_CLOCK_init>:

void TARGET_IO_CLOCK_init(void)
{
     ca0:	b580      	push	{r7, lr}
     ca2:	af00      	add	r7, sp, #0
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     ca4:	2240      	movs	r2, #64	; 0x40
     ca6:	2117      	movs	r1, #23
     ca8:	4806      	ldr	r0, [pc, #24]	; (cc4 <TARGET_IO_CLOCK_init+0x24>)
     caa:	4b07      	ldr	r3, [pc, #28]	; (cc8 <TARGET_IO_CLOCK_init+0x28>)
     cac:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     cae:	2243      	movs	r2, #67	; 0x43
     cb0:	2103      	movs	r1, #3
     cb2:	4804      	ldr	r0, [pc, #16]	; (cc4 <TARGET_IO_CLOCK_init+0x24>)
     cb4:	4b04      	ldr	r3, [pc, #16]	; (cc8 <TARGET_IO_CLOCK_init+0x28>)
     cb6:	4798      	blx	r3

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
     cb8:	4804      	ldr	r0, [pc, #16]	; (ccc <TARGET_IO_CLOCK_init+0x2c>)
     cba:	4b05      	ldr	r3, [pc, #20]	; (cd0 <TARGET_IO_CLOCK_init+0x30>)
     cbc:	4798      	blx	r3
}
     cbe:	bf00      	nop
     cc0:	bd80      	pop	{r7, pc}
     cc2:	bf00      	nop
     cc4:	40001c00 	.word	0x40001c00
     cc8:	00000561 	.word	0x00000561
     ccc:	40000800 	.word	0x40000800
     cd0:	000005c7 	.word	0x000005c7

00000cd4 <TARGET_IO_init>:

void TARGET_IO_init(void)
{
     cd4:	b580      	push	{r7, lr}
     cd6:	af00      	add	r7, sp, #0
	TARGET_IO_CLOCK_init();
     cd8:	4b05      	ldr	r3, [pc, #20]	; (cf0 <TARGET_IO_init+0x1c>)
     cda:	4798      	blx	r3
	usart_sync_init(&TARGET_IO, SERCOM2, (void *)NULL);
     cdc:	2200      	movs	r2, #0
     cde:	4905      	ldr	r1, [pc, #20]	; (cf4 <TARGET_IO_init+0x20>)
     ce0:	4805      	ldr	r0, [pc, #20]	; (cf8 <TARGET_IO_init+0x24>)
     ce2:	4b06      	ldr	r3, [pc, #24]	; (cfc <TARGET_IO_init+0x28>)
     ce4:	4798      	blx	r3
	TARGET_IO_PORT_init();
     ce6:	4b06      	ldr	r3, [pc, #24]	; (d00 <TARGET_IO_init+0x2c>)
     ce8:	4798      	blx	r3
}
     cea:	bf00      	nop
     cec:	bd80      	pop	{r7, pc}
     cee:	bf00      	nop
     cf0:	00000ca1 	.word	0x00000ca1
     cf4:	41012000 	.word	0x41012000
     cf8:	200016d0 	.word	0x200016d0
     cfc:	00001481 	.word	0x00001481
     d00:	00000c7d 	.word	0x00000c7d

00000d04 <PWM_0_PORT_init>:

void PWM_0_PORT_init(void)
{
     d04:	b580      	push	{r7, lr}
     d06:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PC14, PINMUX_PC14G_TCC1_WO0);
     d08:	490e      	ldr	r1, [pc, #56]	; (d44 <PWM_0_PORT_init+0x40>)
     d0a:	204e      	movs	r0, #78	; 0x4e
     d0c:	4b0e      	ldr	r3, [pc, #56]	; (d48 <PWM_0_PORT_init+0x44>)
     d0e:	4798      	blx	r3

	gpio_set_pin_function(VehicleSpeed, PINMUX_PB26F_TCC1_WO2);
     d10:	490e      	ldr	r1, [pc, #56]	; (d4c <PWM_0_PORT_init+0x48>)
     d12:	203a      	movs	r0, #58	; 0x3a
     d14:	4b0c      	ldr	r3, [pc, #48]	; (d48 <PWM_0_PORT_init+0x44>)
     d16:	4798      	blx	r3

	gpio_set_pin_function(SteeringTorque, PINMUX_PB27F_TCC1_WO3);
     d18:	490d      	ldr	r1, [pc, #52]	; (d50 <PWM_0_PORT_init+0x4c>)
     d1a:	203b      	movs	r0, #59	; 0x3b
     d1c:	4b0a      	ldr	r3, [pc, #40]	; (d48 <PWM_0_PORT_init+0x44>)
     d1e:	4798      	blx	r3

	gpio_set_pin_function(FrontBrake, PINMUX_PB28F_TCC1_WO4);
     d20:	490c      	ldr	r1, [pc, #48]	; (d54 <PWM_0_PORT_init+0x50>)
     d22:	203c      	movs	r0, #60	; 0x3c
     d24:	4b08      	ldr	r3, [pc, #32]	; (d48 <PWM_0_PORT_init+0x44>)
     d26:	4798      	blx	r3

	gpio_set_pin_function(RearBrake, PINMUX_PB29F_TCC1_WO5);
     d28:	490b      	ldr	r1, [pc, #44]	; (d58 <PWM_0_PORT_init+0x54>)
     d2a:	203d      	movs	r0, #61	; 0x3d
     d2c:	4b06      	ldr	r3, [pc, #24]	; (d48 <PWM_0_PORT_init+0x44>)
     d2e:	4798      	blx	r3

	gpio_set_pin_function(PA22, PINMUX_PA22F_TCC1_WO6);
     d30:	490a      	ldr	r1, [pc, #40]	; (d5c <PWM_0_PORT_init+0x58>)
     d32:	2016      	movs	r0, #22
     d34:	4b04      	ldr	r3, [pc, #16]	; (d48 <PWM_0_PORT_init+0x44>)
     d36:	4798      	blx	r3

	gpio_set_pin_function(PA23, PINMUX_PA23F_TCC1_WO7);
     d38:	4909      	ldr	r1, [pc, #36]	; (d60 <PWM_0_PORT_init+0x5c>)
     d3a:	2017      	movs	r0, #23
     d3c:	4b02      	ldr	r3, [pc, #8]	; (d48 <PWM_0_PORT_init+0x44>)
     d3e:	4798      	blx	r3
}
     d40:	bf00      	nop
     d42:	bd80      	pop	{r7, pc}
     d44:	004e0006 	.word	0x004e0006
     d48:	00000b55 	.word	0x00000b55
     d4c:	003a0005 	.word	0x003a0005
     d50:	003b0005 	.word	0x003b0005
     d54:	003c0005 	.word	0x003c0005
     d58:	003d0005 	.word	0x003d0005
     d5c:	00160005 	.word	0x00160005
     d60:	00170005 	.word	0x00170005

00000d64 <PWM_0_CLOCK_init>:

void PWM_0_CLOCK_init(void)
{
     d64:	b580      	push	{r7, lr}
     d66:	af00      	add	r7, sp, #0
	hri_mclk_set_APBBMASK_TCC1_bit(MCLK);
     d68:	4804      	ldr	r0, [pc, #16]	; (d7c <PWM_0_CLOCK_init+0x18>)
     d6a:	4b05      	ldr	r3, [pc, #20]	; (d80 <PWM_0_CLOCK_init+0x1c>)
     d6c:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, TCC1_GCLK_ID, CONF_GCLK_TCC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     d6e:	2240      	movs	r2, #64	; 0x40
     d70:	2119      	movs	r1, #25
     d72:	4804      	ldr	r0, [pc, #16]	; (d84 <PWM_0_CLOCK_init+0x20>)
     d74:	4b04      	ldr	r3, [pc, #16]	; (d88 <PWM_0_CLOCK_init+0x24>)
     d76:	4798      	blx	r3
}
     d78:	bf00      	nop
     d7a:	bd80      	pop	{r7, pc}
     d7c:	40000800 	.word	0x40000800
     d80:	000005e7 	.word	0x000005e7
     d84:	40001c00 	.word	0x40001c00
     d88:	00000561 	.word	0x00000561

00000d8c <CAN_0_PORT_init>:

void CAN_0_PORT_init(void)
{
     d8c:	b580      	push	{r7, lr}
     d8e:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PB13, PINMUX_PB13H_CAN1_RX);
     d90:	4904      	ldr	r1, [pc, #16]	; (da4 <CAN_0_PORT_init+0x18>)
     d92:	202d      	movs	r0, #45	; 0x2d
     d94:	4b04      	ldr	r3, [pc, #16]	; (da8 <CAN_0_PORT_init+0x1c>)
     d96:	4798      	blx	r3

	gpio_set_pin_function(PB12, PINMUX_PB12H_CAN1_TX);
     d98:	4904      	ldr	r1, [pc, #16]	; (dac <CAN_0_PORT_init+0x20>)
     d9a:	202c      	movs	r0, #44	; 0x2c
     d9c:	4b02      	ldr	r3, [pc, #8]	; (da8 <CAN_0_PORT_init+0x1c>)
     d9e:	4798      	blx	r3
}
     da0:	bf00      	nop
     da2:	bd80      	pop	{r7, pc}
     da4:	002d0007 	.word	0x002d0007
     da8:	00000b55 	.word	0x00000b55
     dac:	002c0007 	.word	0x002c0007

00000db0 <CAN_0_init>:
 * \brief CAN initialization function
 *
 * Enables CAN peripheral, clocks and initializes CAN driver
 */
void CAN_0_init(void)
{
     db0:	b580      	push	{r7, lr}
     db2:	af00      	add	r7, sp, #0
	hri_mclk_set_AHBMASK_CAN1_bit(MCLK);
     db4:	4807      	ldr	r0, [pc, #28]	; (dd4 <CAN_0_init+0x24>)
     db6:	4b08      	ldr	r3, [pc, #32]	; (dd8 <CAN_0_init+0x28>)
     db8:	4798      	blx	r3
	hri_gclk_write_PCHCTRL_reg(GCLK, CAN1_GCLK_ID, CONF_GCLK_CAN1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
     dba:	2240      	movs	r2, #64	; 0x40
     dbc:	211c      	movs	r1, #28
     dbe:	4807      	ldr	r0, [pc, #28]	; (ddc <CAN_0_init+0x2c>)
     dc0:	4b07      	ldr	r3, [pc, #28]	; (de0 <CAN_0_init+0x30>)
     dc2:	4798      	blx	r3
	can_async_init(&CAN_0, CAN1);
     dc4:	4907      	ldr	r1, [pc, #28]	; (de4 <CAN_0_init+0x34>)
     dc6:	4808      	ldr	r0, [pc, #32]	; (de8 <CAN_0_init+0x38>)
     dc8:	4b08      	ldr	r3, [pc, #32]	; (dec <CAN_0_init+0x3c>)
     dca:	4798      	blx	r3
	CAN_0_PORT_init();
     dcc:	4b08      	ldr	r3, [pc, #32]	; (df0 <CAN_0_init+0x40>)
     dce:	4798      	blx	r3
}
     dd0:	bf00      	nop
     dd2:	bd80      	pop	{r7, pc}
     dd4:	40000800 	.word	0x40000800
     dd8:	000005a7 	.word	0x000005a7
     ddc:	40001c00 	.word	0x40001c00
     de0:	00000561 	.word	0x00000561
     de4:	42000400 	.word	0x42000400
     de8:	200016a8 	.word	0x200016a8
     dec:	00001239 	.word	0x00001239
     df0:	00000d8d 	.word	0x00000d8d

00000df4 <COMMUNICATION_IO_PORT_init>:

void COMMUNICATION_IO_PORT_init(void)
{
     df4:	b580      	push	{r7, lr}
     df6:	af00      	add	r7, sp, #0

	gpio_set_pin_function(PC11, PINMUX_PC11L_GMAC_GMDC);
     df8:	4914      	ldr	r1, [pc, #80]	; (e4c <COMMUNICATION_IO_PORT_init+0x58>)
     dfa:	204b      	movs	r0, #75	; 0x4b
     dfc:	4b14      	ldr	r3, [pc, #80]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     dfe:	4798      	blx	r3

	gpio_set_pin_function(PC12, PINMUX_PC12L_GMAC_GMDIO);
     e00:	4914      	ldr	r1, [pc, #80]	; (e54 <COMMUNICATION_IO_PORT_init+0x60>)
     e02:	204c      	movs	r0, #76	; 0x4c
     e04:	4b12      	ldr	r3, [pc, #72]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e06:	4798      	blx	r3

	gpio_set_pin_function(PA13, PINMUX_PA13L_GMAC_GRX0);
     e08:	4913      	ldr	r1, [pc, #76]	; (e58 <COMMUNICATION_IO_PORT_init+0x64>)
     e0a:	200d      	movs	r0, #13
     e0c:	4b10      	ldr	r3, [pc, #64]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e0e:	4798      	blx	r3

	gpio_set_pin_function(PA12, PINMUX_PA12L_GMAC_GRX1);
     e10:	4912      	ldr	r1, [pc, #72]	; (e5c <COMMUNICATION_IO_PORT_init+0x68>)
     e12:	200c      	movs	r0, #12
     e14:	4b0e      	ldr	r3, [pc, #56]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e16:	4798      	blx	r3

	gpio_set_pin_function(PC20, PINMUX_PC20L_GMAC_GRXDV);
     e18:	4911      	ldr	r1, [pc, #68]	; (e60 <COMMUNICATION_IO_PORT_init+0x6c>)
     e1a:	2054      	movs	r0, #84	; 0x54
     e1c:	4b0c      	ldr	r3, [pc, #48]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e1e:	4798      	blx	r3

	gpio_set_pin_function(PA15, PINMUX_PA15L_GMAC_GRXER);
     e20:	4910      	ldr	r1, [pc, #64]	; (e64 <COMMUNICATION_IO_PORT_init+0x70>)
     e22:	200f      	movs	r0, #15
     e24:	4b0a      	ldr	r3, [pc, #40]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e26:	4798      	blx	r3

	gpio_set_pin_function(PA18, PINMUX_PA18L_GMAC_GTX0);
     e28:	490f      	ldr	r1, [pc, #60]	; (e68 <COMMUNICATION_IO_PORT_init+0x74>)
     e2a:	2012      	movs	r0, #18
     e2c:	4b08      	ldr	r3, [pc, #32]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e2e:	4798      	blx	r3

	gpio_set_pin_function(PA19, PINMUX_PA19L_GMAC_GTX1);
     e30:	490e      	ldr	r1, [pc, #56]	; (e6c <COMMUNICATION_IO_PORT_init+0x78>)
     e32:	2013      	movs	r0, #19
     e34:	4b06      	ldr	r3, [pc, #24]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e36:	4798      	blx	r3

	gpio_set_pin_function(PA14, PINMUX_PA14L_GMAC_GTXCK);
     e38:	490d      	ldr	r1, [pc, #52]	; (e70 <COMMUNICATION_IO_PORT_init+0x7c>)
     e3a:	200e      	movs	r0, #14
     e3c:	4b04      	ldr	r3, [pc, #16]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e3e:	4798      	blx	r3

	gpio_set_pin_function(PA17, PINMUX_PA17L_GMAC_GTXEN);
     e40:	490c      	ldr	r1, [pc, #48]	; (e74 <COMMUNICATION_IO_PORT_init+0x80>)
     e42:	2011      	movs	r0, #17
     e44:	4b02      	ldr	r3, [pc, #8]	; (e50 <COMMUNICATION_IO_PORT_init+0x5c>)
     e46:	4798      	blx	r3
}
     e48:	bf00      	nop
     e4a:	bd80      	pop	{r7, pc}
     e4c:	004b000b 	.word	0x004b000b
     e50:	00000b55 	.word	0x00000b55
     e54:	004c000b 	.word	0x004c000b
     e58:	000d000b 	.word	0x000d000b
     e5c:	000c000b 	.word	0x000c000b
     e60:	0054000b 	.word	0x0054000b
     e64:	000f000b 	.word	0x000f000b
     e68:	0012000b 	.word	0x0012000b
     e6c:	0013000b 	.word	0x0013000b
     e70:	000e000b 	.word	0x000e000b
     e74:	0011000b 	.word	0x0011000b

00000e78 <COMMUNICATION_IO_CLOCK_init>:

void COMMUNICATION_IO_CLOCK_init(void)
{
     e78:	b580      	push	{r7, lr}
     e7a:	af00      	add	r7, sp, #0
	hri_mclk_set_AHBMASK_GMAC_bit(MCLK);
     e7c:	4803      	ldr	r0, [pc, #12]	; (e8c <COMMUNICATION_IO_CLOCK_init+0x14>)
     e7e:	4b04      	ldr	r3, [pc, #16]	; (e90 <COMMUNICATION_IO_CLOCK_init+0x18>)
     e80:	4798      	blx	r3
	hri_mclk_set_APBCMASK_GMAC_bit(MCLK);
     e82:	4802      	ldr	r0, [pc, #8]	; (e8c <COMMUNICATION_IO_CLOCK_init+0x14>)
     e84:	4b03      	ldr	r3, [pc, #12]	; (e94 <COMMUNICATION_IO_CLOCK_init+0x1c>)
     e86:	4798      	blx	r3
}
     e88:	bf00      	nop
     e8a:	bd80      	pop	{r7, pc}
     e8c:	40000800 	.word	0x40000800
     e90:	00000587 	.word	0x00000587
     e94:	00000607 	.word	0x00000607

00000e98 <COMMUNICATION_IO_init>:

void COMMUNICATION_IO_init(void)
{
     e98:	b580      	push	{r7, lr}
     e9a:	af00      	add	r7, sp, #0
	COMMUNICATION_IO_CLOCK_init();
     e9c:	4b04      	ldr	r3, [pc, #16]	; (eb0 <COMMUNICATION_IO_init+0x18>)
     e9e:	4798      	blx	r3
	mac_async_init(&COMMUNICATION_IO, GMAC);
     ea0:	4904      	ldr	r1, [pc, #16]	; (eb4 <COMMUNICATION_IO_init+0x1c>)
     ea2:	4805      	ldr	r0, [pc, #20]	; (eb8 <COMMUNICATION_IO_init+0x20>)
     ea4:	4b05      	ldr	r3, [pc, #20]	; (ebc <COMMUNICATION_IO_init+0x24>)
     ea6:	4798      	blx	r3
	COMMUNICATION_IO_PORT_init();
     ea8:	4b05      	ldr	r3, [pc, #20]	; (ec0 <COMMUNICATION_IO_init+0x28>)
     eaa:	4798      	blx	r3
}
     eac:	bf00      	nop
     eae:	bd80      	pop	{r7, pc}
     eb0:	00000e79 	.word	0x00000e79
     eb4:	42000800 	.word	0x42000800
     eb8:	200016e0 	.word	0x200016e0
     ebc:	000013f9 	.word	0x000013f9
     ec0:	00000df5 	.word	0x00000df5

00000ec4 <system_init>:
	mac_async_enable(&COMMUNICATION_IO);
	mac_async_write(&COMMUNICATION_IO, (uint8_t *)"Hello World!", 12);
}

void system_init(void)
{
     ec4:	b580      	push	{r7, lr}
     ec6:	af00      	add	r7, sp, #0
	init_mcu();
     ec8:	4b49      	ldr	r3, [pc, #292]	; (ff0 <system_init+0x12c>)
     eca:	4798      	blx	r3

	// GPIO on PA06

	gpio_set_pin_level(SteerLeft,
     ecc:	2100      	movs	r1, #0
     ece:	2006      	movs	r0, #6
     ed0:	4b48      	ldr	r3, [pc, #288]	; (ff4 <system_init+0x130>)
     ed2:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(SteerLeft, GPIO_DIRECTION_OUT);
     ed4:	2102      	movs	r1, #2
     ed6:	2006      	movs	r0, #6
     ed8:	4b47      	ldr	r3, [pc, #284]	; (ff8 <system_init+0x134>)
     eda:	4798      	blx	r3

	gpio_set_pin_function(SteerLeft, GPIO_PIN_FUNCTION_OFF);
     edc:	f04f 31ff 	mov.w	r1, #4294967295
     ee0:	2006      	movs	r0, #6
     ee2:	4b46      	ldr	r3, [pc, #280]	; (ffc <system_init+0x138>)
     ee4:	4798      	blx	r3

	// GPIO on PA07

	gpio_set_pin_level(SteerRight,
     ee6:	2100      	movs	r1, #0
     ee8:	2007      	movs	r0, #7
     eea:	4b42      	ldr	r3, [pc, #264]	; (ff4 <system_init+0x130>)
     eec:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(SteerRight, GPIO_DIRECTION_OUT);
     eee:	2102      	movs	r1, #2
     ef0:	2007      	movs	r0, #7
     ef2:	4b41      	ldr	r3, [pc, #260]	; (ff8 <system_init+0x134>)
     ef4:	4798      	blx	r3

	gpio_set_pin_function(SteerRight, GPIO_PIN_FUNCTION_OFF);
     ef6:	f04f 31ff 	mov.w	r1, #4294967295
     efa:	2007      	movs	r0, #7
     efc:	4b3f      	ldr	r3, [pc, #252]	; (ffc <system_init+0x138>)
     efe:	4798      	blx	r3

	// GPIO on PB01

	gpio_set_pin_level(SafetyLights2Mode,
     f00:	2100      	movs	r1, #0
     f02:	2021      	movs	r0, #33	; 0x21
     f04:	4b3b      	ldr	r3, [pc, #236]	; (ff4 <system_init+0x130>)
     f06:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(SafetyLights2Mode, GPIO_DIRECTION_OUT);
     f08:	2102      	movs	r1, #2
     f0a:	2021      	movs	r0, #33	; 0x21
     f0c:	4b3a      	ldr	r3, [pc, #232]	; (ff8 <system_init+0x134>)
     f0e:	4798      	blx	r3

	gpio_set_pin_function(SafetyLights2Mode, GPIO_PIN_FUNCTION_OFF);
     f10:	f04f 31ff 	mov.w	r1, #4294967295
     f14:	2021      	movs	r0, #33	; 0x21
     f16:	4b39      	ldr	r3, [pc, #228]	; (ffc <system_init+0x138>)
     f18:	4798      	blx	r3

	// GPIO on PB06

	gpio_set_pin_level(SafetyLights2On,
     f1a:	2100      	movs	r1, #0
     f1c:	2026      	movs	r0, #38	; 0x26
     f1e:	4b35      	ldr	r3, [pc, #212]	; (ff4 <system_init+0x130>)
     f20:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(SafetyLights2On, GPIO_DIRECTION_OUT);
     f22:	2102      	movs	r1, #2
     f24:	2026      	movs	r0, #38	; 0x26
     f26:	4b34      	ldr	r3, [pc, #208]	; (ff8 <system_init+0x134>)
     f28:	4798      	blx	r3

	gpio_set_pin_function(SafetyLights2On, GPIO_PIN_FUNCTION_OFF);
     f2a:	f04f 31ff 	mov.w	r1, #4294967295
     f2e:	2026      	movs	r0, #38	; 0x26
     f30:	4b32      	ldr	r3, [pc, #200]	; (ffc <system_init+0x138>)
     f32:	4798      	blx	r3

	// GPIO on PB07

	// Set pin direction to input
	gpio_set_pin_direction(WheelSpeed2, GPIO_DIRECTION_IN);
     f34:	2101      	movs	r1, #1
     f36:	2027      	movs	r0, #39	; 0x27
     f38:	4b2f      	ldr	r3, [pc, #188]	; (ff8 <system_init+0x134>)
     f3a:	4798      	blx	r3

	gpio_set_pin_pull_mode(WheelSpeed2,
     f3c:	2102      	movs	r1, #2
     f3e:	2027      	movs	r0, #39	; 0x27
     f40:	4b2f      	ldr	r3, [pc, #188]	; (1000 <system_init+0x13c>)
     f42:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_DOWN);

	gpio_set_pin_function(WheelSpeed2, GPIO_PIN_FUNCTION_OFF);
     f44:	f04f 31ff 	mov.w	r1, #4294967295
     f48:	2027      	movs	r0, #39	; 0x27
     f4a:	4b2c      	ldr	r3, [pc, #176]	; (ffc <system_init+0x138>)
     f4c:	4798      	blx	r3

	// GPIO on PC01

	gpio_set_pin_level(SafetyLights1On,
     f4e:	2100      	movs	r1, #0
     f50:	2041      	movs	r0, #65	; 0x41
     f52:	4b28      	ldr	r3, [pc, #160]	; (ff4 <system_init+0x130>)
     f54:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(SafetyLights1On, GPIO_DIRECTION_OUT);
     f56:	2102      	movs	r1, #2
     f58:	2041      	movs	r0, #65	; 0x41
     f5a:	4b27      	ldr	r3, [pc, #156]	; (ff8 <system_init+0x134>)
     f5c:	4798      	blx	r3

	gpio_set_pin_function(SafetyLights1On, GPIO_PIN_FUNCTION_OFF);
     f5e:	f04f 31ff 	mov.w	r1, #4294967295
     f62:	2041      	movs	r0, #65	; 0x41
     f64:	4b25      	ldr	r3, [pc, #148]	; (ffc <system_init+0x138>)
     f66:	4798      	blx	r3

	// GPIO on PC10

	gpio_set_pin_level(SafetyLights1Mode,
     f68:	2100      	movs	r1, #0
     f6a:	204a      	movs	r0, #74	; 0x4a
     f6c:	4b21      	ldr	r3, [pc, #132]	; (ff4 <system_init+0x130>)
     f6e:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(SafetyLights1Mode, GPIO_DIRECTION_OUT);
     f70:	2102      	movs	r1, #2
     f72:	204a      	movs	r0, #74	; 0x4a
     f74:	4b20      	ldr	r3, [pc, #128]	; (ff8 <system_init+0x134>)
     f76:	4798      	blx	r3

	gpio_set_pin_function(SafetyLights1Mode, GPIO_PIN_FUNCTION_OFF);
     f78:	f04f 31ff 	mov.w	r1, #4294967295
     f7c:	204a      	movs	r0, #74	; 0x4a
     f7e:	4b1f      	ldr	r3, [pc, #124]	; (ffc <system_init+0x138>)
     f80:	4798      	blx	r3

	// GPIO on PC18

	gpio_set_pin_level(LED_0,
     f82:	2101      	movs	r1, #1
     f84:	2052      	movs	r0, #82	; 0x52
     f86:	4b1b      	ldr	r3, [pc, #108]	; (ff4 <system_init+0x130>)
     f88:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   true);

	// Set pin direction to output
	gpio_set_pin_direction(LED_0, GPIO_DIRECTION_OUT);
     f8a:	2102      	movs	r1, #2
     f8c:	2052      	movs	r0, #82	; 0x52
     f8e:	4b1a      	ldr	r3, [pc, #104]	; (ff8 <system_init+0x134>)
     f90:	4798      	blx	r3

	gpio_set_pin_function(LED_0, GPIO_PIN_FUNCTION_OFF);
     f92:	f04f 31ff 	mov.w	r1, #4294967295
     f96:	2052      	movs	r0, #82	; 0x52
     f98:	4b18      	ldr	r3, [pc, #96]	; (ffc <system_init+0x138>)
     f9a:	4798      	blx	r3

	// GPIO on PC30

	gpio_set_pin_level(ReverseDrive,
     f9c:	2100      	movs	r1, #0
     f9e:	205e      	movs	r0, #94	; 0x5e
     fa0:	4b14      	ldr	r3, [pc, #80]	; (ff4 <system_init+0x130>)
     fa2:	4798      	blx	r3
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(ReverseDrive, GPIO_DIRECTION_OUT);
     fa4:	2102      	movs	r1, #2
     fa6:	205e      	movs	r0, #94	; 0x5e
     fa8:	4b13      	ldr	r3, [pc, #76]	; (ff8 <system_init+0x134>)
     faa:	4798      	blx	r3

	gpio_set_pin_function(ReverseDrive, GPIO_PIN_FUNCTION_OFF);
     fac:	f04f 31ff 	mov.w	r1, #4294967295
     fb0:	205e      	movs	r0, #94	; 0x5e
     fb2:	4b12      	ldr	r3, [pc, #72]	; (ffc <system_init+0x138>)
     fb4:	4798      	blx	r3

	// GPIO on PD00

	// Set pin direction to input
	gpio_set_pin_direction(WheelSpeed, GPIO_DIRECTION_IN);
     fb6:	2101      	movs	r1, #1
     fb8:	2060      	movs	r0, #96	; 0x60
     fba:	4b0f      	ldr	r3, [pc, #60]	; (ff8 <system_init+0x134>)
     fbc:	4798      	blx	r3

	gpio_set_pin_pull_mode(WheelSpeed,
     fbe:	2102      	movs	r1, #2
     fc0:	2060      	movs	r0, #96	; 0x60
     fc2:	4b0f      	ldr	r3, [pc, #60]	; (1000 <system_init+0x13c>)
     fc4:	4798      	blx	r3
	                       // <GPIO_PULL_OFF"> Off
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_DOWN);

	gpio_set_pin_function(WheelSpeed, GPIO_PIN_FUNCTION_OFF);
     fc6:	f04f 31ff 	mov.w	r1, #4294967295
     fca:	2060      	movs	r0, #96	; 0x60
     fcc:	4b0b      	ldr	r3, [pc, #44]	; (ffc <system_init+0x138>)
     fce:	4798      	blx	r3

	ADC_0_init();
     fd0:	4b0c      	ldr	r3, [pc, #48]	; (1004 <system_init+0x140>)
     fd2:	4798      	blx	r3

	TARGET_IO_init();
     fd4:	4b0c      	ldr	r3, [pc, #48]	; (1008 <system_init+0x144>)
     fd6:	4798      	blx	r3

	PWM_0_CLOCK_init();
     fd8:	4b0c      	ldr	r3, [pc, #48]	; (100c <system_init+0x148>)
     fda:	4798      	blx	r3

	PWM_0_PORT_init();
     fdc:	4b0c      	ldr	r3, [pc, #48]	; (1010 <system_init+0x14c>)
     fde:	4798      	blx	r3

	PWM_0_init();
     fe0:	4b0c      	ldr	r3, [pc, #48]	; (1014 <system_init+0x150>)
     fe2:	4798      	blx	r3
	CAN_0_init();
     fe4:	4b0c      	ldr	r3, [pc, #48]	; (1018 <system_init+0x154>)
     fe6:	4798      	blx	r3

	COMMUNICATION_IO_init();
     fe8:	4b0c      	ldr	r3, [pc, #48]	; (101c <system_init+0x158>)
     fea:	4798      	blx	r3
}
     fec:	bf00      	nop
     fee:	bd80      	pop	{r7, pc}
     ff0:	00000be5 	.word	0x00000be5
     ff4:	00000bad 	.word	0x00000bad
     ff8:	00000b75 	.word	0x00000b75
     ffc:	00000b55 	.word	0x00000b55
    1000:	00000b21 	.word	0x00000b21
    1004:	00000c41 	.word	0x00000c41
    1008:	00000cd5 	.word	0x00000cd5
    100c:	00000d65 	.word	0x00000d65
    1010:	00000d05 	.word	0x00000d05
    1014:	0000346d 	.word	0x0000346d
    1018:	00000db1 	.word	0x00000db1
    101c:	00000e99 	.word	0x00000e99

00001020 <ethernet_phy_init>:
/**
 * \brief Perform a HW initialization to the PHY
 */
int32_t ethernet_phy_init(struct ethernet_phy_descriptor *const descr, struct mac_async_descriptor *const mac,
                          uint16_t addr)
{
    1020:	b580      	push	{r7, lr}
    1022:	b084      	sub	sp, #16
    1024:	af00      	add	r7, sp, #0
    1026:	60f8      	str	r0, [r7, #12]
    1028:	60b9      	str	r1, [r7, #8]
    102a:	4613      	mov	r3, r2
    102c:	80fb      	strh	r3, [r7, #6]
	ASSERT(descr && mac && (addr <= 0x1F));
    102e:	68fb      	ldr	r3, [r7, #12]
    1030:	2b00      	cmp	r3, #0
    1032:	d007      	beq.n	1044 <ethernet_phy_init+0x24>
    1034:	68bb      	ldr	r3, [r7, #8]
    1036:	2b00      	cmp	r3, #0
    1038:	d004      	beq.n	1044 <ethernet_phy_init+0x24>
    103a:	88fb      	ldrh	r3, [r7, #6]
    103c:	2b1f      	cmp	r3, #31
    103e:	d801      	bhi.n	1044 <ethernet_phy_init+0x24>
    1040:	2301      	movs	r3, #1
    1042:	e000      	b.n	1046 <ethernet_phy_init+0x26>
    1044:	2300      	movs	r3, #0
    1046:	f003 0301 	and.w	r3, r3, #1
    104a:	b2db      	uxtb	r3, r3
    104c:	222a      	movs	r2, #42	; 0x2a
    104e:	4907      	ldr	r1, [pc, #28]	; (106c <ethernet_phy_init+0x4c>)
    1050:	4618      	mov	r0, r3
    1052:	4b07      	ldr	r3, [pc, #28]	; (1070 <ethernet_phy_init+0x50>)
    1054:	4798      	blx	r3

	descr->mac  = mac;
    1056:	68fb      	ldr	r3, [r7, #12]
    1058:	68ba      	ldr	r2, [r7, #8]
    105a:	601a      	str	r2, [r3, #0]
	descr->addr = addr;
    105c:	68fb      	ldr	r3, [r7, #12]
    105e:	88fa      	ldrh	r2, [r7, #6]
    1060:	809a      	strh	r2, [r3, #4]
	return ERR_NONE;
    1062:	2300      	movs	r3, #0
}
    1064:	4618      	mov	r0, r3
    1066:	3710      	adds	r7, #16
    1068:	46bd      	mov	sp, r7
    106a:	bd80      	pop	{r7, pc}
    106c:	00004678 	.word	0x00004678
    1070:	0000168d 	.word	0x0000168d

00001074 <ETHERNET_PHY_0_init>:
#include <ethernet_phy_main.h>

struct ethernet_phy_descriptor ETHERNET_PHY_0_desc;

void ETHERNET_PHY_0_init(void)
{
    1074:	b580      	push	{r7, lr}
    1076:	af00      	add	r7, sp, #0
	mac_async_enable(&COMMUNICATION_IO);
    1078:	4804      	ldr	r0, [pc, #16]	; (108c <ETHERNET_PHY_0_init+0x18>)
    107a:	4b05      	ldr	r3, [pc, #20]	; (1090 <ETHERNET_PHY_0_init+0x1c>)
    107c:	4798      	blx	r3
	ethernet_phy_init(&ETHERNET_PHY_0_desc, &COMMUNICATION_IO, CONF_ETHERNET_PHY_0_IEEE8023_MII_PHY_ADDRESS);
    107e:	2200      	movs	r2, #0
    1080:	4902      	ldr	r1, [pc, #8]	; (108c <ETHERNET_PHY_0_init+0x18>)
    1082:	4804      	ldr	r0, [pc, #16]	; (1094 <ETHERNET_PHY_0_init+0x20>)
    1084:	4b04      	ldr	r3, [pc, #16]	; (1098 <ETHERNET_PHY_0_init+0x24>)
    1086:	4798      	blx	r3
#if CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING == 1
	ethernet_phy_write_reg(&ETHERNET_PHY_0_desc, MDIO_REG0_BMCR, CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0);
#endif /* CONF_ETHERNET_PHY_0_IEEE8023_MII_CONTROL_REG0_SETTING */
}
    1088:	bf00      	nop
    108a:	bd80      	pop	{r7, pc}
    108c:	200016e0 	.word	0x200016e0
    1090:	00001445 	.word	0x00001445
    1094:	2000167c 	.word	0x2000167c
    1098:	00001021 	.word	0x00001021

0000109c <ethernet_phys_init>:
		rst = ethernet_phy_get_link_status(&ETHERNET_PHY_0_desc, &link_state);
	} while (rst == ERR_NONE && link_state == true);
}

void ethernet_phys_init(void)
{
    109c:	b580      	push	{r7, lr}
    109e:	af00      	add	r7, sp, #0

	ETHERNET_PHY_0_init();
    10a0:	4b01      	ldr	r3, [pc, #4]	; (10a8 <ethernet_phys_init+0xc>)
    10a2:	4798      	blx	r3
}
    10a4:	bf00      	nop
    10a6:	bd80      	pop	{r7, pc}
    10a8:	00001075 	.word	0x00001075

000010ac <adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t adc_sync_init(struct adc_sync_descriptor *const descr, void *const hw, void *const func)
{
    10ac:	b580      	push	{r7, lr}
    10ae:	b084      	sub	sp, #16
    10b0:	af00      	add	r7, sp, #0
    10b2:	60f8      	str	r0, [r7, #12]
    10b4:	60b9      	str	r1, [r7, #8]
    10b6:	607a      	str	r2, [r7, #4]
	ASSERT(descr && hw);
    10b8:	68fb      	ldr	r3, [r7, #12]
    10ba:	2b00      	cmp	r3, #0
    10bc:	d004      	beq.n	10c8 <adc_sync_init+0x1c>
    10be:	68bb      	ldr	r3, [r7, #8]
    10c0:	2b00      	cmp	r3, #0
    10c2:	d001      	beq.n	10c8 <adc_sync_init+0x1c>
    10c4:	2301      	movs	r3, #1
    10c6:	e000      	b.n	10ca <adc_sync_init+0x1e>
    10c8:	2300      	movs	r3, #0
    10ca:	f003 0301 	and.w	r3, r3, #1
    10ce:	b2db      	uxtb	r3, r3
    10d0:	2239      	movs	r2, #57	; 0x39
    10d2:	4907      	ldr	r1, [pc, #28]	; (10f0 <adc_sync_init+0x44>)
    10d4:	4618      	mov	r0, r3
    10d6:	4b07      	ldr	r3, [pc, #28]	; (10f4 <adc_sync_init+0x48>)
    10d8:	4798      	blx	r3

	return _adc_sync_init(&descr->device, hw);
    10da:	68fb      	ldr	r3, [r7, #12]
    10dc:	68b9      	ldr	r1, [r7, #8]
    10de:	4618      	mov	r0, r3
    10e0:	4b05      	ldr	r3, [pc, #20]	; (10f8 <adc_sync_init+0x4c>)
    10e2:	4798      	blx	r3
    10e4:	4603      	mov	r3, r0
}
    10e6:	4618      	mov	r0, r3
    10e8:	3710      	adds	r7, #16
    10ea:	46bd      	mov	sp, r7
    10ec:	bd80      	pop	{r7, pc}
    10ee:	bf00      	nop
    10f0:	00004698 	.word	0x00004698
    10f4:	0000168d 	.word	0x0000168d
    10f8:	00001cc9 	.word	0x00001cc9

000010fc <adc_sync_enable_channel>:

/**
 * \brief Enable ADC
 */
int32_t adc_sync_enable_channel(struct adc_sync_descriptor *const descr, const uint8_t channel)
{
    10fc:	b580      	push	{r7, lr}
    10fe:	b082      	sub	sp, #8
    1100:	af00      	add	r7, sp, #0
    1102:	6078      	str	r0, [r7, #4]
    1104:	460b      	mov	r3, r1
    1106:	70fb      	strb	r3, [r7, #3]
	ASSERT(descr);
    1108:	687b      	ldr	r3, [r7, #4]
    110a:	2b00      	cmp	r3, #0
    110c:	bf14      	ite	ne
    110e:	2301      	movne	r3, #1
    1110:	2300      	moveq	r3, #0
    1112:	b2db      	uxtb	r3, r3
    1114:	224e      	movs	r2, #78	; 0x4e
    1116:	4907      	ldr	r1, [pc, #28]	; (1134 <adc_sync_enable_channel+0x38>)
    1118:	4618      	mov	r0, r3
    111a:	4b07      	ldr	r3, [pc, #28]	; (1138 <adc_sync_enable_channel+0x3c>)
    111c:	4798      	blx	r3
	_adc_sync_enable_channel(&descr->device, channel);
    111e:	687b      	ldr	r3, [r7, #4]
    1120:	78fa      	ldrb	r2, [r7, #3]
    1122:	4611      	mov	r1, r2
    1124:	4618      	mov	r0, r3
    1126:	4b05      	ldr	r3, [pc, #20]	; (113c <adc_sync_enable_channel+0x40>)
    1128:	4798      	blx	r3

	return ERR_NONE;
    112a:	2300      	movs	r3, #0
}
    112c:	4618      	mov	r0, r3
    112e:	3708      	adds	r7, #8
    1130:	46bd      	mov	sp, r7
    1132:	bd80      	pop	{r7, pc}
    1134:	00004698 	.word	0x00004698
    1138:	0000168d 	.word	0x0000168d
    113c:	00001d1d 	.word	0x00001d1d

00001140 <adc_sync_read_channel>:
/*
 * \brief Read data from ADC
 */
int32_t adc_sync_read_channel(struct adc_sync_descriptor *const descr, const uint8_t channel, uint8_t *const buffer,
                              const uint16_t length)
{
    1140:	b580      	push	{r7, lr}
    1142:	b086      	sub	sp, #24
    1144:	af00      	add	r7, sp, #0
    1146:	60f8      	str	r0, [r7, #12]
    1148:	607a      	str	r2, [r7, #4]
    114a:	461a      	mov	r2, r3
    114c:	460b      	mov	r3, r1
    114e:	72fb      	strb	r3, [r7, #11]
    1150:	4613      	mov	r3, r2
    1152:	813b      	strh	r3, [r7, #8]
	uint8_t  data_size;
	uint16_t offset = 0;
    1154:	2300      	movs	r3, #0
    1156:	82fb      	strh	r3, [r7, #22]

	ASSERT(descr && buffer && length);
    1158:	68fb      	ldr	r3, [r7, #12]
    115a:	2b00      	cmp	r3, #0
    115c:	d007      	beq.n	116e <adc_sync_read_channel+0x2e>
    115e:	687b      	ldr	r3, [r7, #4]
    1160:	2b00      	cmp	r3, #0
    1162:	d004      	beq.n	116e <adc_sync_read_channel+0x2e>
    1164:	893b      	ldrh	r3, [r7, #8]
    1166:	2b00      	cmp	r3, #0
    1168:	d001      	beq.n	116e <adc_sync_read_channel+0x2e>
    116a:	2301      	movs	r3, #1
    116c:	e000      	b.n	1170 <adc_sync_read_channel+0x30>
    116e:	2300      	movs	r3, #0
    1170:	f003 0301 	and.w	r3, r3, #1
    1174:	b2db      	uxtb	r3, r3
    1176:	2267      	movs	r2, #103	; 0x67
    1178:	4929      	ldr	r1, [pc, #164]	; (1220 <adc_sync_read_channel+0xe0>)
    117a:	4618      	mov	r0, r3
    117c:	4b29      	ldr	r3, [pc, #164]	; (1224 <adc_sync_read_channel+0xe4>)
    117e:	4798      	blx	r3
	data_size = _adc_sync_get_data_size(&descr->device);
    1180:	68fb      	ldr	r3, [r7, #12]
    1182:	4618      	mov	r0, r3
    1184:	4b28      	ldr	r3, [pc, #160]	; (1228 <adc_sync_read_channel+0xe8>)
    1186:	4798      	blx	r3
    1188:	4603      	mov	r3, r0
    118a:	757b      	strb	r3, [r7, #21]
	ASSERT(!(length % data_size));
    118c:	893b      	ldrh	r3, [r7, #8]
    118e:	7d7a      	ldrb	r2, [r7, #21]
    1190:	fb93 f1f2 	sdiv	r1, r3, r2
    1194:	fb02 f201 	mul.w	r2, r2, r1
    1198:	1a9b      	subs	r3, r3, r2
    119a:	2b00      	cmp	r3, #0
    119c:	bf0c      	ite	eq
    119e:	2301      	moveq	r3, #1
    11a0:	2300      	movne	r3, #0
    11a2:	b2db      	uxtb	r3, r3
    11a4:	2269      	movs	r2, #105	; 0x69
    11a6:	491e      	ldr	r1, [pc, #120]	; (1220 <adc_sync_read_channel+0xe0>)
    11a8:	4618      	mov	r0, r3
    11aa:	4b1e      	ldr	r3, [pc, #120]	; (1224 <adc_sync_read_channel+0xe4>)
    11ac:	4798      	blx	r3

	do {
		uint16_t result;
		_adc_sync_convert(&descr->device);
    11ae:	68fb      	ldr	r3, [r7, #12]
    11b0:	4618      	mov	r0, r3
    11b2:	4b1e      	ldr	r3, [pc, #120]	; (122c <adc_sync_read_channel+0xec>)
    11b4:	4798      	blx	r3

		while (!_adc_sync_is_channel_conversion_done(&descr->device, channel))
    11b6:	bf00      	nop
    11b8:	68fb      	ldr	r3, [r7, #12]
    11ba:	7afa      	ldrb	r2, [r7, #11]
    11bc:	4611      	mov	r1, r2
    11be:	4618      	mov	r0, r3
    11c0:	4b1b      	ldr	r3, [pc, #108]	; (1230 <adc_sync_read_channel+0xf0>)
    11c2:	4798      	blx	r3
    11c4:	4603      	mov	r3, r0
    11c6:	f083 0301 	eor.w	r3, r3, #1
    11ca:	b2db      	uxtb	r3, r3
    11cc:	2b00      	cmp	r3, #0
    11ce:	d1f3      	bne.n	11b8 <adc_sync_read_channel+0x78>
			;

		result         = _adc_sync_read_channel_data(&descr->device, channel);
    11d0:	68fb      	ldr	r3, [r7, #12]
    11d2:	7afa      	ldrb	r2, [r7, #11]
    11d4:	4611      	mov	r1, r2
    11d6:	4618      	mov	r0, r3
    11d8:	4b16      	ldr	r3, [pc, #88]	; (1234 <adc_sync_read_channel+0xf4>)
    11da:	4798      	blx	r3
    11dc:	4603      	mov	r3, r0
    11de:	827b      	strh	r3, [r7, #18]
		buffer[offset] = result;
    11e0:	8afb      	ldrh	r3, [r7, #22]
    11e2:	687a      	ldr	r2, [r7, #4]
    11e4:	4413      	add	r3, r2
    11e6:	8a7a      	ldrh	r2, [r7, #18]
    11e8:	b2d2      	uxtb	r2, r2
    11ea:	701a      	strb	r2, [r3, #0]
		if (1 < data_size) {
    11ec:	7d7b      	ldrb	r3, [r7, #21]
    11ee:	2b01      	cmp	r3, #1
    11f0:	d908      	bls.n	1204 <adc_sync_read_channel+0xc4>
			buffer[offset + 1] = result >> 8;
    11f2:	8afb      	ldrh	r3, [r7, #22]
    11f4:	3301      	adds	r3, #1
    11f6:	687a      	ldr	r2, [r7, #4]
    11f8:	4413      	add	r3, r2
    11fa:	8a7a      	ldrh	r2, [r7, #18]
    11fc:	0a12      	lsrs	r2, r2, #8
    11fe:	b292      	uxth	r2, r2
    1200:	b2d2      	uxtb	r2, r2
    1202:	701a      	strb	r2, [r3, #0]
		}
		offset += data_size;
    1204:	7d7b      	ldrb	r3, [r7, #21]
    1206:	b29a      	uxth	r2, r3
    1208:	8afb      	ldrh	r3, [r7, #22]
    120a:	4413      	add	r3, r2
    120c:	82fb      	strh	r3, [r7, #22]
	} while (offset < length);
    120e:	8afa      	ldrh	r2, [r7, #22]
    1210:	893b      	ldrh	r3, [r7, #8]
    1212:	429a      	cmp	r2, r3
    1214:	d3cb      	bcc.n	11ae <adc_sync_read_channel+0x6e>

	return offset;
    1216:	8afb      	ldrh	r3, [r7, #22]
}
    1218:	4618      	mov	r0, r3
    121a:	3718      	adds	r7, #24
    121c:	46bd      	mov	sp, r7
    121e:	bd80      	pop	{r7, pc}
    1220:	00004698 	.word	0x00004698
    1224:	0000168d 	.word	0x0000168d
    1228:	00001d41 	.word	0x00001d41
    122c:	00001d91 	.word	0x00001d91
    1230:	00001d6d 	.word	0x00001d6d
    1234:	00001db1 	.word	0x00001db1

00001238 <can_async_init>:

/**
 * \brief Initialize CAN.
 */
int32_t can_async_init(struct can_async_descriptor *const descr, void *const hw)
{
    1238:	b580      	push	{r7, lr}
    123a:	b084      	sub	sp, #16
    123c:	af00      	add	r7, sp, #0
    123e:	6078      	str	r0, [r7, #4]
    1240:	6039      	str	r1, [r7, #0]
	int32_t rc;

	ASSERT(descr && hw);
    1242:	687b      	ldr	r3, [r7, #4]
    1244:	2b00      	cmp	r3, #0
    1246:	d004      	beq.n	1252 <can_async_init+0x1a>
    1248:	683b      	ldr	r3, [r7, #0]
    124a:	2b00      	cmp	r3, #0
    124c:	d001      	beq.n	1252 <can_async_init+0x1a>
    124e:	2301      	movs	r3, #1
    1250:	e000      	b.n	1254 <can_async_init+0x1c>
    1252:	2300      	movs	r3, #0
    1254:	f003 0301 	and.w	r3, r3, #1
    1258:	b2db      	uxtb	r3, r3
    125a:	2241      	movs	r2, #65	; 0x41
    125c:	490e      	ldr	r1, [pc, #56]	; (1298 <can_async_init+0x60>)
    125e:	4618      	mov	r0, r3
    1260:	4b0e      	ldr	r3, [pc, #56]	; (129c <can_async_init+0x64>)
    1262:	4798      	blx	r3

	rc = _can_async_init(&descr->dev, hw);
    1264:	687b      	ldr	r3, [r7, #4]
    1266:	6839      	ldr	r1, [r7, #0]
    1268:	4618      	mov	r0, r3
    126a:	4b0d      	ldr	r3, [pc, #52]	; (12a0 <can_async_init+0x68>)
    126c:	4798      	blx	r3
    126e:	60f8      	str	r0, [r7, #12]
	if (rc) {
    1270:	68fb      	ldr	r3, [r7, #12]
    1272:	2b00      	cmp	r3, #0
    1274:	d001      	beq.n	127a <can_async_init+0x42>
		return rc;
    1276:	68fb      	ldr	r3, [r7, #12]
    1278:	e009      	b.n	128e <can_async_init+0x56>
	}
	descr->dev.cb.tx_done     = can_tx_done;
    127a:	687b      	ldr	r3, [r7, #4]
    127c:	4a09      	ldr	r2, [pc, #36]	; (12a4 <can_async_init+0x6c>)
    127e:	605a      	str	r2, [r3, #4]
	descr->dev.cb.rx_done     = can_rx_done;
    1280:	687b      	ldr	r3, [r7, #4]
    1282:	4a09      	ldr	r2, [pc, #36]	; (12a8 <can_async_init+0x70>)
    1284:	609a      	str	r2, [r3, #8]
	descr->dev.cb.irq_handler = can_irq_handler;
    1286:	687b      	ldr	r3, [r7, #4]
    1288:	4a08      	ldr	r2, [pc, #32]	; (12ac <can_async_init+0x74>)
    128a:	60da      	str	r2, [r3, #12]

	return ERR_NONE;
    128c:	2300      	movs	r3, #0
}
    128e:	4618      	mov	r0, r3
    1290:	3710      	adds	r7, #16
    1292:	46bd      	mov	sp, r7
    1294:	bd80      	pop	{r7, pc}
    1296:	bf00      	nop
    1298:	000046b4 	.word	0x000046b4
    129c:	0000168d 	.word	0x0000168d
    12a0:	0000213d 	.word	0x0000213d
    12a4:	000012b1 	.word	0x000012b1
    12a8:	000012d5 	.word	0x000012d5
    12ac:	000012f9 	.word	0x000012f9

000012b0 <can_tx_done>:

/**
 * \internal Callback of CAN Message Write finished
 */
static void can_tx_done(struct _can_async_device *dev)
{
    12b0:	b580      	push	{r7, lr}
    12b2:	b084      	sub	sp, #16
    12b4:	af00      	add	r7, sp, #0
    12b6:	6078      	str	r0, [r7, #4]
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);
    12b8:	687b      	ldr	r3, [r7, #4]
    12ba:	60fb      	str	r3, [r7, #12]

	if (descr->cb.tx_done) {
    12bc:	68fb      	ldr	r3, [r7, #12]
    12be:	69db      	ldr	r3, [r3, #28]
    12c0:	2b00      	cmp	r3, #0
    12c2:	d003      	beq.n	12cc <can_tx_done+0x1c>
		descr->cb.tx_done(descr);
    12c4:	68fb      	ldr	r3, [r7, #12]
    12c6:	69db      	ldr	r3, [r3, #28]
    12c8:	68f8      	ldr	r0, [r7, #12]
    12ca:	4798      	blx	r3
	}
}
    12cc:	bf00      	nop
    12ce:	3710      	adds	r7, #16
    12d0:	46bd      	mov	sp, r7
    12d2:	bd80      	pop	{r7, pc}

000012d4 <can_rx_done>:

/**
 * \internal Callback of CAN Message Read finished
 */
static void can_rx_done(struct _can_async_device *dev)
{
    12d4:	b580      	push	{r7, lr}
    12d6:	b084      	sub	sp, #16
    12d8:	af00      	add	r7, sp, #0
    12da:	6078      	str	r0, [r7, #4]
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);
    12dc:	687b      	ldr	r3, [r7, #4]
    12de:	60fb      	str	r3, [r7, #12]

	if (descr->cb.rx_done) {
    12e0:	68fb      	ldr	r3, [r7, #12]
    12e2:	6a1b      	ldr	r3, [r3, #32]
    12e4:	2b00      	cmp	r3, #0
    12e6:	d003      	beq.n	12f0 <can_rx_done+0x1c>
		descr->cb.rx_done(descr);
    12e8:	68fb      	ldr	r3, [r7, #12]
    12ea:	6a1b      	ldr	r3, [r3, #32]
    12ec:	68f8      	ldr	r0, [r7, #12]
    12ee:	4798      	blx	r3
	}
}
    12f0:	bf00      	nop
    12f2:	3710      	adds	r7, #16
    12f4:	46bd      	mov	sp, r7
    12f6:	bd80      	pop	{r7, pc}

000012f8 <can_irq_handler>:

/**
 * \internal Callback of CAN Interrupt
 */
static void can_irq_handler(struct _can_async_device *dev, enum can_async_interrupt_type type)
{
    12f8:	b580      	push	{r7, lr}
    12fa:	b084      	sub	sp, #16
    12fc:	af00      	add	r7, sp, #0
    12fe:	6078      	str	r0, [r7, #4]
    1300:	460b      	mov	r3, r1
    1302:	70fb      	strb	r3, [r7, #3]
	struct can_async_descriptor *const descr = CONTAINER_OF(dev, struct can_async_descriptor, dev);
    1304:	687b      	ldr	r3, [r7, #4]
    1306:	60fb      	str	r3, [r7, #12]

	if (descr->cb.irq_handler) {
    1308:	68fb      	ldr	r3, [r7, #12]
    130a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    130c:	2b00      	cmp	r3, #0
    130e:	d005      	beq.n	131c <can_irq_handler+0x24>
		descr->cb.irq_handler(descr, type);
    1310:	68fb      	ldr	r3, [r7, #12]
    1312:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1314:	78fa      	ldrb	r2, [r7, #3]
    1316:	4611      	mov	r1, r2
    1318:	68f8      	ldr	r0, [r7, #12]
    131a:	4798      	blx	r3
	}
}
    131c:	bf00      	nop
    131e:	3710      	adds	r7, #16
    1320:	46bd      	mov	sp, r7
    1322:	bd80      	pop	{r7, pc}

00001324 <delay_us>:

/**
 * \brief Perform delay in us
 */
void delay_us(const uint16_t us)
{
    1324:	b590      	push	{r4, r7, lr}
    1326:	b083      	sub	sp, #12
    1328:	af00      	add	r7, sp, #0
    132a:	4603      	mov	r3, r0
    132c:	80fb      	strh	r3, [r7, #6]
	_delay_cycles(hardware, _get_cycles_for_us(us));
    132e:	4b07      	ldr	r3, [pc, #28]	; (134c <delay_us+0x28>)
    1330:	681c      	ldr	r4, [r3, #0]
    1332:	88fb      	ldrh	r3, [r7, #6]
    1334:	4618      	mov	r0, r3
    1336:	4b06      	ldr	r3, [pc, #24]	; (1350 <delay_us+0x2c>)
    1338:	4798      	blx	r3
    133a:	4603      	mov	r3, r0
    133c:	4619      	mov	r1, r3
    133e:	4620      	mov	r0, r4
    1340:	4b04      	ldr	r3, [pc, #16]	; (1354 <delay_us+0x30>)
    1342:	4798      	blx	r3
}
    1344:	bf00      	nop
    1346:	370c      	adds	r7, #12
    1348:	46bd      	mov	sp, r7
    134a:	bd90      	pop	{r4, r7, pc}
    134c:	200000bc 	.word	0x200000bc
    1350:	0000252d 	.word	0x0000252d
    1354:	00002559 	.word	0x00002559

00001358 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1358:	b580      	push	{r7, lr}
    135a:	b084      	sub	sp, #16
    135c:	af00      	add	r7, sp, #0
    135e:	60f8      	str	r0, [r7, #12]
    1360:	60b9      	str	r1, [r7, #8]
    1362:	4613      	mov	r3, r2
    1364:	80fb      	strh	r3, [r7, #6]
	ASSERT(io_descr && buf);
    1366:	68fb      	ldr	r3, [r7, #12]
    1368:	2b00      	cmp	r3, #0
    136a:	d004      	beq.n	1376 <io_write+0x1e>
    136c:	68bb      	ldr	r3, [r7, #8]
    136e:	2b00      	cmp	r3, #0
    1370:	d001      	beq.n	1376 <io_write+0x1e>
    1372:	2301      	movs	r3, #1
    1374:	e000      	b.n	1378 <io_write+0x20>
    1376:	2300      	movs	r3, #0
    1378:	f003 0301 	and.w	r3, r3, #1
    137c:	b2db      	uxtb	r3, r3
    137e:	2234      	movs	r2, #52	; 0x34
    1380:	4907      	ldr	r1, [pc, #28]	; (13a0 <io_write+0x48>)
    1382:	4618      	mov	r0, r3
    1384:	4b07      	ldr	r3, [pc, #28]	; (13a4 <io_write+0x4c>)
    1386:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    1388:	68fb      	ldr	r3, [r7, #12]
    138a:	681b      	ldr	r3, [r3, #0]
    138c:	88fa      	ldrh	r2, [r7, #6]
    138e:	68b9      	ldr	r1, [r7, #8]
    1390:	68f8      	ldr	r0, [r7, #12]
    1392:	4798      	blx	r3
    1394:	4603      	mov	r3, r0
}
    1396:	4618      	mov	r0, r3
    1398:	3710      	adds	r7, #16
    139a:	46bd      	mov	sp, r7
    139c:	bd80      	pop	{r7, pc}
    139e:	bf00      	nop
    13a0:	000046d0 	.word	0x000046d0
    13a4:	0000168d 	.word	0x0000168d

000013a8 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    13a8:	b580      	push	{r7, lr}
    13aa:	b084      	sub	sp, #16
    13ac:	af00      	add	r7, sp, #0
    13ae:	60f8      	str	r0, [r7, #12]
    13b0:	60b9      	str	r1, [r7, #8]
    13b2:	4613      	mov	r3, r2
    13b4:	80fb      	strh	r3, [r7, #6]
	ASSERT(io_descr && buf);
    13b6:	68fb      	ldr	r3, [r7, #12]
    13b8:	2b00      	cmp	r3, #0
    13ba:	d004      	beq.n	13c6 <io_read+0x1e>
    13bc:	68bb      	ldr	r3, [r7, #8]
    13be:	2b00      	cmp	r3, #0
    13c0:	d001      	beq.n	13c6 <io_read+0x1e>
    13c2:	2301      	movs	r3, #1
    13c4:	e000      	b.n	13c8 <io_read+0x20>
    13c6:	2300      	movs	r3, #0
    13c8:	f003 0301 	and.w	r3, r3, #1
    13cc:	b2db      	uxtb	r3, r3
    13ce:	223d      	movs	r2, #61	; 0x3d
    13d0:	4907      	ldr	r1, [pc, #28]	; (13f0 <io_read+0x48>)
    13d2:	4618      	mov	r0, r3
    13d4:	4b07      	ldr	r3, [pc, #28]	; (13f4 <io_read+0x4c>)
    13d6:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    13d8:	68fb      	ldr	r3, [r7, #12]
    13da:	685b      	ldr	r3, [r3, #4]
    13dc:	88fa      	ldrh	r2, [r7, #6]
    13de:	68b9      	ldr	r1, [r7, #8]
    13e0:	68f8      	ldr	r0, [r7, #12]
    13e2:	4798      	blx	r3
    13e4:	4603      	mov	r3, r0
}
    13e6:	4618      	mov	r0, r3
    13e8:	3710      	adds	r7, #16
    13ea:	46bd      	mov	sp, r7
    13ec:	bd80      	pop	{r7, pc}
    13ee:	bf00      	nop
    13f0:	000046d0 	.word	0x000046d0
    13f4:	0000168d 	.word	0x0000168d

000013f8 <mac_async_init>:

/**
 * \brief Initialize the MAC driver
 */
int32_t mac_async_init(struct mac_async_descriptor *const descr, void *const hw)
{
    13f8:	b580      	push	{r7, lr}
    13fa:	b082      	sub	sp, #8
    13fc:	af00      	add	r7, sp, #0
    13fe:	6078      	str	r0, [r7, #4]
    1400:	6039      	str	r1, [r7, #0]
	ASSERT(descr && hw);
    1402:	687b      	ldr	r3, [r7, #4]
    1404:	2b00      	cmp	r3, #0
    1406:	d004      	beq.n	1412 <mac_async_init+0x1a>
    1408:	683b      	ldr	r3, [r7, #0]
    140a:	2b00      	cmp	r3, #0
    140c:	d001      	beq.n	1412 <mac_async_init+0x1a>
    140e:	2301      	movs	r3, #1
    1410:	e000      	b.n	1414 <mac_async_init+0x1c>
    1412:	2300      	movs	r3, #0
    1414:	f003 0301 	and.w	r3, r3, #1
    1418:	b2db      	uxtb	r3, r3
    141a:	2231      	movs	r2, #49	; 0x31
    141c:	4906      	ldr	r1, [pc, #24]	; (1438 <mac_async_init+0x40>)
    141e:	4618      	mov	r0, r3
    1420:	4b06      	ldr	r3, [pc, #24]	; (143c <mac_async_init+0x44>)
    1422:	4798      	blx	r3

	return _mac_async_init(&descr->dev, hw);
    1424:	687b      	ldr	r3, [r7, #4]
    1426:	6839      	ldr	r1, [r7, #0]
    1428:	4618      	mov	r0, r3
    142a:	4b05      	ldr	r3, [pc, #20]	; (1440 <mac_async_init+0x48>)
    142c:	4798      	blx	r3
    142e:	4603      	mov	r3, r0
}
    1430:	4618      	mov	r0, r3
    1432:	3708      	adds	r7, #8
    1434:	46bd      	mov	sp, r7
    1436:	bd80      	pop	{r7, pc}
    1438:	000046e4 	.word	0x000046e4
    143c:	0000168d 	.word	0x0000168d
    1440:	00002a7d 	.word	0x00002a7d

00001444 <mac_async_enable>:

/**
 * \brief Enable the MAC
 */
int32_t mac_async_enable(struct mac_async_descriptor *const descr)
{
    1444:	b580      	push	{r7, lr}
    1446:	b082      	sub	sp, #8
    1448:	af00      	add	r7, sp, #0
    144a:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
    144c:	687b      	ldr	r3, [r7, #4]
    144e:	2b00      	cmp	r3, #0
    1450:	bf14      	ite	ne
    1452:	2301      	movne	r3, #1
    1454:	2300      	moveq	r3, #0
    1456:	b2db      	uxtb	r3, r3
    1458:	2245      	movs	r2, #69	; 0x45
    145a:	4906      	ldr	r1, [pc, #24]	; (1474 <mac_async_enable+0x30>)
    145c:	4618      	mov	r0, r3
    145e:	4b06      	ldr	r3, [pc, #24]	; (1478 <mac_async_enable+0x34>)
    1460:	4798      	blx	r3

	return _mac_async_enable(&descr->dev);
    1462:	687b      	ldr	r3, [r7, #4]
    1464:	4618      	mov	r0, r3
    1466:	4b05      	ldr	r3, [pc, #20]	; (147c <mac_async_enable+0x38>)
    1468:	4798      	blx	r3
    146a:	4603      	mov	r3, r0
}
    146c:	4618      	mov	r0, r3
    146e:	3708      	adds	r7, #8
    1470:	46bd      	mov	sp, r7
    1472:	bd80      	pop	{r7, pc}
    1474:	000046e4 	.word	0x000046e4
    1478:	0000168d 	.word	0x0000168d
    147c:	00002b35 	.word	0x00002b35

00001480 <usart_sync_init>:

/**
 * \brief Initialize usart interface
 */
int32_t usart_sync_init(struct usart_sync_descriptor *const descr, void *const hw, void *const func)
{
    1480:	b580      	push	{r7, lr}
    1482:	b086      	sub	sp, #24
    1484:	af00      	add	r7, sp, #0
    1486:	60f8      	str	r0, [r7, #12]
    1488:	60b9      	str	r1, [r7, #8]
    148a:	607a      	str	r2, [r7, #4]
	int32_t init_status;
	ASSERT(descr && hw);
    148c:	68fb      	ldr	r3, [r7, #12]
    148e:	2b00      	cmp	r3, #0
    1490:	d004      	beq.n	149c <usart_sync_init+0x1c>
    1492:	68bb      	ldr	r3, [r7, #8]
    1494:	2b00      	cmp	r3, #0
    1496:	d001      	beq.n	149c <usart_sync_init+0x1c>
    1498:	2301      	movs	r3, #1
    149a:	e000      	b.n	149e <usart_sync_init+0x1e>
    149c:	2300      	movs	r3, #0
    149e:	f003 0301 	and.w	r3, r3, #1
    14a2:	b2db      	uxtb	r3, r3
    14a4:	2234      	movs	r2, #52	; 0x34
    14a6:	490d      	ldr	r1, [pc, #52]	; (14dc <usart_sync_init+0x5c>)
    14a8:	4618      	mov	r0, r3
    14aa:	4b0d      	ldr	r3, [pc, #52]	; (14e0 <usart_sync_init+0x60>)
    14ac:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    14ae:	68fb      	ldr	r3, [r7, #12]
    14b0:	3308      	adds	r3, #8
    14b2:	68b9      	ldr	r1, [r7, #8]
    14b4:	4618      	mov	r0, r3
    14b6:	4b0b      	ldr	r3, [pc, #44]	; (14e4 <usart_sync_init+0x64>)
    14b8:	4798      	blx	r3
    14ba:	6178      	str	r0, [r7, #20]
	if (init_status) {
    14bc:	697b      	ldr	r3, [r7, #20]
    14be:	2b00      	cmp	r3, #0
    14c0:	d001      	beq.n	14c6 <usart_sync_init+0x46>
		return init_status;
    14c2:	697b      	ldr	r3, [r7, #20]
    14c4:	e006      	b.n	14d4 <usart_sync_init+0x54>
	}

	descr->io.read  = usart_sync_read;
    14c6:	68fb      	ldr	r3, [r7, #12]
    14c8:	4a07      	ldr	r2, [pc, #28]	; (14e8 <usart_sync_init+0x68>)
    14ca:	605a      	str	r2, [r3, #4]
	descr->io.write = usart_sync_write;
    14cc:	68fb      	ldr	r3, [r7, #12]
    14ce:	4a07      	ldr	r2, [pc, #28]	; (14ec <usart_sync_init+0x6c>)
    14d0:	601a      	str	r2, [r3, #0]

	return ERR_NONE;
    14d2:	2300      	movs	r3, #0
}
    14d4:	4618      	mov	r0, r3
    14d6:	3718      	adds	r7, #24
    14d8:	46bd      	mov	sp, r7
    14da:	bd80      	pop	{r7, pc}
    14dc:	00004700 	.word	0x00004700
    14e0:	0000168d 	.word	0x0000168d
    14e4:	00002fd5 	.word	0x00002fd5
    14e8:	000015f9 	.word	0x000015f9
    14ec:	00001531 	.word	0x00001531

000014f0 <usart_sync_enable>:

/**
 * \brief Enable usart interface
 */
int32_t usart_sync_enable(struct usart_sync_descriptor *const descr)
{
    14f0:	b580      	push	{r7, lr}
    14f2:	b082      	sub	sp, #8
    14f4:	af00      	add	r7, sp, #0
    14f6:	6078      	str	r0, [r7, #4]
	ASSERT(descr);
    14f8:	687b      	ldr	r3, [r7, #4]
    14fa:	2b00      	cmp	r3, #0
    14fc:	bf14      	ite	ne
    14fe:	2301      	movne	r3, #1
    1500:	2300      	moveq	r3, #0
    1502:	b2db      	uxtb	r3, r3
    1504:	2253      	movs	r2, #83	; 0x53
    1506:	4907      	ldr	r1, [pc, #28]	; (1524 <usart_sync_enable+0x34>)
    1508:	4618      	mov	r0, r3
    150a:	4b07      	ldr	r3, [pc, #28]	; (1528 <usart_sync_enable+0x38>)
    150c:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    150e:	687b      	ldr	r3, [r7, #4]
    1510:	3308      	adds	r3, #8
    1512:	4618      	mov	r0, r3
    1514:	4b05      	ldr	r3, [pc, #20]	; (152c <usart_sync_enable+0x3c>)
    1516:	4798      	blx	r3

	return ERR_NONE;
    1518:	2300      	movs	r3, #0
}
    151a:	4618      	mov	r0, r3
    151c:	3708      	adds	r7, #8
    151e:	46bd      	mov	sp, r7
    1520:	bd80      	pop	{r7, pc}
    1522:	bf00      	nop
    1524:	00004700 	.word	0x00004700
    1528:	0000168d 	.word	0x0000168d
    152c:	00003019 	.word	0x00003019

00001530 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    1530:	b580      	push	{r7, lr}
    1532:	b086      	sub	sp, #24
    1534:	af00      	add	r7, sp, #0
    1536:	60f8      	str	r0, [r7, #12]
    1538:	60b9      	str	r1, [r7, #8]
    153a:	4613      	mov	r3, r2
    153c:	80fb      	strh	r3, [r7, #6]
	uint32_t                      offset = 0;
    153e:	2300      	movs	r3, #0
    1540:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    1542:	68fb      	ldr	r3, [r7, #12]
    1544:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    1546:	68fb      	ldr	r3, [r7, #12]
    1548:	2b00      	cmp	r3, #0
    154a:	d007      	beq.n	155c <usart_sync_write+0x2c>
    154c:	68bb      	ldr	r3, [r7, #8]
    154e:	2b00      	cmp	r3, #0
    1550:	d004      	beq.n	155c <usart_sync_write+0x2c>
    1552:	88fb      	ldrh	r3, [r7, #6]
    1554:	2b00      	cmp	r3, #0
    1556:	d001      	beq.n	155c <usart_sync_write+0x2c>
    1558:	2301      	movs	r3, #1
    155a:	e000      	b.n	155e <usart_sync_write+0x2e>
    155c:	2300      	movs	r3, #0
    155e:	f003 0301 	and.w	r3, r3, #1
    1562:	b2db      	uxtb	r3, r3
    1564:	22f1      	movs	r2, #241	; 0xf1
    1566:	491f      	ldr	r1, [pc, #124]	; (15e4 <usart_sync_write+0xb4>)
    1568:	4618      	mov	r0, r3
    156a:	4b1f      	ldr	r3, [pc, #124]	; (15e8 <usart_sync_write+0xb8>)
    156c:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    156e:	bf00      	nop
    1570:	693b      	ldr	r3, [r7, #16]
    1572:	3308      	adds	r3, #8
    1574:	4618      	mov	r0, r3
    1576:	4b1d      	ldr	r3, [pc, #116]	; (15ec <usart_sync_write+0xbc>)
    1578:	4798      	blx	r3
    157a:	4603      	mov	r3, r0
    157c:	f083 0301 	eor.w	r3, r3, #1
    1580:	b2db      	uxtb	r3, r3
    1582:	2b00      	cmp	r3, #0
    1584:	d1f4      	bne.n	1570 <usart_sync_write+0x40>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    1586:	693b      	ldr	r3, [r7, #16]
    1588:	f103 0008 	add.w	r0, r3, #8
    158c:	68ba      	ldr	r2, [r7, #8]
    158e:	697b      	ldr	r3, [r7, #20]
    1590:	4413      	add	r3, r2
    1592:	781b      	ldrb	r3, [r3, #0]
    1594:	4619      	mov	r1, r3
    1596:	4b16      	ldr	r3, [pc, #88]	; (15f0 <usart_sync_write+0xc0>)
    1598:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
    159a:	bf00      	nop
    159c:	693b      	ldr	r3, [r7, #16]
    159e:	3308      	adds	r3, #8
    15a0:	4618      	mov	r0, r3
    15a2:	4b12      	ldr	r3, [pc, #72]	; (15ec <usart_sync_write+0xbc>)
    15a4:	4798      	blx	r3
    15a6:	4603      	mov	r3, r0
    15a8:	f083 0301 	eor.w	r3, r3, #1
    15ac:	b2db      	uxtb	r3, r3
    15ae:	2b00      	cmp	r3, #0
    15b0:	d1f4      	bne.n	159c <usart_sync_write+0x6c>
			;
	} while (++offset < length);
    15b2:	697b      	ldr	r3, [r7, #20]
    15b4:	3301      	adds	r3, #1
    15b6:	617b      	str	r3, [r7, #20]
    15b8:	88fb      	ldrh	r3, [r7, #6]
    15ba:	697a      	ldr	r2, [r7, #20]
    15bc:	429a      	cmp	r2, r3
    15be:	d3e2      	bcc.n	1586 <usart_sync_write+0x56>
	while (!_usart_sync_is_transmit_done(&descr->device))
    15c0:	bf00      	nop
    15c2:	693b      	ldr	r3, [r7, #16]
    15c4:	3308      	adds	r3, #8
    15c6:	4618      	mov	r0, r3
    15c8:	4b0a      	ldr	r3, [pc, #40]	; (15f4 <usart_sync_write+0xc4>)
    15ca:	4798      	blx	r3
    15cc:	4603      	mov	r3, r0
    15ce:	f083 0301 	eor.w	r3, r3, #1
    15d2:	b2db      	uxtb	r3, r3
    15d4:	2b00      	cmp	r3, #0
    15d6:	d1f4      	bne.n	15c2 <usart_sync_write+0x92>
		;
	return (int32_t)offset;
    15d8:	697b      	ldr	r3, [r7, #20]
}
    15da:	4618      	mov	r0, r3
    15dc:	3718      	adds	r7, #24
    15de:	46bd      	mov	sp, r7
    15e0:	bd80      	pop	{r7, pc}
    15e2:	bf00      	nop
    15e4:	00004700 	.word	0x00004700
    15e8:	0000168d 	.word	0x0000168d
    15ec:	00003085 	.word	0x00003085
    15f0:	00003039 	.word	0x00003039
    15f4:	000030a5 	.word	0x000030a5

000015f8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    15f8:	b590      	push	{r4, r7, lr}
    15fa:	b087      	sub	sp, #28
    15fc:	af00      	add	r7, sp, #0
    15fe:	60f8      	str	r0, [r7, #12]
    1600:	60b9      	str	r1, [r7, #8]
    1602:	4613      	mov	r3, r2
    1604:	80fb      	strh	r3, [r7, #6]
	uint32_t                      offset = 0;
    1606:	2300      	movs	r3, #0
    1608:	617b      	str	r3, [r7, #20]
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);
    160a:	68fb      	ldr	r3, [r7, #12]
    160c:	613b      	str	r3, [r7, #16]

	ASSERT(io_descr && buf && length);
    160e:	68fb      	ldr	r3, [r7, #12]
    1610:	2b00      	cmp	r3, #0
    1612:	d007      	beq.n	1624 <usart_sync_read+0x2c>
    1614:	68bb      	ldr	r3, [r7, #8]
    1616:	2b00      	cmp	r3, #0
    1618:	d004      	beq.n	1624 <usart_sync_read+0x2c>
    161a:	88fb      	ldrh	r3, [r7, #6]
    161c:	2b00      	cmp	r3, #0
    161e:	d001      	beq.n	1624 <usart_sync_read+0x2c>
    1620:	2301      	movs	r3, #1
    1622:	e000      	b.n	1626 <usart_sync_read+0x2e>
    1624:	2300      	movs	r3, #0
    1626:	f003 0301 	and.w	r3, r3, #1
    162a:	b2db      	uxtb	r3, r3
    162c:	f44f 7286 	mov.w	r2, #268	; 0x10c
    1630:	4912      	ldr	r1, [pc, #72]	; (167c <usart_sync_read+0x84>)
    1632:	4618      	mov	r0, r3
    1634:	4b12      	ldr	r3, [pc, #72]	; (1680 <usart_sync_read+0x88>)
    1636:	4798      	blx	r3
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    1638:	bf00      	nop
    163a:	693b      	ldr	r3, [r7, #16]
    163c:	3308      	adds	r3, #8
    163e:	4618      	mov	r0, r3
    1640:	4b10      	ldr	r3, [pc, #64]	; (1684 <usart_sync_read+0x8c>)
    1642:	4798      	blx	r3
    1644:	4603      	mov	r3, r0
    1646:	f083 0301 	eor.w	r3, r3, #1
    164a:	b2db      	uxtb	r3, r3
    164c:	2b00      	cmp	r3, #0
    164e:	d1f4      	bne.n	163a <usart_sync_read+0x42>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    1650:	68ba      	ldr	r2, [r7, #8]
    1652:	697b      	ldr	r3, [r7, #20]
    1654:	18d4      	adds	r4, r2, r3
    1656:	693b      	ldr	r3, [r7, #16]
    1658:	3308      	adds	r3, #8
    165a:	4618      	mov	r0, r3
    165c:	4b0a      	ldr	r3, [pc, #40]	; (1688 <usart_sync_read+0x90>)
    165e:	4798      	blx	r3
    1660:	4603      	mov	r3, r0
    1662:	7023      	strb	r3, [r4, #0]
	} while (++offset < length);
    1664:	697b      	ldr	r3, [r7, #20]
    1666:	3301      	adds	r3, #1
    1668:	617b      	str	r3, [r7, #20]
    166a:	88fb      	ldrh	r3, [r7, #6]
    166c:	697a      	ldr	r2, [r7, #20]
    166e:	429a      	cmp	r2, r3
    1670:	d3e2      	bcc.n	1638 <usart_sync_read+0x40>

	return (int32_t)offset;
    1672:	697b      	ldr	r3, [r7, #20]
}
    1674:	4618      	mov	r0, r3
    1676:	371c      	adds	r7, #28
    1678:	46bd      	mov	sp, r7
    167a:	bd90      	pop	{r4, r7, pc}
    167c:	00004700 	.word	0x00004700
    1680:	0000168d 	.word	0x0000168d
    1684:	000030c5 	.word	0x000030c5
    1688:	00003061 	.word	0x00003061

0000168c <assert>:

/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
    168c:	b480      	push	{r7}
    168e:	b085      	sub	sp, #20
    1690:	af00      	add	r7, sp, #0
    1692:	4603      	mov	r3, r0
    1694:	60b9      	str	r1, [r7, #8]
    1696:	607a      	str	r2, [r7, #4]
    1698:	73fb      	strb	r3, [r7, #15]
	if (!(condition)) {
    169a:	7bfb      	ldrb	r3, [r7, #15]
    169c:	f083 0301 	eor.w	r3, r3, #1
    16a0:	b2db      	uxtb	r3, r3
    16a2:	2b00      	cmp	r3, #0
    16a4:	d000      	beq.n	16a8 <assert+0x1c>
		__asm("BKPT #0");
    16a6:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    16a8:	bf00      	nop
    16aa:	3714      	adds	r7, #20
    16ac:	46bd      	mov	sp, r7
    16ae:	f85d 7b04 	ldr.w	r7, [sp], #4
    16b2:	4770      	bx	lr

000016b4 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
    16b4:	b480      	push	{r7}
    16b6:	b085      	sub	sp, #20
    16b8:	af00      	add	r7, sp, #0
    16ba:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    16bc:	4b0b      	ldr	r3, [pc, #44]	; (16ec <_sbrk+0x38>)
    16be:	681b      	ldr	r3, [r3, #0]
    16c0:	2b00      	cmp	r3, #0
    16c2:	d102      	bne.n	16ca <_sbrk+0x16>
		heap = (unsigned char *)&_end;
    16c4:	4b09      	ldr	r3, [pc, #36]	; (16ec <_sbrk+0x38>)
    16c6:	4a0a      	ldr	r2, [pc, #40]	; (16f0 <_sbrk+0x3c>)
    16c8:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
    16ca:	4b08      	ldr	r3, [pc, #32]	; (16ec <_sbrk+0x38>)
    16cc:	681b      	ldr	r3, [r3, #0]
    16ce:	60fb      	str	r3, [r7, #12]

	heap += incr;
    16d0:	4b06      	ldr	r3, [pc, #24]	; (16ec <_sbrk+0x38>)
    16d2:	681a      	ldr	r2, [r3, #0]
    16d4:	687b      	ldr	r3, [r7, #4]
    16d6:	4413      	add	r3, r2
    16d8:	4a04      	ldr	r2, [pc, #16]	; (16ec <_sbrk+0x38>)
    16da:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
    16dc:	68fb      	ldr	r3, [r7, #12]
}
    16de:	4618      	mov	r0, r3
    16e0:	3714      	adds	r7, #20
    16e2:	46bd      	mov	sp, r7
    16e4:	f85d 7b04 	ldr.w	r7, [sp], #4
    16e8:	4770      	bx	lr
    16ea:	bf00      	nop
    16ec:	200000c0 	.word	0x200000c0
    16f0:	20011750 	.word	0x20011750

000016f4 <_close>:

/**
 * \brief Replacement of C library of _close
 */
extern int _close(int file)
{
    16f4:	b480      	push	{r7}
    16f6:	b083      	sub	sp, #12
    16f8:	af00      	add	r7, sp, #0
    16fa:	6078      	str	r0, [r7, #4]
	(void)file;
	return -1;
    16fc:	f04f 33ff 	mov.w	r3, #4294967295
}
    1700:	4618      	mov	r0, r3
    1702:	370c      	adds	r7, #12
    1704:	46bd      	mov	sp, r7
    1706:	f85d 7b04 	ldr.w	r7, [sp], #4
    170a:	4770      	bx	lr

0000170c <_fstat>:

/**
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
    170c:	b480      	push	{r7}
    170e:	b083      	sub	sp, #12
    1710:	af00      	add	r7, sp, #0
    1712:	6078      	str	r0, [r7, #4]
    1714:	6039      	str	r1, [r7, #0]
	(void)file;
	st->st_mode = S_IFCHR;
    1716:	683b      	ldr	r3, [r7, #0]
    1718:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    171c:	605a      	str	r2, [r3, #4]

	return 0;
    171e:	2300      	movs	r3, #0
}
    1720:	4618      	mov	r0, r3
    1722:	370c      	adds	r7, #12
    1724:	46bd      	mov	sp, r7
    1726:	f85d 7b04 	ldr.w	r7, [sp], #4
    172a:	4770      	bx	lr

0000172c <_lseek>:

/**
 * \brief Replacement of C library of _lseek
 */
extern int _lseek(int file, int ptr, int dir)
{
    172c:	b480      	push	{r7}
    172e:	b085      	sub	sp, #20
    1730:	af00      	add	r7, sp, #0
    1732:	60f8      	str	r0, [r7, #12]
    1734:	60b9      	str	r1, [r7, #8]
    1736:	607a      	str	r2, [r7, #4]
	(void)file, (void)ptr, (void)dir;
	return 0;
    1738:	2300      	movs	r3, #0
}
    173a:	4618      	mov	r0, r3
    173c:	3714      	adds	r7, #20
    173e:	46bd      	mov	sp, r7
    1740:	f85d 7b04 	ldr.w	r7, [sp], #4
    1744:	4770      	bx	lr

00001746 <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_sampctrl_reg_t;
typedef uint8_t  hri_adc_status_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
    1746:	b480      	push	{r7}
    1748:	b083      	sub	sp, #12
    174a:	af00      	add	r7, sp, #0
    174c:	6078      	str	r0, [r7, #4]
    174e:	6039      	str	r1, [r7, #0]
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
    1750:	bf00      	nop
    1752:	687b      	ldr	r3, [r7, #4]
    1754:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1756:	683b      	ldr	r3, [r7, #0]
    1758:	4013      	ands	r3, r2
    175a:	2b00      	cmp	r3, #0
    175c:	d1f9      	bne.n	1752 <hri_adc_wait_for_sync+0xc>
	};
}
    175e:	bf00      	nop
    1760:	370c      	adds	r7, #12
    1762:	46bd      	mov	sp, r7
    1764:	f85d 7b04 	ldr.w	r7, [sp], #4
    1768:	4770      	bx	lr

0000176a <hri_adc_is_syncing>:

static inline bool hri_adc_is_syncing(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
    176a:	b480      	push	{r7}
    176c:	b083      	sub	sp, #12
    176e:	af00      	add	r7, sp, #0
    1770:	6078      	str	r0, [r7, #4]
    1772:	6039      	str	r1, [r7, #0]
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
    1774:	687b      	ldr	r3, [r7, #4]
    1776:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1778:	683b      	ldr	r3, [r7, #0]
    177a:	4013      	ands	r3, r2
    177c:	2b00      	cmp	r3, #0
    177e:	bf14      	ite	ne
    1780:	2301      	movne	r3, #1
    1782:	2300      	moveq	r3, #0
    1784:	b2db      	uxtb	r3, r3
}
    1786:	4618      	mov	r0, r3
    1788:	370c      	adds	r7, #12
    178a:	46bd      	mov	sp, r7
    178c:	f85d 7b04 	ldr.w	r7, [sp], #4
    1790:	4770      	bx	lr

00001792 <hri_adc_get_interrupt_RESRDY_bit>:
{
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_WINMON;
}

static inline bool hri_adc_get_interrupt_RESRDY_bit(const void *const hw)
{
    1792:	b480      	push	{r7}
    1794:	b083      	sub	sp, #12
    1796:	af00      	add	r7, sp, #0
    1798:	6078      	str	r0, [r7, #4]
	return (((Adc *)hw)->INTFLAG.reg & ADC_INTFLAG_RESRDY) >> ADC_INTFLAG_RESRDY_Pos;
    179a:	687b      	ldr	r3, [r7, #4]
    179c:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
    17a0:	b2db      	uxtb	r3, r3
    17a2:	f003 0301 	and.w	r3, r3, #1
    17a6:	2b00      	cmp	r3, #0
    17a8:	bf14      	ite	ne
    17aa:	2301      	movne	r3, #1
    17ac:	2300      	moveq	r3, #0
    17ae:	b2db      	uxtb	r3, r3
}
    17b0:	4618      	mov	r0, r3
    17b2:	370c      	adds	r7, #12
    17b4:	46bd      	mov	sp, r7
    17b6:	f85d 7b04 	ldr.w	r7, [sp], #4
    17ba:	4770      	bx	lr

000017bc <hri_adc_read_RESULT_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_adc_result_reg_t hri_adc_read_RESULT_reg(const void *const hw)
{
    17bc:	b480      	push	{r7}
    17be:	b083      	sub	sp, #12
    17c0:	af00      	add	r7, sp, #0
    17c2:	6078      	str	r0, [r7, #4]
	return ((Adc *)hw)->RESULT.reg;
    17c4:	687b      	ldr	r3, [r7, #4]
    17c6:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
    17ca:	b29b      	uxth	r3, r3
}
    17cc:	4618      	mov	r0, r3
    17ce:	370c      	adds	r7, #12
    17d0:	46bd      	mov	sp, r7
    17d2:	f85d 7b04 	ldr.w	r7, [sp], #4
    17d6:	4770      	bx	lr

000017d8 <hri_adc_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & ADC_CTRLA_SWRST) >> ADC_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_adc_set_CTRLA_ENABLE_bit(const void *const hw)
{
    17d8:	b580      	push	{r7, lr}
    17da:	b082      	sub	sp, #8
    17dc:	af00      	add	r7, sp, #0
    17de:	6078      	str	r0, [r7, #4]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
    17e0:	687b      	ldr	r3, [r7, #4]
    17e2:	881b      	ldrh	r3, [r3, #0]
    17e4:	b29b      	uxth	r3, r3
    17e6:	f043 0302 	orr.w	r3, r3, #2
    17ea:	b29a      	uxth	r2, r3
    17ec:	687b      	ldr	r3, [r7, #4]
    17ee:	801a      	strh	r2, [r3, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    17f0:	2103      	movs	r1, #3
    17f2:	6878      	ldr	r0, [r7, #4]
    17f4:	4b02      	ldr	r3, [pc, #8]	; (1800 <hri_adc_set_CTRLA_ENABLE_bit+0x28>)
    17f6:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    17f8:	bf00      	nop
    17fa:	3708      	adds	r7, #8
    17fc:	46bd      	mov	sp, r7
    17fe:	bd80      	pop	{r7, pc}
    1800:	00001747 	.word	0x00001747

00001804 <hri_adc_clear_CTRLA_ENABLE_bit>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    1804:	b580      	push	{r7, lr}
    1806:	b082      	sub	sp, #8
    1808:	af00      	add	r7, sp, #0
    180a:	6078      	str	r0, [r7, #4]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
    180c:	687b      	ldr	r3, [r7, #4]
    180e:	881b      	ldrh	r3, [r3, #0]
    1810:	b29b      	uxth	r3, r3
    1812:	f023 0302 	bic.w	r3, r3, #2
    1816:	b29a      	uxth	r2, r3
    1818:	687b      	ldr	r3, [r7, #4]
    181a:	801a      	strh	r2, [r3, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    181c:	2103      	movs	r1, #3
    181e:	6878      	ldr	r0, [r7, #4]
    1820:	4b02      	ldr	r3, [pc, #8]	; (182c <hri_adc_clear_CTRLA_ENABLE_bit+0x28>)
    1822:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1824:	bf00      	nop
    1826:	3708      	adds	r7, #8
    1828:	46bd      	mov	sp, r7
    182a:	bd80      	pop	{r7, pc}
    182c:	00001747 	.word	0x00001747

00001830 <hri_adc_get_CTRLA_reg>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
    1830:	b580      	push	{r7, lr}
    1832:	b084      	sub	sp, #16
    1834:	af00      	add	r7, sp, #0
    1836:	6078      	str	r0, [r7, #4]
    1838:	460b      	mov	r3, r1
    183a:	807b      	strh	r3, [r7, #2]
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    183c:	2103      	movs	r1, #3
    183e:	6878      	ldr	r0, [r7, #4]
    1840:	4b06      	ldr	r3, [pc, #24]	; (185c <hri_adc_get_CTRLA_reg+0x2c>)
    1842:	4798      	blx	r3
	tmp = ((Adc *)hw)->CTRLA.reg;
    1844:	687b      	ldr	r3, [r7, #4]
    1846:	881b      	ldrh	r3, [r3, #0]
    1848:	81fb      	strh	r3, [r7, #14]
	tmp &= mask;
    184a:	89fa      	ldrh	r2, [r7, #14]
    184c:	887b      	ldrh	r3, [r7, #2]
    184e:	4013      	ands	r3, r2
    1850:	81fb      	strh	r3, [r7, #14]
	return tmp;
    1852:	89fb      	ldrh	r3, [r7, #14]
}
    1854:	4618      	mov	r0, r3
    1856:	3710      	adds	r7, #16
    1858:	46bd      	mov	sp, r7
    185a:	bd80      	pop	{r7, pc}
    185c:	00001747 	.word	0x00001747

00001860 <hri_adc_write_CTRLA_reg>:

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
    1860:	b580      	push	{r7, lr}
    1862:	b082      	sub	sp, #8
    1864:	af00      	add	r7, sp, #0
    1866:	6078      	str	r0, [r7, #4]
    1868:	460b      	mov	r3, r1
    186a:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
    186c:	687b      	ldr	r3, [r7, #4]
    186e:	887a      	ldrh	r2, [r7, #2]
    1870:	801a      	strh	r2, [r3, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
    1872:	2103      	movs	r1, #3
    1874:	6878      	ldr	r0, [r7, #4]
    1876:	4b03      	ldr	r3, [pc, #12]	; (1884 <hri_adc_write_CTRLA_reg+0x24>)
    1878:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    187a:	bf00      	nop
    187c:	3708      	adds	r7, #8
    187e:	46bd      	mov	sp, r7
    1880:	bd80      	pop	{r7, pc}
    1882:	bf00      	nop
    1884:	00001747 	.word	0x00001747

00001888 <hri_adc_write_EVCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_EVCTRL_reg(const void *const hw, hri_adc_evctrl_reg_t data)
{
    1888:	b480      	push	{r7}
    188a:	b083      	sub	sp, #12
    188c:	af00      	add	r7, sp, #0
    188e:	6078      	str	r0, [r7, #4]
    1890:	460b      	mov	r3, r1
    1892:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->EVCTRL.reg = data;
    1894:	687b      	ldr	r3, [r7, #4]
    1896:	78fa      	ldrb	r2, [r7, #3]
    1898:	709a      	strb	r2, [r3, #2]
	ADC_CRITICAL_SECTION_LEAVE();
}
    189a:	bf00      	nop
    189c:	370c      	adds	r7, #12
    189e:	46bd      	mov	sp, r7
    18a0:	f85d 7b04 	ldr.w	r7, [sp], #4
    18a4:	4770      	bx	lr

000018a6 <hri_adc_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_DBGCTRL_reg(const void *const hw, hri_adc_dbgctrl_reg_t data)
{
    18a6:	b480      	push	{r7}
    18a8:	b083      	sub	sp, #12
    18aa:	af00      	add	r7, sp, #0
    18ac:	6078      	str	r0, [r7, #4]
    18ae:	460b      	mov	r3, r1
    18b0:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->DBGCTRL.reg = data;
    18b2:	687b      	ldr	r3, [r7, #4]
    18b4:	78fa      	ldrb	r2, [r7, #3]
    18b6:	70da      	strb	r2, [r3, #3]
	ADC_CRITICAL_SECTION_LEAVE();
}
    18b8:	bf00      	nop
    18ba:	370c      	adds	r7, #12
    18bc:	46bd      	mov	sp, r7
    18be:	f85d 7b04 	ldr.w	r7, [sp], #4
    18c2:	4770      	bx	lr

000018c4 <hri_adc_write_INPUTCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_INPUTCTRL_reg(const void *const hw, hri_adc_inputctrl_reg_t data)
{
    18c4:	b580      	push	{r7, lr}
    18c6:	b082      	sub	sp, #8
    18c8:	af00      	add	r7, sp, #0
    18ca:	6078      	str	r0, [r7, #4]
    18cc:	460b      	mov	r3, r1
    18ce:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->INPUTCTRL.reg = data;
    18d0:	687b      	ldr	r3, [r7, #4]
    18d2:	887a      	ldrh	r2, [r7, #2]
    18d4:	809a      	strh	r2, [r3, #4]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    18d6:	f640 71ff 	movw	r1, #4095	; 0xfff
    18da:	6878      	ldr	r0, [r7, #4]
    18dc:	4b02      	ldr	r3, [pc, #8]	; (18e8 <hri_adc_write_INPUTCTRL_reg+0x24>)
    18de:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    18e0:	bf00      	nop
    18e2:	3708      	adds	r7, #8
    18e4:	46bd      	mov	sp, r7
    18e6:	bd80      	pop	{r7, pc}
    18e8:	00001747 	.word	0x00001747

000018ec <hri_adc_read_CTRLB_RESSEL_bf>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline hri_adc_ctrlb_reg_t hri_adc_read_CTRLB_RESSEL_bf(const void *const hw)
{
    18ec:	b480      	push	{r7}
    18ee:	b085      	sub	sp, #20
    18f0:	af00      	add	r7, sp, #0
    18f2:	6078      	str	r0, [r7, #4]
	uint16_t tmp;
	tmp = ((Adc *)hw)->CTRLB.reg;
    18f4:	687b      	ldr	r3, [r7, #4]
    18f6:	88db      	ldrh	r3, [r3, #6]
    18f8:	81fb      	strh	r3, [r7, #14]
	tmp = (tmp & ADC_CTRLB_RESSEL_Msk) >> ADC_CTRLB_RESSEL_Pos;
    18fa:	89fb      	ldrh	r3, [r7, #14]
    18fc:	08db      	lsrs	r3, r3, #3
    18fe:	b29b      	uxth	r3, r3
    1900:	f003 0303 	and.w	r3, r3, #3
    1904:	81fb      	strh	r3, [r7, #14]
	return tmp;
    1906:	89fb      	ldrh	r3, [r7, #14]
}
    1908:	4618      	mov	r0, r3
    190a:	3714      	adds	r7, #20
    190c:	46bd      	mov	sp, r7
    190e:	f85d 7b04 	ldr.w	r7, [sp], #4
    1912:	4770      	bx	lr

00001914 <hri_adc_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_CTRLB_reg(const void *const hw, hri_adc_ctrlb_reg_t data)
{
    1914:	b580      	push	{r7, lr}
    1916:	b082      	sub	sp, #8
    1918:	af00      	add	r7, sp, #0
    191a:	6078      	str	r0, [r7, #4]
    191c:	460b      	mov	r3, r1
    191e:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLB.reg = data;
    1920:	687b      	ldr	r3, [r7, #4]
    1922:	887a      	ldrh	r2, [r7, #2]
    1924:	80da      	strh	r2, [r3, #6]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    1926:	f640 71ff 	movw	r1, #4095	; 0xfff
    192a:	6878      	ldr	r0, [r7, #4]
    192c:	4b02      	ldr	r3, [pc, #8]	; (1938 <hri_adc_write_CTRLB_reg+0x24>)
    192e:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1930:	bf00      	nop
    1932:	3708      	adds	r7, #8
    1934:	46bd      	mov	sp, r7
    1936:	bd80      	pop	{r7, pc}
    1938:	00001747 	.word	0x00001747

0000193c <hri_adc_write_REFCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_REFCTRL_reg(const void *const hw, hri_adc_refctrl_reg_t data)
{
    193c:	b580      	push	{r7, lr}
    193e:	b082      	sub	sp, #8
    1940:	af00      	add	r7, sp, #0
    1942:	6078      	str	r0, [r7, #4]
    1944:	460b      	mov	r3, r1
    1946:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->REFCTRL.reg = data;
    1948:	687b      	ldr	r3, [r7, #4]
    194a:	78fa      	ldrb	r2, [r7, #3]
    194c:	721a      	strb	r2, [r3, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    194e:	f640 71ff 	movw	r1, #4095	; 0xfff
    1952:	6878      	ldr	r0, [r7, #4]
    1954:	4b02      	ldr	r3, [pc, #8]	; (1960 <hri_adc_write_REFCTRL_reg+0x24>)
    1956:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1958:	bf00      	nop
    195a:	3708      	adds	r7, #8
    195c:	46bd      	mov	sp, r7
    195e:	bd80      	pop	{r7, pc}
    1960:	00001747 	.word	0x00001747

00001964 <hri_adc_write_AVGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_AVGCTRL_reg(const void *const hw, hri_adc_avgctrl_reg_t data)
{
    1964:	b580      	push	{r7, lr}
    1966:	b082      	sub	sp, #8
    1968:	af00      	add	r7, sp, #0
    196a:	6078      	str	r0, [r7, #4]
    196c:	460b      	mov	r3, r1
    196e:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->AVGCTRL.reg = data;
    1970:	687b      	ldr	r3, [r7, #4]
    1972:	78fa      	ldrb	r2, [r7, #3]
    1974:	729a      	strb	r2, [r3, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    1976:	f640 71ff 	movw	r1, #4095	; 0xfff
    197a:	6878      	ldr	r0, [r7, #4]
    197c:	4b02      	ldr	r3, [pc, #8]	; (1988 <hri_adc_write_AVGCTRL_reg+0x24>)
    197e:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1980:	bf00      	nop
    1982:	3708      	adds	r7, #8
    1984:	46bd      	mov	sp, r7
    1986:	bd80      	pop	{r7, pc}
    1988:	00001747 	.word	0x00001747

0000198c <hri_adc_write_SAMPCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_SAMPCTRL_reg(const void *const hw, hri_adc_sampctrl_reg_t data)
{
    198c:	b580      	push	{r7, lr}
    198e:	b082      	sub	sp, #8
    1990:	af00      	add	r7, sp, #0
    1992:	6078      	str	r0, [r7, #4]
    1994:	460b      	mov	r3, r1
    1996:	70fb      	strb	r3, [r7, #3]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->SAMPCTRL.reg = data;
    1998:	687b      	ldr	r3, [r7, #4]
    199a:	78fa      	ldrb	r2, [r7, #3]
    199c:	72da      	strb	r2, [r3, #11]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    199e:	f640 71ff 	movw	r1, #4095	; 0xfff
    19a2:	6878      	ldr	r0, [r7, #4]
    19a4:	4b02      	ldr	r3, [pc, #8]	; (19b0 <hri_adc_write_SAMPCTRL_reg+0x24>)
    19a6:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    19a8:	bf00      	nop
    19aa:	3708      	adds	r7, #8
    19ac:	46bd      	mov	sp, r7
    19ae:	bd80      	pop	{r7, pc}
    19b0:	00001747 	.word	0x00001747

000019b4 <hri_adc_write_WINLT_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_WINLT_reg(const void *const hw, hri_adc_winlt_reg_t data)
{
    19b4:	b580      	push	{r7, lr}
    19b6:	b082      	sub	sp, #8
    19b8:	af00      	add	r7, sp, #0
    19ba:	6078      	str	r0, [r7, #4]
    19bc:	460b      	mov	r3, r1
    19be:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->WINLT.reg = data;
    19c0:	687b      	ldr	r3, [r7, #4]
    19c2:	887a      	ldrh	r2, [r7, #2]
    19c4:	819a      	strh	r2, [r3, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
    19c6:	2180      	movs	r1, #128	; 0x80
    19c8:	6878      	ldr	r0, [r7, #4]
    19ca:	4b03      	ldr	r3, [pc, #12]	; (19d8 <hri_adc_write_WINLT_reg+0x24>)
    19cc:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    19ce:	bf00      	nop
    19d0:	3708      	adds	r7, #8
    19d2:	46bd      	mov	sp, r7
    19d4:	bd80      	pop	{r7, pc}
    19d6:	bf00      	nop
    19d8:	00001747 	.word	0x00001747

000019dc <hri_adc_write_WINUT_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_WINUT_reg(const void *const hw, hri_adc_winut_reg_t data)
{
    19dc:	b580      	push	{r7, lr}
    19de:	b082      	sub	sp, #8
    19e0:	af00      	add	r7, sp, #0
    19e2:	6078      	str	r0, [r7, #4]
    19e4:	460b      	mov	r3, r1
    19e6:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->WINUT.reg = data;
    19e8:	687b      	ldr	r3, [r7, #4]
    19ea:	887a      	ldrh	r2, [r7, #2]
    19ec:	81da      	strh	r2, [r3, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
    19ee:	f44f 7180 	mov.w	r1, #256	; 0x100
    19f2:	6878      	ldr	r0, [r7, #4]
    19f4:	4b02      	ldr	r3, [pc, #8]	; (1a00 <hri_adc_write_WINUT_reg+0x24>)
    19f6:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    19f8:	bf00      	nop
    19fa:	3708      	adds	r7, #8
    19fc:	46bd      	mov	sp, r7
    19fe:	bd80      	pop	{r7, pc}
    1a00:	00001747 	.word	0x00001747

00001a04 <hri_adc_write_GAINCORR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_GAINCORR_reg(const void *const hw, hri_adc_gaincorr_reg_t data)
{
    1a04:	b580      	push	{r7, lr}
    1a06:	b082      	sub	sp, #8
    1a08:	af00      	add	r7, sp, #0
    1a0a:	6078      	str	r0, [r7, #4]
    1a0c:	460b      	mov	r3, r1
    1a0e:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->GAINCORR.reg = data;
    1a10:	687b      	ldr	r3, [r7, #4]
    1a12:	887a      	ldrh	r2, [r7, #2]
    1a14:	821a      	strh	r2, [r3, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
    1a16:	f44f 7100 	mov.w	r1, #512	; 0x200
    1a1a:	6878      	ldr	r0, [r7, #4]
    1a1c:	4b02      	ldr	r3, [pc, #8]	; (1a28 <hri_adc_write_GAINCORR_reg+0x24>)
    1a1e:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1a20:	bf00      	nop
    1a22:	3708      	adds	r7, #8
    1a24:	46bd      	mov	sp, r7
    1a26:	bd80      	pop	{r7, pc}
    1a28:	00001747 	.word	0x00001747

00001a2c <hri_adc_write_OFFSETCORR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_adc_write_OFFSETCORR_reg(const void *const hw, hri_adc_offsetcorr_reg_t data)
{
    1a2c:	b580      	push	{r7, lr}
    1a2e:	b082      	sub	sp, #8
    1a30:	af00      	add	r7, sp, #0
    1a32:	6078      	str	r0, [r7, #4]
    1a34:	460b      	mov	r3, r1
    1a36:	807b      	strh	r3, [r7, #2]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->OFFSETCORR.reg = data;
    1a38:	687b      	ldr	r3, [r7, #4]
    1a3a:	887a      	ldrh	r2, [r7, #2]
    1a3c:	825a      	strh	r2, [r3, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
    1a3e:	f44f 6180 	mov.w	r1, #1024	; 0x400
    1a42:	6878      	ldr	r0, [r7, #4]
    1a44:	4b02      	ldr	r3, [pc, #8]	; (1a50 <hri_adc_write_OFFSETCORR_reg+0x24>)
    1a46:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1a48:	bf00      	nop
    1a4a:	3708      	adds	r7, #8
    1a4c:	46bd      	mov	sp, r7
    1a4e:	bd80      	pop	{r7, pc}
    1a50:	00001747 	.word	0x00001747

00001a54 <hri_adc_set_SWTRIG_START_bit>:
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
	ADC_CRITICAL_SECTION_LEAVE();
}

static inline void hri_adc_set_SWTRIG_START_bit(const void *const hw)
{
    1a54:	b580      	push	{r7, lr}
    1a56:	b082      	sub	sp, #8
    1a58:	af00      	add	r7, sp, #0
    1a5a:	6078      	str	r0, [r7, #4]
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
    1a5c:	687b      	ldr	r3, [r7, #4]
    1a5e:	7d1b      	ldrb	r3, [r3, #20]
    1a60:	b2db      	uxtb	r3, r3
    1a62:	f043 0302 	orr.w	r3, r3, #2
    1a66:	b2da      	uxtb	r2, r3
    1a68:	687b      	ldr	r3, [r7, #4]
    1a6a:	751a      	strb	r2, [r3, #20]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
    1a6c:	f640 71ff 	movw	r1, #4095	; 0xfff
    1a70:	6878      	ldr	r0, [r7, #4]
    1a72:	4b03      	ldr	r3, [pc, #12]	; (1a80 <hri_adc_set_SWTRIG_START_bit+0x2c>)
    1a74:	4798      	blx	r3
	ADC_CRITICAL_SECTION_LEAVE();
}
    1a76:	bf00      	nop
    1a78:	3708      	adds	r7, #8
    1a7a:	46bd      	mov	sp, r7
    1a7c:	bd80      	pop	{r7, pc}
    1a7e:	bf00      	nop
    1a80:	00001747 	.word	0x00001747

00001a84 <_adc_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given adc hardware instance
 */
static uint8_t _adc_get_hardware_index(const void *const hw)
{
    1a84:	b480      	push	{r7}
    1a86:	b083      	sub	sp, #12
    1a88:	af00      	add	r7, sp, #0
    1a8a:	6078      	str	r0, [r7, #4]
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
    1a8c:	687b      	ldr	r3, [r7, #4]
    1a8e:	f103 433d 	add.w	r3, r3, #3170893824	; 0xbd000000
    1a92:	f5a3 53e0 	sub.w	r3, r3, #7168	; 0x1c00
    1a96:	0a9b      	lsrs	r3, r3, #10
    1a98:	b2db      	uxtb	r3, r3
}
    1a9a:	4618      	mov	r0, r3
    1a9c:	370c      	adds	r7, #12
    1a9e:	46bd      	mov	sp, r7
    1aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
    1aa4:	4770      	bx	lr
	...

00001aa8 <_adc_get_regs>:
/** \brief Return the pointer to register settings of specific ADC
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific ADC.
 */
static uint8_t _adc_get_regs(const uint32_t hw_addr)
{
    1aa8:	b580      	push	{r7, lr}
    1aaa:	b084      	sub	sp, #16
    1aac:	af00      	add	r7, sp, #0
    1aae:	6078      	str	r0, [r7, #4]
	uint8_t n = _adc_get_hardware_index((const void *)hw_addr);
    1ab0:	687b      	ldr	r3, [r7, #4]
    1ab2:	4618      	mov	r0, r3
    1ab4:	4b11      	ldr	r3, [pc, #68]	; (1afc <_adc_get_regs+0x54>)
    1ab6:	4798      	blx	r3
    1ab8:	4603      	mov	r3, r0
    1aba:	73bb      	strb	r3, [r7, #14]
	uint8_t i;

	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    1abc:	2300      	movs	r3, #0
    1abe:	73fb      	strb	r3, [r7, #15]
    1ac0:	e00e      	b.n	1ae0 <_adc_get_regs+0x38>
		if (_adcs[i].number == n) {
    1ac2:	7bfb      	ldrb	r3, [r7, #15]
    1ac4:	4a0e      	ldr	r2, [pc, #56]	; (1b00 <_adc_get_regs+0x58>)
    1ac6:	2116      	movs	r1, #22
    1ac8:	fb01 f303 	mul.w	r3, r1, r3
    1acc:	4413      	add	r3, r2
    1ace:	781b      	ldrb	r3, [r3, #0]
    1ad0:	7bba      	ldrb	r2, [r7, #14]
    1ad2:	429a      	cmp	r2, r3
    1ad4:	d101      	bne.n	1ada <_adc_get_regs+0x32>
			return i;
    1ad6:	7bfb      	ldrb	r3, [r7, #15]
    1ad8:	e00b      	b.n	1af2 <_adc_get_regs+0x4a>
	for (i = 0; i < sizeof(_adcs) / sizeof(struct adc_configuration); i++) {
    1ada:	7bfb      	ldrb	r3, [r7, #15]
    1adc:	3301      	adds	r3, #1
    1ade:	73fb      	strb	r3, [r7, #15]
    1ae0:	7bfb      	ldrb	r3, [r7, #15]
    1ae2:	2b00      	cmp	r3, #0
    1ae4:	d0ed      	beq.n	1ac2 <_adc_get_regs+0x1a>
		}
	}

	ASSERT(false);
    1ae6:	2288      	movs	r2, #136	; 0x88
    1ae8:	4906      	ldr	r1, [pc, #24]	; (1b04 <_adc_get_regs+0x5c>)
    1aea:	2000      	movs	r0, #0
    1aec:	4b06      	ldr	r3, [pc, #24]	; (1b08 <_adc_get_regs+0x60>)
    1aee:	4798      	blx	r3
	return 0;
    1af0:	2300      	movs	r3, #0
}
    1af2:	4618      	mov	r0, r3
    1af4:	3710      	adds	r7, #16
    1af6:	46bd      	mov	sp, r7
    1af8:	bd80      	pop	{r7, pc}
    1afa:	bf00      	nop
    1afc:	00001a85 	.word	0x00001a85
    1b00:	0000471c 	.word	0x0000471c
    1b04:	00004734 	.word	0x00004734
    1b08:	0000168d 	.word	0x0000168d

00001b0c <_adc_init>:
 *
 * \param[in] hw The pointer to hardware instance
 * \param[in] i The number of hardware instance
 */
static int32_t _adc_init(void *const hw, const uint8_t i)
{
    1b0c:	b580      	push	{r7, lr}
    1b0e:	b082      	sub	sp, #8
    1b10:	af00      	add	r7, sp, #0
    1b12:	6078      	str	r0, [r7, #4]
    1b14:	460b      	mov	r3, r1
    1b16:	70fb      	strb	r3, [r7, #3]

	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
    1b18:	2101      	movs	r1, #1
    1b1a:	6878      	ldr	r0, [r7, #4]
    1b1c:	4b59      	ldr	r3, [pc, #356]	; (1c84 <_adc_init+0x178>)
    1b1e:	4798      	blx	r3
    1b20:	4603      	mov	r3, r0
    1b22:	f083 0301 	eor.w	r3, r3, #1
    1b26:	b2db      	uxtb	r3, r3
    1b28:	2b00      	cmp	r3, #0
    1b2a:	d011      	beq.n	1b50 <_adc_init+0x44>
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
    1b2c:	2102      	movs	r1, #2
    1b2e:	6878      	ldr	r0, [r7, #4]
    1b30:	4b55      	ldr	r3, [pc, #340]	; (1c88 <_adc_init+0x17c>)
    1b32:	4798      	blx	r3
    1b34:	4603      	mov	r3, r0
    1b36:	2b00      	cmp	r3, #0
    1b38:	d006      	beq.n	1b48 <_adc_init+0x3c>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
    1b3a:	6878      	ldr	r0, [r7, #4]
    1b3c:	4b53      	ldr	r3, [pc, #332]	; (1c8c <_adc_init+0x180>)
    1b3e:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
    1b40:	2102      	movs	r1, #2
    1b42:	6878      	ldr	r0, [r7, #4]
    1b44:	4b52      	ldr	r3, [pc, #328]	; (1c90 <_adc_init+0x184>)
    1b46:	4798      	blx	r3
		}
		hri_adc_write_CTRLA_reg(hw, ADC_CTRLA_SWRST);
    1b48:	2101      	movs	r1, #1
    1b4a:	6878      	ldr	r0, [r7, #4]
    1b4c:	4b51      	ldr	r3, [pc, #324]	; (1c94 <_adc_init+0x188>)
    1b4e:	4798      	blx	r3
	}
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
    1b50:	2101      	movs	r1, #1
    1b52:	6878      	ldr	r0, [r7, #4]
    1b54:	4b4e      	ldr	r3, [pc, #312]	; (1c90 <_adc_init+0x184>)
    1b56:	4798      	blx	r3

	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
    1b58:	78fb      	ldrb	r3, [r7, #3]
    1b5a:	4a4f      	ldr	r2, [pc, #316]	; (1c98 <_adc_init+0x18c>)
    1b5c:	2116      	movs	r1, #22
    1b5e:	fb01 f303 	mul.w	r3, r1, r3
    1b62:	4413      	add	r3, r2
    1b64:	3304      	adds	r3, #4
    1b66:	881b      	ldrh	r3, [r3, #0]
    1b68:	4619      	mov	r1, r3
    1b6a:	6878      	ldr	r0, [r7, #4]
    1b6c:	4b4b      	ldr	r3, [pc, #300]	; (1c9c <_adc_init+0x190>)
    1b6e:	4798      	blx	r3
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
    1b70:	78fb      	ldrb	r3, [r7, #3]
    1b72:	4a49      	ldr	r2, [pc, #292]	; (1c98 <_adc_init+0x18c>)
    1b74:	2116      	movs	r1, #22
    1b76:	fb01 f303 	mul.w	r3, r1, r3
    1b7a:	4413      	add	r3, r2
    1b7c:	3306      	adds	r3, #6
    1b7e:	781b      	ldrb	r3, [r3, #0]
    1b80:	4619      	mov	r1, r3
    1b82:	6878      	ldr	r0, [r7, #4]
    1b84:	4b46      	ldr	r3, [pc, #280]	; (1ca0 <_adc_init+0x194>)
    1b86:	4798      	blx	r3
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
    1b88:	78fb      	ldrb	r3, [r7, #3]
    1b8a:	4a43      	ldr	r2, [pc, #268]	; (1c98 <_adc_init+0x18c>)
    1b8c:	2116      	movs	r1, #22
    1b8e:	fb01 f303 	mul.w	r3, r1, r3
    1b92:	4413      	add	r3, r2
    1b94:	3307      	adds	r3, #7
    1b96:	781b      	ldrb	r3, [r3, #0]
    1b98:	4619      	mov	r1, r3
    1b9a:	6878      	ldr	r0, [r7, #4]
    1b9c:	4b41      	ldr	r3, [pc, #260]	; (1ca4 <_adc_init+0x198>)
    1b9e:	4798      	blx	r3
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
    1ba0:	78fb      	ldrb	r3, [r7, #3]
    1ba2:	4a3d      	ldr	r2, [pc, #244]	; (1c98 <_adc_init+0x18c>)
    1ba4:	2116      	movs	r1, #22
    1ba6:	fb01 f303 	mul.w	r3, r1, r3
    1baa:	4413      	add	r3, r2
    1bac:	3308      	adds	r3, #8
    1bae:	881b      	ldrh	r3, [r3, #0]
    1bb0:	4619      	mov	r1, r3
    1bb2:	6878      	ldr	r0, [r7, #4]
    1bb4:	4b3c      	ldr	r3, [pc, #240]	; (1ca8 <_adc_init+0x19c>)
    1bb6:	4798      	blx	r3
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
    1bb8:	78fb      	ldrb	r3, [r7, #3]
    1bba:	4a37      	ldr	r2, [pc, #220]	; (1c98 <_adc_init+0x18c>)
    1bbc:	2116      	movs	r1, #22
    1bbe:	fb01 f303 	mul.w	r3, r1, r3
    1bc2:	4413      	add	r3, r2
    1bc4:	330a      	adds	r3, #10
    1bc6:	781b      	ldrb	r3, [r3, #0]
    1bc8:	4619      	mov	r1, r3
    1bca:	6878      	ldr	r0, [r7, #4]
    1bcc:	4b37      	ldr	r3, [pc, #220]	; (1cac <_adc_init+0x1a0>)
    1bce:	4798      	blx	r3
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
    1bd0:	78fb      	ldrb	r3, [r7, #3]
    1bd2:	4a31      	ldr	r2, [pc, #196]	; (1c98 <_adc_init+0x18c>)
    1bd4:	2116      	movs	r1, #22
    1bd6:	fb01 f303 	mul.w	r3, r1, r3
    1bda:	4413      	add	r3, r2
    1bdc:	330b      	adds	r3, #11
    1bde:	781b      	ldrb	r3, [r3, #0]
    1be0:	4619      	mov	r1, r3
    1be2:	6878      	ldr	r0, [r7, #4]
    1be4:	4b32      	ldr	r3, [pc, #200]	; (1cb0 <_adc_init+0x1a4>)
    1be6:	4798      	blx	r3
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
    1be8:	78fb      	ldrb	r3, [r7, #3]
    1bea:	4a2b      	ldr	r2, [pc, #172]	; (1c98 <_adc_init+0x18c>)
    1bec:	2116      	movs	r1, #22
    1bee:	fb01 f303 	mul.w	r3, r1, r3
    1bf2:	4413      	add	r3, r2
    1bf4:	330c      	adds	r3, #12
    1bf6:	881b      	ldrh	r3, [r3, #0]
    1bf8:	4619      	mov	r1, r3
    1bfa:	6878      	ldr	r0, [r7, #4]
    1bfc:	4b2d      	ldr	r3, [pc, #180]	; (1cb4 <_adc_init+0x1a8>)
    1bfe:	4798      	blx	r3
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
    1c00:	78fb      	ldrb	r3, [r7, #3]
    1c02:	4a25      	ldr	r2, [pc, #148]	; (1c98 <_adc_init+0x18c>)
    1c04:	2116      	movs	r1, #22
    1c06:	fb01 f303 	mul.w	r3, r1, r3
    1c0a:	4413      	add	r3, r2
    1c0c:	330e      	adds	r3, #14
    1c0e:	881b      	ldrh	r3, [r3, #0]
    1c10:	4619      	mov	r1, r3
    1c12:	6878      	ldr	r0, [r7, #4]
    1c14:	4b28      	ldr	r3, [pc, #160]	; (1cb8 <_adc_init+0x1ac>)
    1c16:	4798      	blx	r3
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
    1c18:	78fb      	ldrb	r3, [r7, #3]
    1c1a:	4a1f      	ldr	r2, [pc, #124]	; (1c98 <_adc_init+0x18c>)
    1c1c:	2116      	movs	r1, #22
    1c1e:	fb01 f303 	mul.w	r3, r1, r3
    1c22:	4413      	add	r3, r2
    1c24:	3310      	adds	r3, #16
    1c26:	881b      	ldrh	r3, [r3, #0]
    1c28:	4619      	mov	r1, r3
    1c2a:	6878      	ldr	r0, [r7, #4]
    1c2c:	4b23      	ldr	r3, [pc, #140]	; (1cbc <_adc_init+0x1b0>)
    1c2e:	4798      	blx	r3
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
    1c30:	78fb      	ldrb	r3, [r7, #3]
    1c32:	4a19      	ldr	r2, [pc, #100]	; (1c98 <_adc_init+0x18c>)
    1c34:	2116      	movs	r1, #22
    1c36:	fb01 f303 	mul.w	r3, r1, r3
    1c3a:	4413      	add	r3, r2
    1c3c:	3312      	adds	r3, #18
    1c3e:	881b      	ldrh	r3, [r3, #0]
    1c40:	4619      	mov	r1, r3
    1c42:	6878      	ldr	r0, [r7, #4]
    1c44:	4b1e      	ldr	r3, [pc, #120]	; (1cc0 <_adc_init+0x1b4>)
    1c46:	4798      	blx	r3
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
    1c48:	78fb      	ldrb	r3, [r7, #3]
    1c4a:	4a13      	ldr	r2, [pc, #76]	; (1c98 <_adc_init+0x18c>)
    1c4c:	2116      	movs	r1, #22
    1c4e:	fb01 f303 	mul.w	r3, r1, r3
    1c52:	4413      	add	r3, r2
    1c54:	3314      	adds	r3, #20
    1c56:	781b      	ldrb	r3, [r3, #0]
    1c58:	4619      	mov	r1, r3
    1c5a:	6878      	ldr	r0, [r7, #4]
    1c5c:	4b19      	ldr	r3, [pc, #100]	; (1cc4 <_adc_init+0x1b8>)
    1c5e:	4798      	blx	r3
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
    1c60:	78fb      	ldrb	r3, [r7, #3]
    1c62:	4a0d      	ldr	r2, [pc, #52]	; (1c98 <_adc_init+0x18c>)
    1c64:	2116      	movs	r1, #22
    1c66:	fb01 f303 	mul.w	r3, r1, r3
    1c6a:	4413      	add	r3, r2
    1c6c:	3302      	adds	r3, #2
    1c6e:	881b      	ldrh	r3, [r3, #0]
    1c70:	4619      	mov	r1, r3
    1c72:	6878      	ldr	r0, [r7, #4]
    1c74:	4b07      	ldr	r3, [pc, #28]	; (1c94 <_adc_init+0x188>)
    1c76:	4798      	blx	r3

	return ERR_NONE;
    1c78:	2300      	movs	r3, #0
}
    1c7a:	4618      	mov	r0, r3
    1c7c:	3708      	adds	r7, #8
    1c7e:	46bd      	mov	sp, r7
    1c80:	bd80      	pop	{r7, pc}
    1c82:	bf00      	nop
    1c84:	0000176b 	.word	0x0000176b
    1c88:	00001831 	.word	0x00001831
    1c8c:	00001805 	.word	0x00001805
    1c90:	00001747 	.word	0x00001747
    1c94:	00001861 	.word	0x00001861
    1c98:	0000471c 	.word	0x0000471c
    1c9c:	00001915 	.word	0x00001915
    1ca0:	0000193d 	.word	0x0000193d
    1ca4:	00001889 	.word	0x00001889
    1ca8:	000018c5 	.word	0x000018c5
    1cac:	00001965 	.word	0x00001965
    1cb0:	0000198d 	.word	0x0000198d
    1cb4:	000019b5 	.word	0x000019b5
    1cb8:	000019dd 	.word	0x000019dd
    1cbc:	00001a05 	.word	0x00001a05
    1cc0:	00001a2d 	.word	0x00001a2d
    1cc4:	000018a7 	.word	0x000018a7

00001cc8 <_adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t _adc_sync_init(struct _adc_sync_device *const device, void *const hw)
{
    1cc8:	b580      	push	{r7, lr}
    1cca:	b082      	sub	sp, #8
    1ccc:	af00      	add	r7, sp, #0
    1cce:	6078      	str	r0, [r7, #4]
    1cd0:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    1cd2:	687b      	ldr	r3, [r7, #4]
    1cd4:	2b00      	cmp	r3, #0
    1cd6:	bf14      	ite	ne
    1cd8:	2301      	movne	r3, #1
    1cda:	2300      	moveq	r3, #0
    1cdc:	b2db      	uxtb	r3, r3
    1cde:	22ce      	movs	r2, #206	; 0xce
    1ce0:	490a      	ldr	r1, [pc, #40]	; (1d0c <_adc_sync_init+0x44>)
    1ce2:	4618      	mov	r0, r3
    1ce4:	4b0a      	ldr	r3, [pc, #40]	; (1d10 <_adc_sync_init+0x48>)
    1ce6:	4798      	blx	r3

	device->hw = hw;
    1ce8:	687b      	ldr	r3, [r7, #4]
    1cea:	683a      	ldr	r2, [r7, #0]
    1cec:	601a      	str	r2, [r3, #0]

	return _adc_init(hw, _adc_get_regs((uint32_t)hw));
    1cee:	683b      	ldr	r3, [r7, #0]
    1cf0:	4618      	mov	r0, r3
    1cf2:	4b08      	ldr	r3, [pc, #32]	; (1d14 <_adc_sync_init+0x4c>)
    1cf4:	4798      	blx	r3
    1cf6:	4603      	mov	r3, r0
    1cf8:	4619      	mov	r1, r3
    1cfa:	6838      	ldr	r0, [r7, #0]
    1cfc:	4b06      	ldr	r3, [pc, #24]	; (1d18 <_adc_sync_init+0x50>)
    1cfe:	4798      	blx	r3
    1d00:	4603      	mov	r3, r0
}
    1d02:	4618      	mov	r0, r3
    1d04:	3708      	adds	r7, #8
    1d06:	46bd      	mov	sp, r7
    1d08:	bd80      	pop	{r7, pc}
    1d0a:	bf00      	nop
    1d0c:	00004734 	.word	0x00004734
    1d10:	0000168d 	.word	0x0000168d
    1d14:	00001aa9 	.word	0x00001aa9
    1d18:	00001b0d 	.word	0x00001b0d

00001d1c <_adc_sync_enable_channel>:

/**
 * \brief Enable ADC
 */
void _adc_sync_enable_channel(struct _adc_sync_device *const device, const uint8_t channel)
{
    1d1c:	b580      	push	{r7, lr}
    1d1e:	b082      	sub	sp, #8
    1d20:	af00      	add	r7, sp, #0
    1d22:	6078      	str	r0, [r7, #4]
    1d24:	460b      	mov	r3, r1
    1d26:	70fb      	strb	r3, [r7, #3]
	(void)channel;

	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
    1d28:	687b      	ldr	r3, [r7, #4]
    1d2a:	681b      	ldr	r3, [r3, #0]
    1d2c:	4618      	mov	r0, r3
    1d2e:	4b03      	ldr	r3, [pc, #12]	; (1d3c <_adc_sync_enable_channel+0x20>)
    1d30:	4798      	blx	r3
}
    1d32:	bf00      	nop
    1d34:	3708      	adds	r7, #8
    1d36:	46bd      	mov	sp, r7
    1d38:	bd80      	pop	{r7, pc}
    1d3a:	bf00      	nop
    1d3c:	000017d9 	.word	0x000017d9

00001d40 <_adc_sync_get_data_size>:

/**
 * \brief Retrieve ADC conversion data size
 */
uint8_t _adc_sync_get_data_size(const struct _adc_sync_device *const device)
{
    1d40:	b580      	push	{r7, lr}
    1d42:	b082      	sub	sp, #8
    1d44:	af00      	add	r7, sp, #0
    1d46:	6078      	str	r0, [r7, #4]
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
    1d48:	687b      	ldr	r3, [r7, #4]
    1d4a:	681b      	ldr	r3, [r3, #0]
    1d4c:	4618      	mov	r0, r3
    1d4e:	4b06      	ldr	r3, [pc, #24]	; (1d68 <_adc_sync_get_data_size+0x28>)
    1d50:	4798      	blx	r3
    1d52:	4603      	mov	r3, r0
    1d54:	2b03      	cmp	r3, #3
    1d56:	d101      	bne.n	1d5c <_adc_sync_get_data_size+0x1c>
    1d58:	2301      	movs	r3, #1
    1d5a:	e000      	b.n	1d5e <_adc_sync_get_data_size+0x1e>
    1d5c:	2302      	movs	r3, #2
}
    1d5e:	4618      	mov	r0, r3
    1d60:	3708      	adds	r7, #8
    1d62:	46bd      	mov	sp, r7
    1d64:	bd80      	pop	{r7, pc}
    1d66:	bf00      	nop
    1d68:	000018ed 	.word	0x000018ed

00001d6c <_adc_sync_is_channel_conversion_done>:

/**
 * \brief Check if conversion is done
 */
bool _adc_sync_is_channel_conversion_done(const struct _adc_sync_device *const device, const uint8_t channel)
{
    1d6c:	b580      	push	{r7, lr}
    1d6e:	b082      	sub	sp, #8
    1d70:	af00      	add	r7, sp, #0
    1d72:	6078      	str	r0, [r7, #4]
    1d74:	460b      	mov	r3, r1
    1d76:	70fb      	strb	r3, [r7, #3]
	(void)channel;

	return hri_adc_get_interrupt_RESRDY_bit(device->hw);
    1d78:	687b      	ldr	r3, [r7, #4]
    1d7a:	681b      	ldr	r3, [r3, #0]
    1d7c:	4618      	mov	r0, r3
    1d7e:	4b03      	ldr	r3, [pc, #12]	; (1d8c <_adc_sync_is_channel_conversion_done+0x20>)
    1d80:	4798      	blx	r3
    1d82:	4603      	mov	r3, r0
}
    1d84:	4618      	mov	r0, r3
    1d86:	3708      	adds	r7, #8
    1d88:	46bd      	mov	sp, r7
    1d8a:	bd80      	pop	{r7, pc}
    1d8c:	00001793 	.word	0x00001793

00001d90 <_adc_sync_convert>:

/**
 * \brief Make conversion
 */
void _adc_sync_convert(struct _adc_sync_device *const device)
{
    1d90:	b580      	push	{r7, lr}
    1d92:	b082      	sub	sp, #8
    1d94:	af00      	add	r7, sp, #0
    1d96:	6078      	str	r0, [r7, #4]
	hri_adc_set_SWTRIG_START_bit(device->hw);
    1d98:	687b      	ldr	r3, [r7, #4]
    1d9a:	681b      	ldr	r3, [r3, #0]
    1d9c:	4618      	mov	r0, r3
    1d9e:	4b03      	ldr	r3, [pc, #12]	; (1dac <_adc_sync_convert+0x1c>)
    1da0:	4798      	blx	r3
}
    1da2:	bf00      	nop
    1da4:	3708      	adds	r7, #8
    1da6:	46bd      	mov	sp, r7
    1da8:	bd80      	pop	{r7, pc}
    1daa:	bf00      	nop
    1dac:	00001a55 	.word	0x00001a55

00001db0 <_adc_sync_read_channel_data>:

/**
 * \brief Retrieve the conversion result
 */
uint16_t _adc_sync_read_channel_data(const struct _adc_sync_device *const device, const uint8_t channel)
{
    1db0:	b580      	push	{r7, lr}
    1db2:	b082      	sub	sp, #8
    1db4:	af00      	add	r7, sp, #0
    1db6:	6078      	str	r0, [r7, #4]
    1db8:	460b      	mov	r3, r1
    1dba:	70fb      	strb	r3, [r7, #3]
	(void)channel;

	return hri_adc_read_RESULT_reg(device->hw);
    1dbc:	687b      	ldr	r3, [r7, #4]
    1dbe:	681b      	ldr	r3, [r3, #0]
    1dc0:	4618      	mov	r0, r3
    1dc2:	4b03      	ldr	r3, [pc, #12]	; (1dd0 <_adc_sync_read_channel_data+0x20>)
    1dc4:	4798      	blx	r3
    1dc6:	4603      	mov	r3, r0
}
    1dc8:	4618      	mov	r0, r3
    1dca:	3708      	adds	r7, #8
    1dcc:	46bd      	mov	sp, r7
    1dce:	bd80      	pop	{r7, pc}
    1dd0:	000017bd 	.word	0x000017bd

00001dd4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
    1dd4:	b480      	push	{r7}
    1dd6:	b083      	sub	sp, #12
    1dd8:	af00      	add	r7, sp, #0
    1dda:	4603      	mov	r3, r0
    1ddc:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    1dde:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1de2:	2b00      	cmp	r3, #0
    1de4:	db0b      	blt.n	1dfe <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1de6:	4909      	ldr	r1, [pc, #36]	; (1e0c <__NVIC_EnableIRQ+0x38>)
    1de8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1dec:	095b      	lsrs	r3, r3, #5
    1dee:	88fa      	ldrh	r2, [r7, #6]
    1df0:	f002 021f 	and.w	r2, r2, #31
    1df4:	2001      	movs	r0, #1
    1df6:	fa00 f202 	lsl.w	r2, r0, r2
    1dfa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    1dfe:	bf00      	nop
    1e00:	370c      	adds	r7, #12
    1e02:	46bd      	mov	sp, r7
    1e04:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e08:	4770      	bx	lr
    1e0a:	bf00      	nop
    1e0c:	e000e100 	.word	0xe000e100

00001e10 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
    1e10:	b480      	push	{r7}
    1e12:	b083      	sub	sp, #12
    1e14:	af00      	add	r7, sp, #0
    1e16:	4603      	mov	r3, r0
    1e18:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    1e1a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1e1e:	2b00      	cmp	r3, #0
    1e20:	db10      	blt.n	1e44 <__NVIC_DisableIRQ+0x34>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1e22:	490b      	ldr	r1, [pc, #44]	; (1e50 <__NVIC_DisableIRQ+0x40>)
    1e24:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1e28:	095b      	lsrs	r3, r3, #5
    1e2a:	88fa      	ldrh	r2, [r7, #6]
    1e2c:	f002 021f 	and.w	r2, r2, #31
    1e30:	2001      	movs	r0, #1
    1e32:	fa00 f202 	lsl.w	r2, r0, r2
    1e36:	3320      	adds	r3, #32
    1e38:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    1e3c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1e40:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
    1e44:	bf00      	nop
    1e46:	370c      	adds	r7, #12
    1e48:	46bd      	mov	sp, r7
    1e4a:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e4e:	4770      	bx	lr
    1e50:	e000e100 	.word	0xe000e100

00001e54 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
    1e54:	b480      	push	{r7}
    1e56:	b083      	sub	sp, #12
    1e58:	af00      	add	r7, sp, #0
    1e5a:	4603      	mov	r3, r0
    1e5c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    1e5e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1e62:	2b00      	cmp	r3, #0
    1e64:	db0c      	blt.n	1e80 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1e66:	4909      	ldr	r1, [pc, #36]	; (1e8c <__NVIC_ClearPendingIRQ+0x38>)
    1e68:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    1e6c:	095b      	lsrs	r3, r3, #5
    1e6e:	88fa      	ldrh	r2, [r7, #6]
    1e70:	f002 021f 	and.w	r2, r2, #31
    1e74:	2001      	movs	r0, #1
    1e76:	fa00 f202 	lsl.w	r2, r0, r2
    1e7a:	3360      	adds	r3, #96	; 0x60
    1e7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
    1e80:	bf00      	nop
    1e82:	370c      	adds	r7, #12
    1e84:	46bd      	mov	sp, r7
    1e86:	f85d 7b04 	ldr.w	r7, [sp], #4
    1e8a:	4770      	bx	lr
    1e8c:	e000e100 	.word	0xe000e100

00001e90 <hri_can_get_PSR_EP_bit>:
{
	return ((Can *)hw)->ECR.reg;
}

static inline bool hri_can_get_PSR_EP_bit(const void *const hw)
{
    1e90:	b480      	push	{r7}
    1e92:	b083      	sub	sp, #12
    1e94:	af00      	add	r7, sp, #0
    1e96:	6078      	str	r0, [r7, #4]
	return (((Can *)hw)->PSR.reg & CAN_PSR_EP) >> CAN_PSR_EP_Pos;
    1e98:	687b      	ldr	r3, [r7, #4]
    1e9a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    1e9c:	095b      	lsrs	r3, r3, #5
    1e9e:	f003 0301 	and.w	r3, r3, #1
    1ea2:	2b00      	cmp	r3, #0
    1ea4:	bf14      	ite	ne
    1ea6:	2301      	movne	r3, #1
    1ea8:	2300      	moveq	r3, #0
    1eaa:	b2db      	uxtb	r3, r3
}
    1eac:	4618      	mov	r0, r3
    1eae:	370c      	adds	r7, #12
    1eb0:	46bd      	mov	sp, r7
    1eb2:	f85d 7b04 	ldr.w	r7, [sp], #4
    1eb6:	4770      	bx	lr

00001eb8 <hri_can_write_MRCFG_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_MRCFG_reg(const void *const hw, hri_can_mrcfg_reg_t data)
{
    1eb8:	b480      	push	{r7}
    1eba:	b083      	sub	sp, #12
    1ebc:	af00      	add	r7, sp, #0
    1ebe:	6078      	str	r0, [r7, #4]
    1ec0:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->MRCFG.reg = data;
    1ec2:	687b      	ldr	r3, [r7, #4]
    1ec4:	683a      	ldr	r2, [r7, #0]
    1ec6:	609a      	str	r2, [r3, #8]
	CAN_CRITICAL_SECTION_LEAVE();
}
    1ec8:	bf00      	nop
    1eca:	370c      	adds	r7, #12
    1ecc:	46bd      	mov	sp, r7
    1ece:	f85d 7b04 	ldr.w	r7, [sp], #4
    1ed2:	4770      	bx	lr

00001ed4 <hri_can_write_DBTP_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_DBTP_reg(const void *const hw, hri_can_dbtp_reg_t data)
{
    1ed4:	b480      	push	{r7}
    1ed6:	b083      	sub	sp, #12
    1ed8:	af00      	add	r7, sp, #0
    1eda:	6078      	str	r0, [r7, #4]
    1edc:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->DBTP.reg = data;
    1ede:	687b      	ldr	r3, [r7, #4]
    1ee0:	683a      	ldr	r2, [r7, #0]
    1ee2:	60da      	str	r2, [r3, #12]
	CAN_CRITICAL_SECTION_LEAVE();
}
    1ee4:	bf00      	nop
    1ee6:	370c      	adds	r7, #12
    1ee8:	46bd      	mov	sp, r7
    1eea:	f85d 7b04 	ldr.w	r7, [sp], #4
    1eee:	4770      	bx	lr

00001ef0 <hri_can_set_CCCR_INIT_bit>:
{
	return ((Can *)hw)->RWD.reg;
}

static inline void hri_can_set_CCCR_INIT_bit(const void *const hw)
{
    1ef0:	b480      	push	{r7}
    1ef2:	b083      	sub	sp, #12
    1ef4:	af00      	add	r7, sp, #0
    1ef6:	6078      	str	r0, [r7, #4]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= CAN_CCCR_INIT;
    1ef8:	687b      	ldr	r3, [r7, #4]
    1efa:	699b      	ldr	r3, [r3, #24]
    1efc:	f043 0201 	orr.w	r2, r3, #1
    1f00:	687b      	ldr	r3, [r7, #4]
    1f02:	619a      	str	r2, [r3, #24]
	CAN_CRITICAL_SECTION_LEAVE();
}
    1f04:	bf00      	nop
    1f06:	370c      	adds	r7, #12
    1f08:	46bd      	mov	sp, r7
    1f0a:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f0e:	4770      	bx	lr

00001f10 <hri_can_get_CCCR_INIT_bit>:

static inline bool hri_can_get_CCCR_INIT_bit(const void *const hw)
{
    1f10:	b480      	push	{r7}
    1f12:	b085      	sub	sp, #20
    1f14:	af00      	add	r7, sp, #0
    1f16:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Can *)hw)->CCCR.reg;
    1f18:	687b      	ldr	r3, [r7, #4]
    1f1a:	699b      	ldr	r3, [r3, #24]
    1f1c:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & CAN_CCCR_INIT) >> CAN_CCCR_INIT_Pos;
    1f1e:	68fb      	ldr	r3, [r7, #12]
    1f20:	f003 0301 	and.w	r3, r3, #1
    1f24:	60fb      	str	r3, [r7, #12]
	return (bool)tmp;
    1f26:	68fb      	ldr	r3, [r7, #12]
    1f28:	2b00      	cmp	r3, #0
    1f2a:	bf14      	ite	ne
    1f2c:	2301      	movne	r3, #1
    1f2e:	2300      	moveq	r3, #0
    1f30:	b2db      	uxtb	r3, r3
}
    1f32:	4618      	mov	r0, r3
    1f34:	3714      	adds	r7, #20
    1f36:	46bd      	mov	sp, r7
    1f38:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f3c:	4770      	bx	lr

00001f3e <hri_can_clear_CCCR_INIT_bit>:
	((Can *)hw)->CCCR.reg = tmp;
	CAN_CRITICAL_SECTION_LEAVE();
}

static inline void hri_can_clear_CCCR_INIT_bit(const void *const hw)
{
    1f3e:	b480      	push	{r7}
    1f40:	b083      	sub	sp, #12
    1f42:	af00      	add	r7, sp, #0
    1f44:	6078      	str	r0, [r7, #4]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_INIT;
    1f46:	687b      	ldr	r3, [r7, #4]
    1f48:	699b      	ldr	r3, [r3, #24]
    1f4a:	f023 0201 	bic.w	r2, r3, #1
    1f4e:	687b      	ldr	r3, [r7, #4]
    1f50:	619a      	str	r2, [r3, #24]
	CAN_CRITICAL_SECTION_LEAVE();
}
    1f52:	bf00      	nop
    1f54:	370c      	adds	r7, #12
    1f56:	46bd      	mov	sp, r7
    1f58:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f5c:	4770      	bx	lr

00001f5e <hri_can_set_CCCR_CCE_bit>:
	((Can *)hw)->CCCR.reg ^= CAN_CCCR_INIT;
	CAN_CRITICAL_SECTION_LEAVE();
}

static inline void hri_can_set_CCCR_CCE_bit(const void *const hw)
{
    1f5e:	b480      	push	{r7}
    1f60:	b083      	sub	sp, #12
    1f62:	af00      	add	r7, sp, #0
    1f64:	6078      	str	r0, [r7, #4]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= CAN_CCCR_CCE;
    1f66:	687b      	ldr	r3, [r7, #4]
    1f68:	699b      	ldr	r3, [r3, #24]
    1f6a:	f043 0202 	orr.w	r2, r3, #2
    1f6e:	687b      	ldr	r3, [r7, #4]
    1f70:	619a      	str	r2, [r3, #24]
	CAN_CRITICAL_SECTION_LEAVE();
}
    1f72:	bf00      	nop
    1f74:	370c      	adds	r7, #12
    1f76:	46bd      	mov	sp, r7
    1f78:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f7c:	4770      	bx	lr

00001f7e <hri_can_clear_CCCR_CCE_bit>:
	((Can *)hw)->CCCR.reg = tmp;
	CAN_CRITICAL_SECTION_LEAVE();
}

static inline void hri_can_clear_CCCR_CCE_bit(const void *const hw)
{
    1f7e:	b480      	push	{r7}
    1f80:	b083      	sub	sp, #12
    1f82:	af00      	add	r7, sp, #0
    1f84:	6078      	str	r0, [r7, #4]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg &= ~CAN_CCCR_CCE;
    1f86:	687b      	ldr	r3, [r7, #4]
    1f88:	699b      	ldr	r3, [r3, #24]
    1f8a:	f023 0202 	bic.w	r2, r3, #2
    1f8e:	687b      	ldr	r3, [r7, #4]
    1f90:	619a      	str	r2, [r3, #24]
	CAN_CRITICAL_SECTION_LEAVE();
}
    1f92:	bf00      	nop
    1f94:	370c      	adds	r7, #12
    1f96:	46bd      	mov	sp, r7
    1f98:	f85d 7b04 	ldr.w	r7, [sp], #4
    1f9c:	4770      	bx	lr

00001f9e <hri_can_set_CCCR_reg>:
	((Can *)hw)->CCCR.reg ^= CAN_CCCR_NISO;
	CAN_CRITICAL_SECTION_LEAVE();
}

static inline void hri_can_set_CCCR_reg(const void *const hw, hri_can_cccr_reg_t mask)
{
    1f9e:	b480      	push	{r7}
    1fa0:	b083      	sub	sp, #12
    1fa2:	af00      	add	r7, sp, #0
    1fa4:	6078      	str	r0, [r7, #4]
    1fa6:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->CCCR.reg |= mask;
    1fa8:	687b      	ldr	r3, [r7, #4]
    1faa:	699a      	ldr	r2, [r3, #24]
    1fac:	683b      	ldr	r3, [r7, #0]
    1fae:	431a      	orrs	r2, r3
    1fb0:	687b      	ldr	r3, [r7, #4]
    1fb2:	619a      	str	r2, [r3, #24]
	CAN_CRITICAL_SECTION_LEAVE();
}
    1fb4:	bf00      	nop
    1fb6:	370c      	adds	r7, #12
    1fb8:	46bd      	mov	sp, r7
    1fba:	f85d 7b04 	ldr.w	r7, [sp], #4
    1fbe:	4770      	bx	lr

00001fc0 <hri_can_write_NBTP_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_NBTP_reg(const void *const hw, hri_can_nbtp_reg_t data)
{
    1fc0:	b480      	push	{r7}
    1fc2:	b083      	sub	sp, #12
    1fc4:	af00      	add	r7, sp, #0
    1fc6:	6078      	str	r0, [r7, #4]
    1fc8:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->NBTP.reg = data;
    1fca:	687b      	ldr	r3, [r7, #4]
    1fcc:	683a      	ldr	r2, [r7, #0]
    1fce:	61da      	str	r2, [r3, #28]
	CAN_CRITICAL_SECTION_LEAVE();
}
    1fd0:	bf00      	nop
    1fd2:	370c      	adds	r7, #12
    1fd4:	46bd      	mov	sp, r7
    1fd6:	f85d 7b04 	ldr.w	r7, [sp], #4
    1fda:	4770      	bx	lr

00001fdc <hri_can_write_IR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_IR_reg(const void *const hw, hri_can_ir_reg_t data)
{
    1fdc:	b480      	push	{r7}
    1fde:	b083      	sub	sp, #12
    1fe0:	af00      	add	r7, sp, #0
    1fe2:	6078      	str	r0, [r7, #4]
    1fe4:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->IR.reg = data;
    1fe6:	687b      	ldr	r3, [r7, #4]
    1fe8:	683a      	ldr	r2, [r7, #0]
    1fea:	651a      	str	r2, [r3, #80]	; 0x50
	CAN_CRITICAL_SECTION_LEAVE();
}
    1fec:	bf00      	nop
    1fee:	370c      	adds	r7, #12
    1ff0:	46bd      	mov	sp, r7
    1ff2:	f85d 7b04 	ldr.w	r7, [sp], #4
    1ff6:	4770      	bx	lr

00001ff8 <hri_can_read_IR_reg>:
	((Can *)hw)->IR.reg ^= mask;
	CAN_CRITICAL_SECTION_LEAVE();
}

static inline hri_can_ir_reg_t hri_can_read_IR_reg(const void *const hw)
{
    1ff8:	b480      	push	{r7}
    1ffa:	b083      	sub	sp, #12
    1ffc:	af00      	add	r7, sp, #0
    1ffe:	6078      	str	r0, [r7, #4]
	return ((Can *)hw)->IR.reg;
    2000:	687b      	ldr	r3, [r7, #4]
    2002:	6d1b      	ldr	r3, [r3, #80]	; 0x50
}
    2004:	4618      	mov	r0, r3
    2006:	370c      	adds	r7, #12
    2008:	46bd      	mov	sp, r7
    200a:	f85d 7b04 	ldr.w	r7, [sp], #4
    200e:	4770      	bx	lr

00002010 <hri_can_write_ILE_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_ILE_reg(const void *const hw, hri_can_ile_reg_t data)
{
    2010:	b480      	push	{r7}
    2012:	b083      	sub	sp, #12
    2014:	af00      	add	r7, sp, #0
    2016:	6078      	str	r0, [r7, #4]
    2018:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->ILE.reg = data;
    201a:	687b      	ldr	r3, [r7, #4]
    201c:	683a      	ldr	r2, [r7, #0]
    201e:	65da      	str	r2, [r3, #92]	; 0x5c
	CAN_CRITICAL_SECTION_LEAVE();
}
    2020:	bf00      	nop
    2022:	370c      	adds	r7, #12
    2024:	46bd      	mov	sp, r7
    2026:	f85d 7b04 	ldr.w	r7, [sp], #4
    202a:	4770      	bx	lr

0000202c <hri_can_write_GFC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_GFC_reg(const void *const hw, hri_can_gfc_reg_t data)
{
    202c:	b480      	push	{r7}
    202e:	b083      	sub	sp, #12
    2030:	af00      	add	r7, sp, #0
    2032:	6078      	str	r0, [r7, #4]
    2034:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->GFC.reg = data;
    2036:	687b      	ldr	r3, [r7, #4]
    2038:	683a      	ldr	r2, [r7, #0]
    203a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	CAN_CRITICAL_SECTION_LEAVE();
}
    203e:	bf00      	nop
    2040:	370c      	adds	r7, #12
    2042:	46bd      	mov	sp, r7
    2044:	f85d 7b04 	ldr.w	r7, [sp], #4
    2048:	4770      	bx	lr

0000204a <hri_can_write_SIDFC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_SIDFC_reg(const void *const hw, hri_can_sidfc_reg_t data)
{
    204a:	b480      	push	{r7}
    204c:	b083      	sub	sp, #12
    204e:	af00      	add	r7, sp, #0
    2050:	6078      	str	r0, [r7, #4]
    2052:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->SIDFC.reg = data;
    2054:	687b      	ldr	r3, [r7, #4]
    2056:	683a      	ldr	r2, [r7, #0]
    2058:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	CAN_CRITICAL_SECTION_LEAVE();
}
    205c:	bf00      	nop
    205e:	370c      	adds	r7, #12
    2060:	46bd      	mov	sp, r7
    2062:	f85d 7b04 	ldr.w	r7, [sp], #4
    2066:	4770      	bx	lr

00002068 <hri_can_write_XIDFC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_XIDFC_reg(const void *const hw, hri_can_xidfc_reg_t data)
{
    2068:	b480      	push	{r7}
    206a:	b083      	sub	sp, #12
    206c:	af00      	add	r7, sp, #0
    206e:	6078      	str	r0, [r7, #4]
    2070:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->XIDFC.reg = data;
    2072:	687b      	ldr	r3, [r7, #4]
    2074:	683a      	ldr	r2, [r7, #0]
    2076:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	CAN_CRITICAL_SECTION_LEAVE();
}
    207a:	bf00      	nop
    207c:	370c      	adds	r7, #12
    207e:	46bd      	mov	sp, r7
    2080:	f85d 7b04 	ldr.w	r7, [sp], #4
    2084:	4770      	bx	lr

00002086 <hri_can_write_XIDAM_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_XIDAM_reg(const void *const hw, hri_can_xidam_reg_t data)
{
    2086:	b480      	push	{r7}
    2088:	b083      	sub	sp, #12
    208a:	af00      	add	r7, sp, #0
    208c:	6078      	str	r0, [r7, #4]
    208e:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->XIDAM.reg = data;
    2090:	687b      	ldr	r3, [r7, #4]
    2092:	683a      	ldr	r2, [r7, #0]
    2094:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	CAN_CRITICAL_SECTION_LEAVE();
}
    2098:	bf00      	nop
    209a:	370c      	adds	r7, #12
    209c:	46bd      	mov	sp, r7
    209e:	f85d 7b04 	ldr.w	r7, [sp], #4
    20a2:	4770      	bx	lr

000020a4 <hri_can_write_RXF0C_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_RXF0C_reg(const void *const hw, hri_can_rxf0c_reg_t data)
{
    20a4:	b480      	push	{r7}
    20a6:	b083      	sub	sp, #12
    20a8:	af00      	add	r7, sp, #0
    20aa:	6078      	str	r0, [r7, #4]
    20ac:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->RXF0C.reg = data;
    20ae:	687b      	ldr	r3, [r7, #4]
    20b0:	683a      	ldr	r2, [r7, #0]
    20b2:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	CAN_CRITICAL_SECTION_LEAVE();
}
    20b6:	bf00      	nop
    20b8:	370c      	adds	r7, #12
    20ba:	46bd      	mov	sp, r7
    20bc:	f85d 7b04 	ldr.w	r7, [sp], #4
    20c0:	4770      	bx	lr

000020c2 <hri_can_write_RXESC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_RXESC_reg(const void *const hw, hri_can_rxesc_reg_t data)
{
    20c2:	b480      	push	{r7}
    20c4:	b083      	sub	sp, #12
    20c6:	af00      	add	r7, sp, #0
    20c8:	6078      	str	r0, [r7, #4]
    20ca:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->RXESC.reg = data;
    20cc:	687b      	ldr	r3, [r7, #4]
    20ce:	683a      	ldr	r2, [r7, #0]
    20d0:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
	CAN_CRITICAL_SECTION_LEAVE();
}
    20d4:	bf00      	nop
    20d6:	370c      	adds	r7, #12
    20d8:	46bd      	mov	sp, r7
    20da:	f85d 7b04 	ldr.w	r7, [sp], #4
    20de:	4770      	bx	lr

000020e0 <hri_can_write_TXBC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_TXBC_reg(const void *const hw, hri_can_txbc_reg_t data)
{
    20e0:	b480      	push	{r7}
    20e2:	b083      	sub	sp, #12
    20e4:	af00      	add	r7, sp, #0
    20e6:	6078      	str	r0, [r7, #4]
    20e8:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXBC.reg = data;
    20ea:	687b      	ldr	r3, [r7, #4]
    20ec:	683a      	ldr	r2, [r7, #0]
    20ee:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	CAN_CRITICAL_SECTION_LEAVE();
}
    20f2:	bf00      	nop
    20f4:	370c      	adds	r7, #12
    20f6:	46bd      	mov	sp, r7
    20f8:	f85d 7b04 	ldr.w	r7, [sp], #4
    20fc:	4770      	bx	lr

000020fe <hri_can_write_TXESC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_TXESC_reg(const void *const hw, hri_can_txesc_reg_t data)
{
    20fe:	b480      	push	{r7}
    2100:	b083      	sub	sp, #12
    2102:	af00      	add	r7, sp, #0
    2104:	6078      	str	r0, [r7, #4]
    2106:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXESC.reg = data;
    2108:	687b      	ldr	r3, [r7, #4]
    210a:	683a      	ldr	r2, [r7, #0]
    210c:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
	CAN_CRITICAL_SECTION_LEAVE();
}
    2110:	bf00      	nop
    2112:	370c      	adds	r7, #12
    2114:	46bd      	mov	sp, r7
    2116:	f85d 7b04 	ldr.w	r7, [sp], #4
    211a:	4770      	bx	lr

0000211c <hri_can_write_TXEFC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_can_write_TXEFC_reg(const void *const hw, hri_can_txefc_reg_t data)
{
    211c:	b480      	push	{r7}
    211e:	b083      	sub	sp, #12
    2120:	af00      	add	r7, sp, #0
    2122:	6078      	str	r0, [r7, #4]
    2124:	6039      	str	r1, [r7, #0]
	CAN_CRITICAL_SECTION_ENTER();
	((Can *)hw)->TXEFC.reg = data;
    2126:	687b      	ldr	r3, [r7, #4]
    2128:	683a      	ldr	r2, [r7, #0]
    212a:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
	CAN_CRITICAL_SECTION_LEAVE();
}
    212e:	bf00      	nop
    2130:	370c      	adds	r7, #12
    2132:	46bd      	mov	sp, r7
    2134:	f85d 7b04 	ldr.w	r7, [sp], #4
    2138:	4770      	bx	lr
	...

0000213c <_can_async_init>:

/**
 * \brief Initialize CAN.
 */
int32_t _can_async_init(struct _can_async_device *const dev, void *const hw)
{
    213c:	b580      	push	{r7, lr}
    213e:	b082      	sub	sp, #8
    2140:	af00      	add	r7, sp, #0
    2142:	6078      	str	r0, [r7, #4]
    2144:	6039      	str	r1, [r7, #0]
	dev->hw = hw;
    2146:	687b      	ldr	r3, [r7, #4]
    2148:	683a      	ldr	r2, [r7, #0]
    214a:	601a      	str	r2, [r3, #0]
	hri_can_set_CCCR_INIT_bit(dev->hw);
    214c:	687b      	ldr	r3, [r7, #4]
    214e:	681b      	ldr	r3, [r3, #0]
    2150:	4618      	mov	r0, r3
    2152:	4b53      	ldr	r3, [pc, #332]	; (22a0 <_can_async_init+0x164>)
    2154:	4798      	blx	r3
	while (hri_can_get_CCCR_INIT_bit(dev->hw) == 0)
    2156:	bf00      	nop
    2158:	687b      	ldr	r3, [r7, #4]
    215a:	681b      	ldr	r3, [r3, #0]
    215c:	4618      	mov	r0, r3
    215e:	4b51      	ldr	r3, [pc, #324]	; (22a4 <_can_async_init+0x168>)
    2160:	4798      	blx	r3
    2162:	4603      	mov	r3, r0
    2164:	f083 0301 	eor.w	r3, r3, #1
    2168:	b2db      	uxtb	r3, r3
    216a:	2b00      	cmp	r3, #0
    216c:	d1f4      	bne.n	2158 <_can_async_init+0x1c>
		;
	hri_can_set_CCCR_CCE_bit(dev->hw);
    216e:	687b      	ldr	r3, [r7, #4]
    2170:	681b      	ldr	r3, [r3, #0]
    2172:	4618      	mov	r0, r3
    2174:	4b4c      	ldr	r3, [pc, #304]	; (22a8 <_can_async_init+0x16c>)
    2176:	4798      	blx	r3
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
	}
#endif

#ifdef CONF_CAN1_ENABLED
	if (hw == CAN1) {
    2178:	683b      	ldr	r3, [r7, #0]
    217a:	4a4c      	ldr	r2, [pc, #304]	; (22ac <_can_async_init+0x170>)
    217c:	4293      	cmp	r3, r2
    217e:	d177      	bne.n	2270 <_can_async_init+0x134>
		_can1_dev    = dev;
    2180:	4a4b      	ldr	r2, [pc, #300]	; (22b0 <_can_async_init+0x174>)
    2182:	687b      	ldr	r3, [r7, #4]
    2184:	6013      	str	r3, [r2, #0]
		dev->context = (void *)&_can1_context;
    2186:	687b      	ldr	r3, [r7, #4]
    2188:	4a4a      	ldr	r2, [pc, #296]	; (22b4 <_can_async_init+0x178>)
    218a:	619a      	str	r2, [r3, #24]
		hri_can_set_CCCR_reg(dev->hw, CONF_CAN1_CCCR_REG);
    218c:	687b      	ldr	r3, [r7, #4]
    218e:	681b      	ldr	r3, [r3, #0]
    2190:	2100      	movs	r1, #0
    2192:	4618      	mov	r0, r3
    2194:	4b48      	ldr	r3, [pc, #288]	; (22b8 <_can_async_init+0x17c>)
    2196:	4798      	blx	r3
		hri_can_write_MRCFG_reg(dev->hw, CONF_CAN1_MRCFG_REG);
    2198:	687b      	ldr	r3, [r7, #4]
    219a:	681b      	ldr	r3, [r3, #0]
    219c:	2100      	movs	r1, #0
    219e:	4618      	mov	r0, r3
    21a0:	4b46      	ldr	r3, [pc, #280]	; (22bc <_can_async_init+0x180>)
    21a2:	4798      	blx	r3
		hri_can_write_NBTP_reg(dev->hw, CONF_CAN1_BTP_REG);
    21a4:	687b      	ldr	r3, [r7, #4]
    21a6:	681b      	ldr	r3, [r3, #0]
    21a8:	4945      	ldr	r1, [pc, #276]	; (22c0 <_can_async_init+0x184>)
    21aa:	4618      	mov	r0, r3
    21ac:	4b45      	ldr	r3, [pc, #276]	; (22c4 <_can_async_init+0x188>)
    21ae:	4798      	blx	r3
		hri_can_write_DBTP_reg(dev->hw, CONF_CAN1_DBTP_REG);
    21b0:	687b      	ldr	r3, [r7, #4]
    21b2:	681b      	ldr	r3, [r3, #0]
    21b4:	f640 2133 	movw	r1, #2611	; 0xa33
    21b8:	4618      	mov	r0, r3
    21ba:	4b43      	ldr	r3, [pc, #268]	; (22c8 <_can_async_init+0x18c>)
    21bc:	4798      	blx	r3
		hri_can_write_RXF0C_reg(dev->hw, CONF_CAN1_RXF0C_REG | CAN_RXF0C_F0SA((uint32_t)can1_rx_fifo));
    21be:	687b      	ldr	r3, [r7, #4]
    21c0:	681a      	ldr	r2, [r3, #0]
    21c2:	4b42      	ldr	r3, [pc, #264]	; (22cc <_can_async_init+0x190>)
    21c4:	b29b      	uxth	r3, r3
    21c6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    21ca:	4619      	mov	r1, r3
    21cc:	4610      	mov	r0, r2
    21ce:	4b40      	ldr	r3, [pc, #256]	; (22d0 <_can_async_init+0x194>)
    21d0:	4798      	blx	r3
		hri_can_write_RXESC_reg(dev->hw, CONF_CAN1_RXESC_REG);
    21d2:	687b      	ldr	r3, [r7, #4]
    21d4:	681b      	ldr	r3, [r3, #0]
    21d6:	2100      	movs	r1, #0
    21d8:	4618      	mov	r0, r3
    21da:	4b3e      	ldr	r3, [pc, #248]	; (22d4 <_can_async_init+0x198>)
    21dc:	4798      	blx	r3
		hri_can_write_TXESC_reg(dev->hw, CONF_CAN1_TXESC_REG);
    21de:	687b      	ldr	r3, [r7, #4]
    21e0:	681b      	ldr	r3, [r3, #0]
    21e2:	2100      	movs	r1, #0
    21e4:	4618      	mov	r0, r3
    21e6:	4b3c      	ldr	r3, [pc, #240]	; (22d8 <_can_async_init+0x19c>)
    21e8:	4798      	blx	r3
		hri_can_write_TXBC_reg(dev->hw, CONF_CAN1_TXBC_REG | CAN_TXBC_TBSA((uint32_t)can1_tx_fifo));
    21ea:	687b      	ldr	r3, [r7, #4]
    21ec:	681a      	ldr	r2, [r3, #0]
    21ee:	4b3b      	ldr	r3, [pc, #236]	; (22dc <_can_async_init+0x1a0>)
    21f0:	b29b      	uxth	r3, r3
    21f2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    21f6:	4619      	mov	r1, r3
    21f8:	4610      	mov	r0, r2
    21fa:	4b39      	ldr	r3, [pc, #228]	; (22e0 <_can_async_init+0x1a4>)
    21fc:	4798      	blx	r3
		hri_can_write_TXEFC_reg(dev->hw, CONF_CAN1_TXEFC_REG | CAN_TXEFC_EFSA((uint32_t)can1_tx_event_fifo));
    21fe:	687b      	ldr	r3, [r7, #4]
    2200:	681a      	ldr	r2, [r3, #0]
    2202:	4b38      	ldr	r3, [pc, #224]	; (22e4 <_can_async_init+0x1a8>)
    2204:	b29b      	uxth	r3, r3
    2206:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    220a:	4619      	mov	r1, r3
    220c:	4610      	mov	r0, r2
    220e:	4b36      	ldr	r3, [pc, #216]	; (22e8 <_can_async_init+0x1ac>)
    2210:	4798      	blx	r3
		hri_can_write_GFC_reg(dev->hw, CONF_CAN1_GFC_REG);
    2212:	687b      	ldr	r3, [r7, #4]
    2214:	681b      	ldr	r3, [r3, #0]
    2216:	2128      	movs	r1, #40	; 0x28
    2218:	4618      	mov	r0, r3
    221a:	4b34      	ldr	r3, [pc, #208]	; (22ec <_can_async_init+0x1b0>)
    221c:	4798      	blx	r3
		hri_can_write_SIDFC_reg(dev->hw, CONF_CAN1_SIDFC_REG | CAN_SIDFC_FLSSA((uint32_t)can1_rx_std_filter));
    221e:	687b      	ldr	r3, [r7, #4]
    2220:	681a      	ldr	r2, [r3, #0]
    2222:	4b33      	ldr	r3, [pc, #204]	; (22f0 <_can_async_init+0x1b4>)
    2224:	b29b      	uxth	r3, r3
    2226:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    222a:	4619      	mov	r1, r3
    222c:	4610      	mov	r0, r2
    222e:	4b31      	ldr	r3, [pc, #196]	; (22f4 <_can_async_init+0x1b8>)
    2230:	4798      	blx	r3
		hri_can_write_XIDFC_reg(dev->hw, CONF_CAN1_XIDFC_REG | CAN_XIDFC_FLESA((uint32_t)can1_rx_ext_filter));
    2232:	687b      	ldr	r3, [r7, #4]
    2234:	681a      	ldr	r2, [r3, #0]
    2236:	4b30      	ldr	r3, [pc, #192]	; (22f8 <_can_async_init+0x1bc>)
    2238:	b29b      	uxth	r3, r3
    223a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    223e:	4619      	mov	r1, r3
    2240:	4610      	mov	r0, r2
    2242:	4b2e      	ldr	r3, [pc, #184]	; (22fc <_can_async_init+0x1c0>)
    2244:	4798      	blx	r3
		hri_can_write_XIDAM_reg(dev->hw, CONF_CAN1_XIDAM_REG);
    2246:	687b      	ldr	r3, [r7, #4]
    2248:	681b      	ldr	r3, [r3, #0]
    224a:	2100      	movs	r1, #0
    224c:	4618      	mov	r0, r3
    224e:	4b2c      	ldr	r3, [pc, #176]	; (2300 <_can_async_init+0x1c4>)
    2250:	4798      	blx	r3

		NVIC_DisableIRQ(CAN1_IRQn);
    2252:	204f      	movs	r0, #79	; 0x4f
    2254:	4b2b      	ldr	r3, [pc, #172]	; (2304 <_can_async_init+0x1c8>)
    2256:	4798      	blx	r3
		NVIC_ClearPendingIRQ(CAN1_IRQn);
    2258:	204f      	movs	r0, #79	; 0x4f
    225a:	4b2b      	ldr	r3, [pc, #172]	; (2308 <_can_async_init+0x1cc>)
    225c:	4798      	blx	r3
		NVIC_EnableIRQ(CAN1_IRQn);
    225e:	204f      	movs	r0, #79	; 0x4f
    2260:	4b2a      	ldr	r3, [pc, #168]	; (230c <_can_async_init+0x1d0>)
    2262:	4798      	blx	r3
		hri_can_write_ILE_reg(dev->hw, CAN_ILE_EINT0);
    2264:	687b      	ldr	r3, [r7, #4]
    2266:	681b      	ldr	r3, [r3, #0]
    2268:	2101      	movs	r1, #1
    226a:	4618      	mov	r0, r3
    226c:	4b28      	ldr	r3, [pc, #160]	; (2310 <_can_async_init+0x1d4>)
    226e:	4798      	blx	r3
	}
#endif

	/* Disable CCE to prevent Configuration Change */
	hri_can_clear_CCCR_CCE_bit(dev->hw);
    2270:	687b      	ldr	r3, [r7, #4]
    2272:	681b      	ldr	r3, [r3, #0]
    2274:	4618      	mov	r0, r3
    2276:	4b27      	ldr	r3, [pc, #156]	; (2314 <_can_async_init+0x1d8>)
    2278:	4798      	blx	r3
	hri_can_clear_CCCR_INIT_bit(dev->hw);
    227a:	687b      	ldr	r3, [r7, #4]
    227c:	681b      	ldr	r3, [r3, #0]
    227e:	4618      	mov	r0, r3
    2280:	4b25      	ldr	r3, [pc, #148]	; (2318 <_can_async_init+0x1dc>)
    2282:	4798      	blx	r3
	while (hri_can_get_CCCR_INIT_bit(dev->hw)) {
    2284:	bf00      	nop
    2286:	687b      	ldr	r3, [r7, #4]
    2288:	681b      	ldr	r3, [r3, #0]
    228a:	4618      	mov	r0, r3
    228c:	4b05      	ldr	r3, [pc, #20]	; (22a4 <_can_async_init+0x168>)
    228e:	4798      	blx	r3
    2290:	4603      	mov	r3, r0
    2292:	2b00      	cmp	r3, #0
    2294:	d1f7      	bne.n	2286 <_can_async_init+0x14a>
	};

	return ERR_NONE;
    2296:	2300      	movs	r3, #0
}
    2298:	4618      	mov	r0, r3
    229a:	3708      	adds	r7, #8
    229c:	46bd      	mov	sp, r7
    229e:	bd80      	pop	{r7, pc}
    22a0:	00001ef1 	.word	0x00001ef1
    22a4:	00001f11 	.word	0x00001f11
    22a8:	00001f5f 	.word	0x00001f5f
    22ac:	42000400 	.word	0x42000400
    22b0:	200000ec 	.word	0x200000ec
    22b4:	20000004 	.word	0x20000004
    22b8:	00001f9f 	.word	0x00001f9f
    22bc:	00001eb9 	.word	0x00001eb9
    22c0:	06020a07 	.word	0x06020a07
    22c4:	00001fc1 	.word	0x00001fc1
    22c8:	00001ed5 	.word	0x00001ed5
    22cc:	2000171c 	.word	0x2000171c
    22d0:	000020a5 	.word	0x000020a5
    22d4:	000020c3 	.word	0x000020c3
    22d8:	000020ff 	.word	0x000020ff
    22dc:	200016fc 	.word	0x200016fc
    22e0:	000020e1 	.word	0x000020e1
    22e4:	200000c4 	.word	0x200000c4
    22e8:	0000211d 	.word	0x0000211d
    22ec:	0000202d 	.word	0x0000202d
    22f0:	200000d4 	.word	0x200000d4
    22f4:	0000204b 	.word	0x0000204b
    22f8:	200000dc 	.word	0x200000dc
    22fc:	00002069 	.word	0x00002069
    2300:	00002087 	.word	0x00002087
    2304:	00001e11 	.word	0x00001e11
    2308:	00001e55 	.word	0x00001e55
    230c:	00001dd5 	.word	0x00001dd5
    2310:	00002011 	.word	0x00002011
    2314:	00001f7f 	.word	0x00001f7f
    2318:	00001f3f 	.word	0x00001f3f

0000231c <CAN1_Handler>:

/*
 * \brief CAN interrupt handler
 */
void CAN1_Handler(void)
{
    231c:	b590      	push	{r4, r7, lr}
    231e:	b083      	sub	sp, #12
    2320:	af00      	add	r7, sp, #0
	struct _can_async_device *dev = _can1_dev;
    2322:	4b2c      	ldr	r3, [pc, #176]	; (23d4 <CAN1_Handler+0xb8>)
    2324:	681b      	ldr	r3, [r3, #0]
    2326:	607b      	str	r3, [r7, #4]
	uint32_t                  ir;
	ir = hri_can_read_IR_reg(dev->hw);
    2328:	687b      	ldr	r3, [r7, #4]
    232a:	681b      	ldr	r3, [r3, #0]
    232c:	4618      	mov	r0, r3
    232e:	4b2a      	ldr	r3, [pc, #168]	; (23d8 <CAN1_Handler+0xbc>)
    2330:	4798      	blx	r3
    2332:	6038      	str	r0, [r7, #0]

	if (ir & CAN_IR_RF0N) {
    2334:	683b      	ldr	r3, [r7, #0]
    2336:	f003 0301 	and.w	r3, r3, #1
    233a:	2b00      	cmp	r3, #0
    233c:	d003      	beq.n	2346 <CAN1_Handler+0x2a>
		dev->cb.rx_done(dev);
    233e:	687b      	ldr	r3, [r7, #4]
    2340:	689b      	ldr	r3, [r3, #8]
    2342:	6878      	ldr	r0, [r7, #4]
    2344:	4798      	blx	r3
	}

	if (ir & CAN_IR_TC) {
    2346:	683b      	ldr	r3, [r7, #0]
    2348:	f403 7300 	and.w	r3, r3, #512	; 0x200
    234c:	2b00      	cmp	r3, #0
    234e:	d003      	beq.n	2358 <CAN1_Handler+0x3c>
		dev->cb.tx_done(dev);
    2350:	687b      	ldr	r3, [r7, #4]
    2352:	685b      	ldr	r3, [r3, #4]
    2354:	6878      	ldr	r0, [r7, #4]
    2356:	4798      	blx	r3
	}

	if (ir & CAN_IR_BO) {
    2358:	683b      	ldr	r3, [r7, #0]
    235a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    235e:	2b00      	cmp	r3, #0
    2360:	d004      	beq.n	236c <CAN1_Handler+0x50>
		dev->cb.irq_handler(dev, CAN_IRQ_BO);
    2362:	687b      	ldr	r3, [r7, #4]
    2364:	68db      	ldr	r3, [r3, #12]
    2366:	2103      	movs	r1, #3
    2368:	6878      	ldr	r0, [r7, #4]
    236a:	4798      	blx	r3
	}

	if (ir & CAN_IR_EW) {
    236c:	683b      	ldr	r3, [r7, #0]
    236e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    2372:	2b00      	cmp	r3, #0
    2374:	d004      	beq.n	2380 <CAN1_Handler+0x64>
		dev->cb.irq_handler(dev, CAN_IRQ_EW);
    2376:	687b      	ldr	r3, [r7, #4]
    2378:	68db      	ldr	r3, [r3, #12]
    237a:	2100      	movs	r1, #0
    237c:	6878      	ldr	r0, [r7, #4]
    237e:	4798      	blx	r3
	}

	if (ir & CAN_IR_EP) {
    2380:	683b      	ldr	r3, [r7, #0]
    2382:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
    2386:	2b00      	cmp	r3, #0
    2388:	d00f      	beq.n	23aa <CAN1_Handler+0x8e>
		dev->cb.irq_handler(dev, hri_can_get_PSR_EP_bit(dev->hw) ? CAN_IRQ_EP : CAN_IRQ_EA);
    238a:	687b      	ldr	r3, [r7, #4]
    238c:	68dc      	ldr	r4, [r3, #12]
    238e:	687b      	ldr	r3, [r7, #4]
    2390:	681b      	ldr	r3, [r3, #0]
    2392:	4618      	mov	r0, r3
    2394:	4b11      	ldr	r3, [pc, #68]	; (23dc <CAN1_Handler+0xc0>)
    2396:	4798      	blx	r3
    2398:	4603      	mov	r3, r0
    239a:	2b00      	cmp	r3, #0
    239c:	d001      	beq.n	23a2 <CAN1_Handler+0x86>
    239e:	2302      	movs	r3, #2
    23a0:	e000      	b.n	23a4 <CAN1_Handler+0x88>
    23a2:	2301      	movs	r3, #1
    23a4:	4619      	mov	r1, r3
    23a6:	6878      	ldr	r0, [r7, #4]
    23a8:	47a0      	blx	r4
	}

	if (ir & CAN_IR_RF0L) {
    23aa:	683b      	ldr	r3, [r7, #0]
    23ac:	f003 0308 	and.w	r3, r3, #8
    23b0:	2b00      	cmp	r3, #0
    23b2:	d004      	beq.n	23be <CAN1_Handler+0xa2>
		dev->cb.irq_handler(dev, CAN_IRQ_DO);
    23b4:	687b      	ldr	r3, [r7, #4]
    23b6:	68db      	ldr	r3, [r3, #12]
    23b8:	2104      	movs	r1, #4
    23ba:	6878      	ldr	r0, [r7, #4]
    23bc:	4798      	blx	r3
	}

	hri_can_write_IR_reg(dev->hw, ir);
    23be:	687b      	ldr	r3, [r7, #4]
    23c0:	681b      	ldr	r3, [r3, #0]
    23c2:	6839      	ldr	r1, [r7, #0]
    23c4:	4618      	mov	r0, r3
    23c6:	4b06      	ldr	r3, [pc, #24]	; (23e0 <CAN1_Handler+0xc4>)
    23c8:	4798      	blx	r3
}
    23ca:	bf00      	nop
    23cc:	370c      	adds	r7, #12
    23ce:	46bd      	mov	sp, r7
    23d0:	bd90      	pop	{r4, r7, pc}
    23d2:	bf00      	nop
    23d4:	200000ec 	.word	0x200000ec
    23d8:	00001ff9 	.word	0x00001ff9
    23dc:	00001e91 	.word	0x00001e91
    23e0:	00001fdd 	.word	0x00001fdd

000023e4 <_get_cycles_for_us_internal>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
static inline uint32_t _get_cycles_for_us_internal(const uint16_t us, const uint32_t freq, const uint8_t power)
{
    23e4:	b480      	push	{r7}
    23e6:	b083      	sub	sp, #12
    23e8:	af00      	add	r7, sp, #0
    23ea:	4603      	mov	r3, r0
    23ec:	6039      	str	r1, [r7, #0]
    23ee:	80fb      	strh	r3, [r7, #6]
    23f0:	4613      	mov	r3, r2
    23f2:	717b      	strb	r3, [r7, #5]
	switch (power) {
    23f4:	797b      	ldrb	r3, [r7, #5]
    23f6:	3b04      	subs	r3, #4
    23f8:	2b05      	cmp	r3, #5
    23fa:	d86b      	bhi.n	24d4 <_get_cycles_for_us_internal+0xf0>
    23fc:	a201      	add	r2, pc, #4	; (adr r2, 2404 <_get_cycles_for_us_internal+0x20>)
    23fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    2402:	bf00      	nop
    2404:	000024b3 	.word	0x000024b3
    2408:	00002493 	.word	0x00002493
    240c:	00002475 	.word	0x00002475
    2410:	00002457 	.word	0x00002457
    2414:	00002439 	.word	0x00002439
    2418:	0000241d 	.word	0x0000241d
	case 9:
		return (us * (freq / 1000000) + 2) / 3;
    241c:	88fb      	ldrh	r3, [r7, #6]
    241e:	683a      	ldr	r2, [r7, #0]
    2420:	4935      	ldr	r1, [pc, #212]	; (24f8 <_get_cycles_for_us_internal+0x114>)
    2422:	fba1 1202 	umull	r1, r2, r1, r2
    2426:	0c92      	lsrs	r2, r2, #18
    2428:	fb02 f303 	mul.w	r3, r2, r3
    242c:	3302      	adds	r3, #2
    242e:	4a33      	ldr	r2, [pc, #204]	; (24fc <_get_cycles_for_us_internal+0x118>)
    2430:	fba2 2303 	umull	r2, r3, r2, r3
    2434:	085b      	lsrs	r3, r3, #1
    2436:	e059      	b.n	24ec <_get_cycles_for_us_internal+0x108>
	case 8:
		return (us * (freq / 100000) + 29) / 30;
    2438:	88fb      	ldrh	r3, [r7, #6]
    243a:	683a      	ldr	r2, [r7, #0]
    243c:	0952      	lsrs	r2, r2, #5
    243e:	4930      	ldr	r1, [pc, #192]	; (2500 <_get_cycles_for_us_internal+0x11c>)
    2440:	fba1 1202 	umull	r1, r2, r1, r2
    2444:	09d2      	lsrs	r2, r2, #7
    2446:	fb02 f303 	mul.w	r3, r2, r3
    244a:	331d      	adds	r3, #29
    244c:	4a2d      	ldr	r2, [pc, #180]	; (2504 <_get_cycles_for_us_internal+0x120>)
    244e:	fba2 2303 	umull	r2, r3, r2, r3
    2452:	091b      	lsrs	r3, r3, #4
    2454:	e04a      	b.n	24ec <_get_cycles_for_us_internal+0x108>
	case 7:
		return (us * (freq / 10000) + 299) / 300;
    2456:	88fb      	ldrh	r3, [r7, #6]
    2458:	683a      	ldr	r2, [r7, #0]
    245a:	492b      	ldr	r1, [pc, #172]	; (2508 <_get_cycles_for_us_internal+0x124>)
    245c:	fba1 1202 	umull	r1, r2, r1, r2
    2460:	0b52      	lsrs	r2, r2, #13
    2462:	fb02 f303 	mul.w	r3, r2, r3
    2466:	f203 132b 	addw	r3, r3, #299	; 0x12b
    246a:	4a28      	ldr	r2, [pc, #160]	; (250c <_get_cycles_for_us_internal+0x128>)
    246c:	fba2 2303 	umull	r2, r3, r2, r3
    2470:	095b      	lsrs	r3, r3, #5
    2472:	e03b      	b.n	24ec <_get_cycles_for_us_internal+0x108>
	case 6:
		return (us * (freq / 1000) + 2999) / 3000;
    2474:	88fb      	ldrh	r3, [r7, #6]
    2476:	683a      	ldr	r2, [r7, #0]
    2478:	4925      	ldr	r1, [pc, #148]	; (2510 <_get_cycles_for_us_internal+0x12c>)
    247a:	fba1 1202 	umull	r1, r2, r1, r2
    247e:	0992      	lsrs	r2, r2, #6
    2480:	fb02 f303 	mul.w	r3, r2, r3
    2484:	f603 33b7 	addw	r3, r3, #2999	; 0xbb7
    2488:	4a22      	ldr	r2, [pc, #136]	; (2514 <_get_cycles_for_us_internal+0x130>)
    248a:	fba2 2303 	umull	r2, r3, r2, r3
    248e:	099b      	lsrs	r3, r3, #6
    2490:	e02c      	b.n	24ec <_get_cycles_for_us_internal+0x108>
	case 5:
		return (us * (freq / 100) + 29999) / 30000;
    2492:	88fb      	ldrh	r3, [r7, #6]
    2494:	683a      	ldr	r2, [r7, #0]
    2496:	4920      	ldr	r1, [pc, #128]	; (2518 <_get_cycles_for_us_internal+0x134>)
    2498:	fba1 1202 	umull	r1, r2, r1, r2
    249c:	0952      	lsrs	r2, r2, #5
    249e:	fb02 f303 	mul.w	r3, r2, r3
    24a2:	f503 43ea 	add.w	r3, r3, #29952	; 0x7500
    24a6:	332f      	adds	r3, #47	; 0x2f
    24a8:	4a1c      	ldr	r2, [pc, #112]	; (251c <_get_cycles_for_us_internal+0x138>)
    24aa:	fba2 2303 	umull	r2, r3, r2, r3
    24ae:	0b5b      	lsrs	r3, r3, #13
    24b0:	e01c      	b.n	24ec <_get_cycles_for_us_internal+0x108>
	case 4:
		return (us * (freq / 10) + 299999) / 300000;
    24b2:	88fb      	ldrh	r3, [r7, #6]
    24b4:	683a      	ldr	r2, [r7, #0]
    24b6:	491a      	ldr	r1, [pc, #104]	; (2520 <_get_cycles_for_us_internal+0x13c>)
    24b8:	fba1 1202 	umull	r1, r2, r1, r2
    24bc:	08d2      	lsrs	r2, r2, #3
    24be:	fb02 f303 	mul.w	r3, r2, r3
    24c2:	f503 2392 	add.w	r3, r3, #299008	; 0x49000
    24c6:	f203 33df 	addw	r3, r3, #991	; 0x3df
    24ca:	4a16      	ldr	r2, [pc, #88]	; (2524 <_get_cycles_for_us_internal+0x140>)
    24cc:	fba2 2303 	umull	r2, r3, r2, r3
    24d0:	0c5b      	lsrs	r3, r3, #17
    24d2:	e00b      	b.n	24ec <_get_cycles_for_us_internal+0x108>
	default:
		return (us * freq + 2999999) / 3000000;
    24d4:	88fb      	ldrh	r3, [r7, #6]
    24d6:	683a      	ldr	r2, [r7, #0]
    24d8:	fb02 f303 	mul.w	r3, r2, r3
    24dc:	f503 1337 	add.w	r3, r3, #2998272	; 0x2dc000
    24e0:	f203 63bf 	addw	r3, r3, #1727	; 0x6bf
    24e4:	4a10      	ldr	r2, [pc, #64]	; (2528 <_get_cycles_for_us_internal+0x144>)
    24e6:	fba2 2303 	umull	r2, r3, r2, r3
    24ea:	0c9b      	lsrs	r3, r3, #18
	}
}
    24ec:	4618      	mov	r0, r3
    24ee:	370c      	adds	r7, #12
    24f0:	46bd      	mov	sp, r7
    24f2:	f85d 7b04 	ldr.w	r7, [sp], #4
    24f6:	4770      	bx	lr
    24f8:	431bde83 	.word	0x431bde83
    24fc:	aaaaaaab 	.word	0xaaaaaaab
    2500:	0a7c5ac5 	.word	0x0a7c5ac5
    2504:	88888889 	.word	0x88888889
    2508:	d1b71759 	.word	0xd1b71759
    250c:	1b4e81b5 	.word	0x1b4e81b5
    2510:	10624dd3 	.word	0x10624dd3
    2514:	057619f1 	.word	0x057619f1
    2518:	51eb851f 	.word	0x51eb851f
    251c:	45e7b273 	.word	0x45e7b273
    2520:	cccccccd 	.word	0xcccccccd
    2524:	6fd91d85 	.word	0x6fd91d85
    2528:	165e9f81 	.word	0x165e9f81

0000252c <_get_cycles_for_us>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
uint32_t _get_cycles_for_us(const uint16_t us)
{
    252c:	b580      	push	{r7, lr}
    252e:	b082      	sub	sp, #8
    2530:	af00      	add	r7, sp, #0
    2532:	4603      	mov	r3, r0
    2534:	80fb      	strh	r3, [r7, #6]
	return _get_cycles_for_us_internal(us, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
    2536:	88fb      	ldrh	r3, [r7, #6]
    2538:	2208      	movs	r2, #8
    253a:	4904      	ldr	r1, [pc, #16]	; (254c <_get_cycles_for_us+0x20>)
    253c:	4618      	mov	r0, r3
    253e:	4b04      	ldr	r3, [pc, #16]	; (2550 <_get_cycles_for_us+0x24>)
    2540:	4798      	blx	r3
    2542:	4603      	mov	r3, r0
}
    2544:	4618      	mov	r0, r3
    2546:	3708      	adds	r7, #8
    2548:	46bd      	mov	sp, r7
    254a:	bd80      	pop	{r7, pc}
    254c:	00b71b00 	.word	0x00b71b00
    2550:	000023e5 	.word	0x000023e5
    2554:	00000000 	.word	0x00000000

00002558 <_delay_cycles>:
}
/**
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
    2558:	b480      	push	{r7}
    255a:	b083      	sub	sp, #12
    255c:	af00      	add	r7, sp, #0
    255e:	6078      	str	r0, [r7, #4]
    2560:	6039      	str	r1, [r7, #0]
    2562:	bf00      	nop
    2564:	f3af 8000 	nop.w

00002568 <__delay>:
	__asm(".align 3 \n"
	      "__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#elif defined __GNUC__
	__asm(".syntax unified\n"
    2568:	3901      	subs	r1, #1
    256a:	d8fd      	bhi.n	2568 <__delay>
	__asm("__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi.n __delay\n");
#endif
#endif
}
    256c:	bf00      	nop
    256e:	370c      	adds	r7, #12
    2570:	46bd      	mov	sp, r7
    2572:	f85d 7b04 	ldr.w	r7, [sp], #4
    2576:	4770      	bx	lr

00002578 <hri_nvmctrl_set_CTRLA_RWS_bf>:
	tmp = (tmp & NVMCTRL_CTRLA_PRM_Msk) >> NVMCTRL_CTRLA_PRM_Pos;
	return tmp;
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
    2578:	b480      	push	{r7}
    257a:	b083      	sub	sp, #12
    257c:	af00      	add	r7, sp, #0
    257e:	6078      	str	r0, [r7, #4]
    2580:	460b      	mov	r3, r1
    2582:	807b      	strh	r3, [r7, #2]
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    2584:	687b      	ldr	r3, [r7, #4]
    2586:	881b      	ldrh	r3, [r3, #0]
    2588:	b29a      	uxth	r2, r3
    258a:	887b      	ldrh	r3, [r7, #2]
    258c:	021b      	lsls	r3, r3, #8
    258e:	b29b      	uxth	r3, r3
    2590:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
    2594:	b29b      	uxth	r3, r3
    2596:	4313      	orrs	r3, r2
    2598:	b29a      	uxth	r2, r3
    259a:	687b      	ldr	r3, [r7, #4]
    259c:	801a      	strh	r2, [r3, #0]
	NVMCTRL_CRITICAL_SECTION_LEAVE();
}
    259e:	bf00      	nop
    25a0:	370c      	adds	r7, #12
    25a2:	46bd      	mov	sp, r7
    25a4:	f85d 7b04 	ldr.w	r7, [sp], #4
    25a8:	4770      	bx	lr
	...

000025ac <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    25ac:	b580      	push	{r7, lr}
    25ae:	af00      	add	r7, sp, #0
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);
    25b0:	2100      	movs	r1, #0
    25b2:	4808      	ldr	r0, [pc, #32]	; (25d4 <_init_chip+0x28>)
    25b4:	4b08      	ldr	r3, [pc, #32]	; (25d8 <_init_chip+0x2c>)
    25b6:	4798      	blx	r3

	_osc32kctrl_init_sources();
    25b8:	4b08      	ldr	r3, [pc, #32]	; (25dc <_init_chip+0x30>)
    25ba:	4798      	blx	r3
	_oscctrl_init_sources();
    25bc:	4b08      	ldr	r3, [pc, #32]	; (25e0 <_init_chip+0x34>)
    25be:	4798      	blx	r3
	_mclk_init();
    25c0:	4b08      	ldr	r3, [pc, #32]	; (25e4 <_init_chip+0x38>)
    25c2:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
    25c4:	4b08      	ldr	r3, [pc, #32]	; (25e8 <_init_chip+0x3c>)
    25c6:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    25c8:	f640 70ff 	movw	r0, #4095	; 0xfff
    25cc:	4b07      	ldr	r3, [pc, #28]	; (25ec <_init_chip+0x40>)
    25ce:	4798      	blx	r3
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    25d0:	bf00      	nop
    25d2:	bd80      	pop	{r7, pc}
    25d4:	41004000 	.word	0x41004000
    25d8:	00002579 	.word	0x00002579
    25dc:	00002bfd 	.word	0x00002bfd
    25e0:	00002c95 	.word	0x00002c95
    25e4:	00002b79 	.word	0x00002b79
    25e8:	00002cd5 	.word	0x00002cd5
    25ec:	00002645 	.word	0x00002645

000025f0 <hri_gclk_wait_for_sync>:
{
    25f0:	b480      	push	{r7}
    25f2:	b083      	sub	sp, #12
    25f4:	af00      	add	r7, sp, #0
    25f6:	6078      	str	r0, [r7, #4]
    25f8:	6039      	str	r1, [r7, #0]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    25fa:	bf00      	nop
    25fc:	687b      	ldr	r3, [r7, #4]
    25fe:	685a      	ldr	r2, [r3, #4]
    2600:	683b      	ldr	r3, [r7, #0]
    2602:	4013      	ands	r3, r2
    2604:	2b00      	cmp	r3, #0
    2606:	d1f9      	bne.n	25fc <hri_gclk_wait_for_sync+0xc>
}
    2608:	bf00      	nop
    260a:	370c      	adds	r7, #12
    260c:	46bd      	mov	sp, r7
    260e:	f85d 7b04 	ldr.w	r7, [sp], #4
    2612:	4770      	bx	lr

00002614 <hri_gclk_write_GENCTRL_reg>:
{
    2614:	b580      	push	{r7, lr}
    2616:	b084      	sub	sp, #16
    2618:	af00      	add	r7, sp, #0
    261a:	60f8      	str	r0, [r7, #12]
    261c:	460b      	mov	r3, r1
    261e:	607a      	str	r2, [r7, #4]
    2620:	72fb      	strb	r3, [r7, #11]
	((Gclk *)hw)->GENCTRL[index].reg = data;
    2622:	7afa      	ldrb	r2, [r7, #11]
    2624:	68fb      	ldr	r3, [r7, #12]
    2626:	3208      	adds	r2, #8
    2628:	6879      	ldr	r1, [r7, #4]
    262a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    262e:	f643 71fd 	movw	r1, #16381	; 0x3ffd
    2632:	68f8      	ldr	r0, [r7, #12]
    2634:	4b02      	ldr	r3, [pc, #8]	; (2640 <hri_gclk_write_GENCTRL_reg+0x2c>)
    2636:	4798      	blx	r3
}
    2638:	bf00      	nop
    263a:	3710      	adds	r7, #16
    263c:	46bd      	mov	sp, r7
    263e:	bd80      	pop	{r7, pc}
    2640:	000025f1 	.word	0x000025f1

00002644 <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    2644:	b580      	push	{r7, lr}
    2646:	b082      	sub	sp, #8
    2648:	af00      	add	r7, sp, #0
    264a:	6078      	str	r0, [r7, #4]

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    264c:	687b      	ldr	r3, [r7, #4]
    264e:	f003 0301 	and.w	r3, r3, #1
    2652:	2b00      	cmp	r3, #0
    2654:	d004      	beq.n	2660 <_gclk_init_generators_by_fref+0x1c>
		hri_gclk_write_GENCTRL_reg(
    2656:	4a04      	ldr	r2, [pc, #16]	; (2668 <_gclk_init_generators_by_fref+0x24>)
    2658:	2100      	movs	r1, #0
    265a:	4804      	ldr	r0, [pc, #16]	; (266c <_gclk_init_generators_by_fref+0x28>)
    265c:	4b04      	ldr	r3, [pc, #16]	; (2670 <_gclk_init_generators_by_fref+0x2c>)
    265e:	4798      	blx	r3
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    2660:	bf00      	nop
    2662:	3708      	adds	r7, #8
    2664:	46bd      	mov	sp, r7
    2666:	bd80      	pop	{r7, pc}
    2668:	00010101 	.word	0x00010101
    266c:	40001c00 	.word	0x40001c00
    2670:	00002615 	.word	0x00002615

00002674 <__NVIC_EnableIRQ>:
{
    2674:	b480      	push	{r7}
    2676:	b083      	sub	sp, #12
    2678:	af00      	add	r7, sp, #0
    267a:	4603      	mov	r3, r0
    267c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    267e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    2682:	2b00      	cmp	r3, #0
    2684:	db0b      	blt.n	269e <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2686:	4909      	ldr	r1, [pc, #36]	; (26ac <__NVIC_EnableIRQ+0x38>)
    2688:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    268c:	095b      	lsrs	r3, r3, #5
    268e:	88fa      	ldrh	r2, [r7, #6]
    2690:	f002 021f 	and.w	r2, r2, #31
    2694:	2001      	movs	r0, #1
    2696:	fa00 f202 	lsl.w	r2, r0, r2
    269a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    269e:	bf00      	nop
    26a0:	370c      	adds	r7, #12
    26a2:	46bd      	mov	sp, r7
    26a4:	f85d 7b04 	ldr.w	r7, [sp], #4
    26a8:	4770      	bx	lr
    26aa:	bf00      	nop
    26ac:	e000e100 	.word	0xe000e100

000026b0 <__NVIC_DisableIRQ>:
{
    26b0:	b480      	push	{r7}
    26b2:	b083      	sub	sp, #12
    26b4:	af00      	add	r7, sp, #0
    26b6:	4603      	mov	r3, r0
    26b8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    26ba:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    26be:	2b00      	cmp	r3, #0
    26c0:	db10      	blt.n	26e4 <__NVIC_DisableIRQ+0x34>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    26c2:	490b      	ldr	r1, [pc, #44]	; (26f0 <__NVIC_DisableIRQ+0x40>)
    26c4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    26c8:	095b      	lsrs	r3, r3, #5
    26ca:	88fa      	ldrh	r2, [r7, #6]
    26cc:	f002 021f 	and.w	r2, r2, #31
    26d0:	2001      	movs	r0, #1
    26d2:	fa00 f202 	lsl.w	r2, r0, r2
    26d6:	3320      	adds	r3, #32
    26d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
    26dc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    26e0:	f3bf 8f6f 	isb	sy
}
    26e4:	bf00      	nop
    26e6:	370c      	adds	r7, #12
    26e8:	46bd      	mov	sp, r7
    26ea:	f85d 7b04 	ldr.w	r7, [sp], #4
    26ee:	4770      	bx	lr
    26f0:	e000e100 	.word	0xe000e100

000026f4 <__NVIC_ClearPendingIRQ>:
{
    26f4:	b480      	push	{r7}
    26f6:	b083      	sub	sp, #12
    26f8:	af00      	add	r7, sp, #0
    26fa:	4603      	mov	r3, r0
    26fc:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
    26fe:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    2702:	2b00      	cmp	r3, #0
    2704:	db0c      	blt.n	2720 <__NVIC_ClearPendingIRQ+0x2c>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2706:	4909      	ldr	r1, [pc, #36]	; (272c <__NVIC_ClearPendingIRQ+0x38>)
    2708:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    270c:	095b      	lsrs	r3, r3, #5
    270e:	88fa      	ldrh	r2, [r7, #6]
    2710:	f002 021f 	and.w	r2, r2, #31
    2714:	2001      	movs	r0, #1
    2716:	fa00 f202 	lsl.w	r2, r0, r2
    271a:	3360      	adds	r3, #96	; 0x60
    271c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    2720:	bf00      	nop
    2722:	370c      	adds	r7, #12
    2724:	46bd      	mov	sp, r7
    2726:	f85d 7b04 	ldr.w	r7, [sp], #4
    272a:	4770      	bx	lr
    272c:	e000e100 	.word	0xe000e100

00002730 <hri_gmac_set_NCR_reg>:
{
	return ((Gmac *)hw)->TLPITI.reg;
}

static inline void hri_gmac_set_NCR_reg(const void *const hw, hri_gmac_ncr_reg_t mask)
{
    2730:	b480      	push	{r7}
    2732:	b083      	sub	sp, #12
    2734:	af00      	add	r7, sp, #0
    2736:	6078      	str	r0, [r7, #4]
    2738:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->NCR.reg |= mask;
    273a:	687b      	ldr	r3, [r7, #4]
    273c:	681a      	ldr	r2, [r3, #0]
    273e:	683b      	ldr	r3, [r7, #0]
    2740:	431a      	orrs	r2, r3
    2742:	687b      	ldr	r3, [r7, #4]
    2744:	601a      	str	r2, [r3, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    2746:	bf00      	nop
    2748:	370c      	adds	r7, #12
    274a:	46bd      	mov	sp, r7
    274c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2750:	4770      	bx	lr

00002752 <hri_gmac_write_NCR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_NCR_reg(const void *const hw, hri_gmac_ncr_reg_t data)
{
    2752:	b480      	push	{r7}
    2754:	b083      	sub	sp, #12
    2756:	af00      	add	r7, sp, #0
    2758:	6078      	str	r0, [r7, #4]
    275a:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->NCR.reg = data;
    275c:	687b      	ldr	r3, [r7, #4]
    275e:	683a      	ldr	r2, [r7, #0]
    2760:	601a      	str	r2, [r3, #0]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    2762:	bf00      	nop
    2764:	370c      	adds	r7, #12
    2766:	46bd      	mov	sp, r7
    2768:	f85d 7b04 	ldr.w	r7, [sp], #4
    276c:	4770      	bx	lr

0000276e <hri_gmac_write_NCFGR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_NCFGR_reg(const void *const hw, hri_gmac_ncfgr_reg_t data)
{
    276e:	b480      	push	{r7}
    2770:	b083      	sub	sp, #12
    2772:	af00      	add	r7, sp, #0
    2774:	6078      	str	r0, [r7, #4]
    2776:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->NCFGR.reg = data;
    2778:	687b      	ldr	r3, [r7, #4]
    277a:	683a      	ldr	r2, [r7, #0]
    277c:	605a      	str	r2, [r3, #4]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    277e:	bf00      	nop
    2780:	370c      	adds	r7, #12
    2782:	46bd      	mov	sp, r7
    2784:	f85d 7b04 	ldr.w	r7, [sp], #4
    2788:	4770      	bx	lr

0000278a <hri_gmac_write_UR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_UR_reg(const void *const hw, hri_gmac_ur_reg_t data)
{
    278a:	b480      	push	{r7}
    278c:	b083      	sub	sp, #12
    278e:	af00      	add	r7, sp, #0
    2790:	6078      	str	r0, [r7, #4]
    2792:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->UR.reg = data;
    2794:	687b      	ldr	r3, [r7, #4]
    2796:	683a      	ldr	r2, [r7, #0]
    2798:	60da      	str	r2, [r3, #12]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    279a:	bf00      	nop
    279c:	370c      	adds	r7, #12
    279e:	46bd      	mov	sp, r7
    27a0:	f85d 7b04 	ldr.w	r7, [sp], #4
    27a4:	4770      	bx	lr

000027a6 <hri_gmac_write_DCFGR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_DCFGR_reg(const void *const hw, hri_gmac_dcfgr_reg_t data)
{
    27a6:	b480      	push	{r7}
    27a8:	b083      	sub	sp, #12
    27aa:	af00      	add	r7, sp, #0
    27ac:	6078      	str	r0, [r7, #4]
    27ae:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->DCFGR.reg = data;
    27b0:	687b      	ldr	r3, [r7, #4]
    27b2:	683a      	ldr	r2, [r7, #0]
    27b4:	611a      	str	r2, [r3, #16]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    27b6:	bf00      	nop
    27b8:	370c      	adds	r7, #12
    27ba:	46bd      	mov	sp, r7
    27bc:	f85d 7b04 	ldr.w	r7, [sp], #4
    27c0:	4770      	bx	lr

000027c2 <hri_gmac_write_TSR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_TSR_reg(const void *const hw, hri_gmac_tsr_reg_t data)
{
    27c2:	b480      	push	{r7}
    27c4:	b083      	sub	sp, #12
    27c6:	af00      	add	r7, sp, #0
    27c8:	6078      	str	r0, [r7, #4]
    27ca:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->TSR.reg = data;
    27cc:	687b      	ldr	r3, [r7, #4]
    27ce:	683a      	ldr	r2, [r7, #0]
    27d0:	615a      	str	r2, [r3, #20]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    27d2:	bf00      	nop
    27d4:	370c      	adds	r7, #12
    27d6:	46bd      	mov	sp, r7
    27d8:	f85d 7b04 	ldr.w	r7, [sp], #4
    27dc:	4770      	bx	lr

000027de <hri_gmac_read_TSR_reg>:
	((Gmac *)hw)->TSR.reg ^= mask;
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_tsr_reg_t hri_gmac_read_TSR_reg(const void *const hw)
{
    27de:	b480      	push	{r7}
    27e0:	b083      	sub	sp, #12
    27e2:	af00      	add	r7, sp, #0
    27e4:	6078      	str	r0, [r7, #4]
	return ((Gmac *)hw)->TSR.reg;
    27e6:	687b      	ldr	r3, [r7, #4]
    27e8:	695b      	ldr	r3, [r3, #20]
}
    27ea:	4618      	mov	r0, r3
    27ec:	370c      	adds	r7, #12
    27ee:	46bd      	mov	sp, r7
    27f0:	f85d 7b04 	ldr.w	r7, [sp], #4
    27f4:	4770      	bx	lr

000027f6 <hri_gmac_write_RBQB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_RBQB_reg(const void *const hw, hri_gmac_rbqb_reg_t data)
{
    27f6:	b480      	push	{r7}
    27f8:	b083      	sub	sp, #12
    27fa:	af00      	add	r7, sp, #0
    27fc:	6078      	str	r0, [r7, #4]
    27fe:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->RBQB.reg = data;
    2800:	687b      	ldr	r3, [r7, #4]
    2802:	683a      	ldr	r2, [r7, #0]
    2804:	619a      	str	r2, [r3, #24]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    2806:	bf00      	nop
    2808:	370c      	adds	r7, #12
    280a:	46bd      	mov	sp, r7
    280c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2810:	4770      	bx	lr

00002812 <hri_gmac_write_TBQB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_TBQB_reg(const void *const hw, hri_gmac_tbqb_reg_t data)
{
    2812:	b480      	push	{r7}
    2814:	b083      	sub	sp, #12
    2816:	af00      	add	r7, sp, #0
    2818:	6078      	str	r0, [r7, #4]
    281a:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->TBQB.reg = data;
    281c:	687b      	ldr	r3, [r7, #4]
    281e:	683a      	ldr	r2, [r7, #0]
    2820:	61da      	str	r2, [r3, #28]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    2822:	bf00      	nop
    2824:	370c      	adds	r7, #12
    2826:	46bd      	mov	sp, r7
    2828:	f85d 7b04 	ldr.w	r7, [sp], #4
    282c:	4770      	bx	lr

0000282e <hri_gmac_write_RSR_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_RSR_reg(const void *const hw, hri_gmac_rsr_reg_t data)
{
    282e:	b480      	push	{r7}
    2830:	b083      	sub	sp, #12
    2832:	af00      	add	r7, sp, #0
    2834:	6078      	str	r0, [r7, #4]
    2836:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->RSR.reg = data;
    2838:	687b      	ldr	r3, [r7, #4]
    283a:	683a      	ldr	r2, [r7, #0]
    283c:	621a      	str	r2, [r3, #32]
	GMAC_CRITICAL_SECTION_LEAVE();
}
    283e:	bf00      	nop
    2840:	370c      	adds	r7, #12
    2842:	46bd      	mov	sp, r7
    2844:	f85d 7b04 	ldr.w	r7, [sp], #4
    2848:	4770      	bx	lr

0000284a <hri_gmac_read_RSR_reg>:
	((Gmac *)hw)->RSR.reg ^= mask;
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_rsr_reg_t hri_gmac_read_RSR_reg(const void *const hw)
{
    284a:	b480      	push	{r7}
    284c:	b083      	sub	sp, #12
    284e:	af00      	add	r7, sp, #0
    2850:	6078      	str	r0, [r7, #4]
	return ((Gmac *)hw)->RSR.reg;
    2852:	687b      	ldr	r3, [r7, #4]
    2854:	6a1b      	ldr	r3, [r3, #32]
}
    2856:	4618      	mov	r0, r3
    2858:	370c      	adds	r7, #12
    285a:	46bd      	mov	sp, r7
    285c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2860:	4770      	bx	lr

00002862 <hri_gmac_read_ISR_reg>:
	((Gmac *)hw)->ISR.reg ^= mask;
	GMAC_CRITICAL_SECTION_LEAVE();
}

static inline hri_gmac_isr_reg_t hri_gmac_read_ISR_reg(const void *const hw)
{
    2862:	b480      	push	{r7}
    2864:	b083      	sub	sp, #12
    2866:	af00      	add	r7, sp, #0
    2868:	6078      	str	r0, [r7, #4]
	return ((Gmac *)hw)->ISR.reg;
    286a:	687b      	ldr	r3, [r7, #4]
    286c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
    286e:	4618      	mov	r0, r3
    2870:	370c      	adds	r7, #12
    2872:	46bd      	mov	sp, r7
    2874:	f85d 7b04 	ldr.w	r7, [sp], #4
    2878:	4770      	bx	lr

0000287a <hri_gmac_write_WOL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_WOL_reg(const void *const hw, hri_gmac_wol_reg_t data)
{
    287a:	b480      	push	{r7}
    287c:	b083      	sub	sp, #12
    287e:	af00      	add	r7, sp, #0
    2880:	6078      	str	r0, [r7, #4]
    2882:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->WOL.reg = data;
    2884:	687b      	ldr	r3, [r7, #4]
    2886:	683a      	ldr	r2, [r7, #0]
    2888:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
	GMAC_CRITICAL_SECTION_LEAVE();
}
    288c:	bf00      	nop
    288e:	370c      	adds	r7, #12
    2890:	46bd      	mov	sp, r7
    2892:	f85d 7b04 	ldr.w	r7, [sp], #4
    2896:	4770      	bx	lr

00002898 <hri_gmac_write_IPGS_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_gmac_write_IPGS_reg(const void *const hw, hri_gmac_ipgs_reg_t data)
{
    2898:	b480      	push	{r7}
    289a:	b083      	sub	sp, #12
    289c:	af00      	add	r7, sp, #0
    289e:	6078      	str	r0, [r7, #4]
    28a0:	6039      	str	r1, [r7, #0]
	GMAC_CRITICAL_SECTION_ENTER();
	((Gmac *)hw)->IPGS.reg = data;
    28a2:	687b      	ldr	r3, [r7, #4]
    28a4:	683a      	ldr	r2, [r7, #0]
    28a6:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
	GMAC_CRITICAL_SECTION_LEAVE();
}
    28aa:	bf00      	nop
    28ac:	370c      	adds	r7, #12
    28ae:	46bd      	mov	sp, r7
    28b0:	f85d 7b04 	ldr.w	r7, [sp], #4
    28b4:	4770      	bx	lr
	...

000028b8 <_mac_init_bufdescr>:
 * \internal Initialize the Transmit and receive buffer descriptor array
 *
 * \param[in] dev Pointer to the HPL MAC descriptor
 */
static void _mac_init_bufdescr(struct _mac_async_device *const dev)
{
    28b8:	b580      	push	{r7, lr}
    28ba:	b084      	sub	sp, #16
    28bc:	af00      	add	r7, sp, #0
    28be:	6078      	str	r0, [r7, #4]
	uint32_t i;

	/* TX buffer descriptor */
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
    28c0:	2300      	movs	r3, #0
    28c2:	60fb      	str	r3, [r7, #12]
    28c4:	e01c      	b.n	2900 <_mac_init_bufdescr+0x48>
		_txbuf_descrs[i].address        = (uint32_t)_txbuf[i];
    28c6:	68fb      	ldr	r3, [r7, #12]
    28c8:	f240 52dc 	movw	r2, #1500	; 0x5dc
    28cc:	fb02 f303 	mul.w	r3, r2, r3
    28d0:	4a2c      	ldr	r2, [pc, #176]	; (2984 <_mac_init_bufdescr+0xcc>)
    28d2:	4413      	add	r3, r2
    28d4:	4619      	mov	r1, r3
    28d6:	4a2c      	ldr	r2, [pc, #176]	; (2988 <_mac_init_bufdescr+0xd0>)
    28d8:	68fb      	ldr	r3, [r7, #12]
    28da:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
		_txbuf_descrs[i].status.val     = 0;
    28de:	4a2a      	ldr	r2, [pc, #168]	; (2988 <_mac_init_bufdescr+0xd0>)
    28e0:	68fb      	ldr	r3, [r7, #12]
    28e2:	00db      	lsls	r3, r3, #3
    28e4:	4413      	add	r3, r2
    28e6:	2200      	movs	r2, #0
    28e8:	605a      	str	r2, [r3, #4]
		_txbuf_descrs[i].status.bm.used = 1;
    28ea:	4a27      	ldr	r2, [pc, #156]	; (2988 <_mac_init_bufdescr+0xd0>)
    28ec:	68fb      	ldr	r3, [r7, #12]
    28ee:	00db      	lsls	r3, r3, #3
    28f0:	4413      	add	r3, r2
    28f2:	79da      	ldrb	r2, [r3, #7]
    28f4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    28f8:	71da      	strb	r2, [r3, #7]
	for (i = 0; i < CONF_GMAC_TXDESCR_NUM; i++) {
    28fa:	68fb      	ldr	r3, [r7, #12]
    28fc:	3301      	adds	r3, #1
    28fe:	60fb      	str	r3, [r7, #12]
    2900:	68fb      	ldr	r3, [r7, #12]
    2902:	2b01      	cmp	r3, #1
    2904:	d9df      	bls.n	28c6 <_mac_init_bufdescr+0xe>
	}

	_txbuf_descrs[CONF_GMAC_TXDESCR_NUM - 1].status.bm.wrap = 1;
    2906:	4a20      	ldr	r2, [pc, #128]	; (2988 <_mac_init_bufdescr+0xd0>)
    2908:	7bd3      	ldrb	r3, [r2, #15]
    290a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    290e:	73d3      	strb	r3, [r2, #15]
	_txbuf_index                                            = 0;
    2910:	4b1e      	ldr	r3, [pc, #120]	; (298c <_mac_init_bufdescr+0xd4>)
    2912:	2200      	movs	r2, #0
    2914:	601a      	str	r2, [r3, #0]
	_last_txbuf_index                                       = 0;
    2916:	4b1e      	ldr	r3, [pc, #120]	; (2990 <_mac_init_bufdescr+0xd8>)
    2918:	2200      	movs	r2, #0
    291a:	601a      	str	r2, [r3, #0]

	/* RX buffer descriptor */
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    291c:	2300      	movs	r3, #0
    291e:	60fb      	str	r3, [r7, #12]
    2920:	e011      	b.n	2946 <_mac_init_bufdescr+0x8e>
		_rxbuf_descrs[i].address.val = (uint32_t)_rxbuf[i];
    2922:	68fb      	ldr	r3, [r7, #12]
    2924:	01db      	lsls	r3, r3, #7
    2926:	4a1b      	ldr	r2, [pc, #108]	; (2994 <_mac_init_bufdescr+0xdc>)
    2928:	4413      	add	r3, r2
    292a:	4619      	mov	r1, r3
    292c:	4a1a      	ldr	r2, [pc, #104]	; (2998 <_mac_init_bufdescr+0xe0>)
    292e:	68fb      	ldr	r3, [r7, #12]
    2930:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
		_rxbuf_descrs[i].status.val  = 0;
    2934:	4a18      	ldr	r2, [pc, #96]	; (2998 <_mac_init_bufdescr+0xe0>)
    2936:	68fb      	ldr	r3, [r7, #12]
    2938:	00db      	lsls	r3, r3, #3
    293a:	4413      	add	r3, r2
    293c:	2200      	movs	r2, #0
    293e:	605a      	str	r2, [r3, #4]
	for (i = 0; i < CONF_GMAC_RXDESCR_NUM; i++) {
    2940:	68fb      	ldr	r3, [r7, #12]
    2942:	3301      	adds	r3, #1
    2944:	60fb      	str	r3, [r7, #12]
    2946:	68fb      	ldr	r3, [r7, #12]
    2948:	2b0f      	cmp	r3, #15
    294a:	d9ea      	bls.n	2922 <_mac_init_bufdescr+0x6a>
	}

	_rxbuf_descrs[CONF_GMAC_RXDESCR_NUM - 1].address.bm.wrap = 1;
    294c:	4a12      	ldr	r2, [pc, #72]	; (2998 <_mac_init_bufdescr+0xe0>)
    294e:	f892 3078 	ldrb.w	r3, [r2, #120]	; 0x78
    2952:	f043 0302 	orr.w	r3, r3, #2
    2956:	f882 3078 	strb.w	r3, [r2, #120]	; 0x78
	_rxbuf_index                                             = 0;
    295a:	4b10      	ldr	r3, [pc, #64]	; (299c <_mac_init_bufdescr+0xe4>)
    295c:	2200      	movs	r2, #0
    295e:	601a      	str	r2, [r3, #0]

	hri_gmac_write_TBQB_reg(dev->hw, (uint32_t)_txbuf_descrs);
    2960:	687b      	ldr	r3, [r7, #4]
    2962:	681b      	ldr	r3, [r3, #0]
    2964:	4a08      	ldr	r2, [pc, #32]	; (2988 <_mac_init_bufdescr+0xd0>)
    2966:	4611      	mov	r1, r2
    2968:	4618      	mov	r0, r3
    296a:	4b0d      	ldr	r3, [pc, #52]	; (29a0 <_mac_init_bufdescr+0xe8>)
    296c:	4798      	blx	r3
	hri_gmac_write_RBQB_reg(dev->hw, (uint32_t)_rxbuf_descrs);
    296e:	687b      	ldr	r3, [r7, #4]
    2970:	681b      	ldr	r3, [r3, #0]
    2972:	4a09      	ldr	r2, [pc, #36]	; (2998 <_mac_init_bufdescr+0xe0>)
    2974:	4611      	mov	r1, r2
    2976:	4618      	mov	r0, r3
    2978:	4b0a      	ldr	r3, [pc, #40]	; (29a4 <_mac_init_bufdescr+0xec>)
    297a:	4798      	blx	r3
}
    297c:	bf00      	nop
    297e:	3710      	adds	r7, #16
    2980:	46bd      	mov	sp, r7
    2982:	bd80      	pop	{r7, pc}
    2984:	200001a0 	.word	0x200001a0
    2988:	20000100 	.word	0x20000100
    298c:	20001564 	.word	0x20001564
    2990:	20001568 	.word	0x20001568
    2994:	20000d60 	.word	0x20000d60
    2998:	20000110 	.word	0x20000110
    299c:	2000156c 	.word	0x2000156c
    29a0:	00002813 	.word	0x00002813
    29a4:	000027f7 	.word	0x000027f7

000029a8 <GMAC_Handler>:

/*
 * \internal GMAC interrupt handler
 */
void GMAC_Handler(void)
{
    29a8:	b580      	push	{r7, lr}
    29aa:	b082      	sub	sp, #8
    29ac:	af00      	add	r7, sp, #0
	volatile uint32_t tsr;
	volatile uint32_t rsr;

	tsr = hri_gmac_read_TSR_reg(_gmac_dev->hw);
    29ae:	4b2b      	ldr	r3, [pc, #172]	; (2a5c <GMAC_Handler+0xb4>)
    29b0:	681b      	ldr	r3, [r3, #0]
    29b2:	681b      	ldr	r3, [r3, #0]
    29b4:	4618      	mov	r0, r3
    29b6:	4b2a      	ldr	r3, [pc, #168]	; (2a60 <GMAC_Handler+0xb8>)
    29b8:	4798      	blx	r3
    29ba:	4603      	mov	r3, r0
    29bc:	607b      	str	r3, [r7, #4]
	rsr = hri_gmac_read_RSR_reg(_gmac_dev->hw);
    29be:	4b27      	ldr	r3, [pc, #156]	; (2a5c <GMAC_Handler+0xb4>)
    29c0:	681b      	ldr	r3, [r3, #0]
    29c2:	681b      	ldr	r3, [r3, #0]
    29c4:	4618      	mov	r0, r3
    29c6:	4b27      	ldr	r3, [pc, #156]	; (2a64 <GMAC_Handler+0xbc>)
    29c8:	4798      	blx	r3
    29ca:	4603      	mov	r3, r0
    29cc:	603b      	str	r3, [r7, #0]
	/* Must be Clear ISR (Clear on read) */
	hri_gmac_read_ISR_reg(_gmac_dev->hw);
    29ce:	4b23      	ldr	r3, [pc, #140]	; (2a5c <GMAC_Handler+0xb4>)
    29d0:	681b      	ldr	r3, [r3, #0]
    29d2:	681b      	ldr	r3, [r3, #0]
    29d4:	4618      	mov	r0, r3
    29d6:	4b24      	ldr	r3, [pc, #144]	; (2a68 <GMAC_Handler+0xc0>)
    29d8:	4798      	blx	r3

	/* Frame transmited */
	if (tsr & GMAC_TSR_TXCOMP) {
    29da:	687b      	ldr	r3, [r7, #4]
    29dc:	f003 0320 	and.w	r3, r3, #32
    29e0:	2b00      	cmp	r3, #0
    29e2:	d01e      	beq.n	2a22 <GMAC_Handler+0x7a>
		hri_gmac_write_TSR_reg(_gmac_dev->hw, tsr);
    29e4:	4b1d      	ldr	r3, [pc, #116]	; (2a5c <GMAC_Handler+0xb4>)
    29e6:	681b      	ldr	r3, [r3, #0]
    29e8:	681b      	ldr	r3, [r3, #0]
    29ea:	687a      	ldr	r2, [r7, #4]
    29ec:	4611      	mov	r1, r2
    29ee:	4618      	mov	r0, r3
    29f0:	4b1e      	ldr	r3, [pc, #120]	; (2a6c <GMAC_Handler+0xc4>)
    29f2:	4798      	blx	r3
		if ((_txbuf_descrs[_txbuf_index].status.bm.used) && (_gmac_dev->cb.transmited != NULL)) {
    29f4:	4b1e      	ldr	r3, [pc, #120]	; (2a70 <GMAC_Handler+0xc8>)
    29f6:	681b      	ldr	r3, [r3, #0]
    29f8:	4a1e      	ldr	r2, [pc, #120]	; (2a74 <GMAC_Handler+0xcc>)
    29fa:	00db      	lsls	r3, r3, #3
    29fc:	4413      	add	r3, r2
    29fe:	79db      	ldrb	r3, [r3, #7]
    2a00:	f3c3 13c0 	ubfx	r3, r3, #7, #1
    2a04:	b2db      	uxtb	r3, r3
    2a06:	2b00      	cmp	r3, #0
    2a08:	d00b      	beq.n	2a22 <GMAC_Handler+0x7a>
    2a0a:	4b14      	ldr	r3, [pc, #80]	; (2a5c <GMAC_Handler+0xb4>)
    2a0c:	681b      	ldr	r3, [r3, #0]
    2a0e:	685b      	ldr	r3, [r3, #4]
    2a10:	2b00      	cmp	r3, #0
    2a12:	d006      	beq.n	2a22 <GMAC_Handler+0x7a>
			_gmac_dev->cb.transmited(_gmac_dev);
    2a14:	4b11      	ldr	r3, [pc, #68]	; (2a5c <GMAC_Handler+0xb4>)
    2a16:	681b      	ldr	r3, [r3, #0]
    2a18:	685b      	ldr	r3, [r3, #4]
    2a1a:	4a10      	ldr	r2, [pc, #64]	; (2a5c <GMAC_Handler+0xb4>)
    2a1c:	6812      	ldr	r2, [r2, #0]
    2a1e:	4610      	mov	r0, r2
    2a20:	4798      	blx	r3
		}
	}

	/* Frame received */
	if (rsr & GMAC_RSR_REC) {
    2a22:	683b      	ldr	r3, [r7, #0]
    2a24:	f003 0302 	and.w	r3, r3, #2
    2a28:	2b00      	cmp	r3, #0
    2a2a:	d00b      	beq.n	2a44 <GMAC_Handler+0x9c>
		if (_gmac_dev->cb.received != NULL) {
    2a2c:	4b0b      	ldr	r3, [pc, #44]	; (2a5c <GMAC_Handler+0xb4>)
    2a2e:	681b      	ldr	r3, [r3, #0]
    2a30:	689b      	ldr	r3, [r3, #8]
    2a32:	2b00      	cmp	r3, #0
    2a34:	d006      	beq.n	2a44 <GMAC_Handler+0x9c>
			_gmac_dev->cb.received(_gmac_dev);
    2a36:	4b09      	ldr	r3, [pc, #36]	; (2a5c <GMAC_Handler+0xb4>)
    2a38:	681b      	ldr	r3, [r3, #0]
    2a3a:	689b      	ldr	r3, [r3, #8]
    2a3c:	4a07      	ldr	r2, [pc, #28]	; (2a5c <GMAC_Handler+0xb4>)
    2a3e:	6812      	ldr	r2, [r2, #0]
    2a40:	4610      	mov	r0, r2
    2a42:	4798      	blx	r3
		}
	}
	hri_gmac_write_RSR_reg(_gmac_dev->hw, rsr);
    2a44:	4b05      	ldr	r3, [pc, #20]	; (2a5c <GMAC_Handler+0xb4>)
    2a46:	681b      	ldr	r3, [r3, #0]
    2a48:	681b      	ldr	r3, [r3, #0]
    2a4a:	683a      	ldr	r2, [r7, #0]
    2a4c:	4611      	mov	r1, r2
    2a4e:	4618      	mov	r0, r3
    2a50:	4b09      	ldr	r3, [pc, #36]	; (2a78 <GMAC_Handler+0xd0>)
    2a52:	4798      	blx	r3
}
    2a54:	bf00      	nop
    2a56:	3708      	adds	r7, #8
    2a58:	46bd      	mov	sp, r7
    2a5a:	bd80      	pop	{r7, pc}
    2a5c:	20001560 	.word	0x20001560
    2a60:	000027df 	.word	0x000027df
    2a64:	0000284b 	.word	0x0000284b
    2a68:	00002863 	.word	0x00002863
    2a6c:	000027c3 	.word	0x000027c3
    2a70:	20001564 	.word	0x20001564
    2a74:	20000100 	.word	0x20000100
    2a78:	0000282f 	.word	0x0000282f

00002a7c <_mac_async_init>:

int32_t _mac_async_init(struct _mac_async_device *const dev, void *const hw)
{
    2a7c:	b580      	push	{r7, lr}
    2a7e:	b082      	sub	sp, #8
    2a80:	af00      	add	r7, sp, #0
    2a82:	6078      	str	r0, [r7, #4]
    2a84:	6039      	str	r1, [r7, #0]
	dev->hw = hw;
    2a86:	687b      	ldr	r3, [r7, #4]
    2a88:	683a      	ldr	r2, [r7, #0]
    2a8a:	601a      	str	r2, [r3, #0]
	hri_gmac_write_NCR_reg(dev->hw,
    2a8c:	687b      	ldr	r3, [r7, #4]
    2a8e:	681b      	ldr	r3, [r3, #0]
    2a90:	2110      	movs	r1, #16
    2a92:	4618      	mov	r0, r3
    2a94:	4b1a      	ldr	r3, [pc, #104]	; (2b00 <_mac_async_init+0x84>)
    2a96:	4798      	blx	r3
	                       (CONF_GMAC_NCR_LBL ? GMAC_NCR_LBL : 0) | (CONF_GMAC_NCR_MPE ? GMAC_NCR_MPE : 0)
	                           | (CONF_GMAC_NCR_WESTAT ? GMAC_NCR_WESTAT : 0) | (CONF_GMAC_NCR_BP ? GMAC_NCR_BP : 0)
	                           | (CONF_GMAC_NCR_ENPBPR ? GMAC_NCR_ENPBPR : 0)
	                           | (CONF_GMAC_NCR_TXPBPF ? GMAC_NCR_TXPBPF : 0));
	hri_gmac_write_NCFGR_reg(
	    dev->hw,
    2a98:	687b      	ldr	r3, [r7, #4]
    2a9a:	681b      	ldr	r3, [r3, #0]
	hri_gmac_write_NCFGR_reg(
    2a9c:	4919      	ldr	r1, [pc, #100]	; (2b04 <_mac_async_init+0x88>)
    2a9e:	4618      	mov	r0, r3
    2aa0:	4b19      	ldr	r3, [pc, #100]	; (2b08 <_mac_async_init+0x8c>)
    2aa2:	4798      	blx	r3
	        | (CONF_GMAC_NCFGR_LFERD ? GMAC_NCFGR_LFERD : 0) | (CONF_GMAC_NCFGR_RFCS ? GMAC_NCFGR_RFCS : 0)
	        | GMAC_NCFGR_CLK(CONF_GMAC_NCFGR_CLK) | (CONF_GMAC_NCFGR_DCPF ? GMAC_NCFGR_DCPF : 0)
	        | (CONF_GMAC_NCFGR_RXCOEN ? GMAC_NCFGR_RXCOEN : 0) | (CONF_GMAC_NCFGR_EFRHD ? GMAC_NCFGR_EFRHD : 0)
	        | (CONF_GMAC_NCFGR_IRXFCS ? GMAC_NCFGR_IRXFCS : 0) | (CONF_GMAC_NCFGR_IPGSEN ? GMAC_NCFGR_IPGSEN : 0)
	        | (CONF_GMAC_NCFGR_RXBP ? GMAC_NCFGR_RXBP : 0) | (CONF_GMAC_NCFGR_IRXER ? GMAC_NCFGR_IRXER : 0));
	hri_gmac_write_UR_reg(dev->hw, (CONF_GMAC_UR_MII ? GMAC_UR_MII : 0));
    2aa4:	687b      	ldr	r3, [r7, #4]
    2aa6:	681b      	ldr	r3, [r3, #0]
    2aa8:	2100      	movs	r1, #0
    2aaa:	4618      	mov	r0, r3
    2aac:	4b17      	ldr	r3, [pc, #92]	; (2b0c <_mac_async_init+0x90>)
    2aae:	4798      	blx	r3
	hri_gmac_write_DCFGR_reg(
	    dev->hw,
    2ab0:	687b      	ldr	r3, [r7, #4]
    2ab2:	681b      	ldr	r3, [r3, #0]
	hri_gmac_write_DCFGR_reg(
    2ab4:	4916      	ldr	r1, [pc, #88]	; (2b10 <_mac_async_init+0x94>)
    2ab6:	4618      	mov	r0, r3
    2ab8:	4b16      	ldr	r3, [pc, #88]	; (2b14 <_mac_async_init+0x98>)
    2aba:	4798      	blx	r3
	    GMAC_DCFGR_FBLDO(CONF_GMAC_DCFGR_FBLDO) | (CONF_GMAC_DCFGR_ESMA ? GMAC_DCFGR_ESMA : 0)
	        | (CONF_GMAC_DCFGR_ESPA ? GMAC_DCFGR_ESPA : 0) | GMAC_DCFGR_RXBMS(CONF_GMAC_DCFGR_RXBMS)
	        | (CONF_GMAC_DCFGR_TXPBMS ? GMAC_DCFGR_TXPBMS : 0) | (CONF_GMAC_DCFGR_TXCOEN ? GMAC_DCFGR_TXCOEN : 0)
	        | GMAC_DCFGR_DRBS(CONF_GMAC_DCFGR_DRBS) | (CONF_GMAC_DCFGR_DDRP ? GMAC_DCFGR_DDRP : 0));
	hri_gmac_write_WOL_reg(dev->hw, 0);
    2abc:	687b      	ldr	r3, [r7, #4]
    2abe:	681b      	ldr	r3, [r3, #0]
    2ac0:	2100      	movs	r1, #0
    2ac2:	4618      	mov	r0, r3
    2ac4:	4b14      	ldr	r3, [pc, #80]	; (2b18 <_mac_async_init+0x9c>)
    2ac6:	4798      	blx	r3
	hri_gmac_write_IPGS_reg(dev->hw, GMAC_IPGS_FL((CONF_GMAC_IPGS_FL_MUL << 8) | CONF_GMAC_IPGS_FL_DIV));
    2ac8:	687b      	ldr	r3, [r7, #4]
    2aca:	681b      	ldr	r3, [r3, #0]
    2acc:	f240 1101 	movw	r1, #257	; 0x101
    2ad0:	4618      	mov	r0, r3
    2ad2:	4b12      	ldr	r3, [pc, #72]	; (2b1c <_mac_async_init+0xa0>)
    2ad4:	4798      	blx	r3
	_mac_init_bufdescr(dev);
    2ad6:	6878      	ldr	r0, [r7, #4]
    2ad8:	4b11      	ldr	r3, [pc, #68]	; (2b20 <_mac_async_init+0xa4>)
    2ada:	4798      	blx	r3

	_gmac_dev = dev;
    2adc:	4a11      	ldr	r2, [pc, #68]	; (2b24 <_mac_async_init+0xa8>)
    2ade:	687b      	ldr	r3, [r7, #4]
    2ae0:	6013      	str	r3, [r2, #0]
	NVIC_DisableIRQ(GMAC_IRQn);
    2ae2:	2054      	movs	r0, #84	; 0x54
    2ae4:	4b10      	ldr	r3, [pc, #64]	; (2b28 <_mac_async_init+0xac>)
    2ae6:	4798      	blx	r3
	NVIC_ClearPendingIRQ(GMAC_IRQn);
    2ae8:	2054      	movs	r0, #84	; 0x54
    2aea:	4b10      	ldr	r3, [pc, #64]	; (2b2c <_mac_async_init+0xb0>)
    2aec:	4798      	blx	r3
	NVIC_EnableIRQ(GMAC_IRQn);
    2aee:	2054      	movs	r0, #84	; 0x54
    2af0:	4b0f      	ldr	r3, [pc, #60]	; (2b30 <_mac_async_init+0xb4>)
    2af2:	4798      	blx	r3

	return ERR_NONE;
    2af4:	2300      	movs	r3, #0
}
    2af6:	4618      	mov	r0, r3
    2af8:	3708      	adds	r7, #8
    2afa:	46bd      	mov	sp, r7
    2afc:	bd80      	pop	{r7, pc}
    2afe:	bf00      	nop
    2b00:	00002753 	.word	0x00002753
    2b04:	00100103 	.word	0x00100103
    2b08:	0000276f 	.word	0x0000276f
    2b0c:	0000278b 	.word	0x0000278b
    2b10:	00020704 	.word	0x00020704
    2b14:	000027a7 	.word	0x000027a7
    2b18:	0000287b 	.word	0x0000287b
    2b1c:	00002899 	.word	0x00002899
    2b20:	000028b9 	.word	0x000028b9
    2b24:	20001560 	.word	0x20001560
    2b28:	000026b1 	.word	0x000026b1
    2b2c:	000026f5 	.word	0x000026f5
    2b30:	00002675 	.word	0x00002675

00002b34 <_mac_async_enable>:

	return ERR_NONE;
}

int32_t _mac_async_enable(struct _mac_async_device *const dev)
{
    2b34:	b580      	push	{r7, lr}
    2b36:	b082      	sub	sp, #8
    2b38:	af00      	add	r7, sp, #0
    2b3a:	6078      	str	r0, [r7, #4]
	hri_gmac_set_NCR_reg(dev->hw, GMAC_NCR_RXEN | GMAC_NCR_TXEN);
    2b3c:	687b      	ldr	r3, [r7, #4]
    2b3e:	681b      	ldr	r3, [r3, #0]
    2b40:	210c      	movs	r1, #12
    2b42:	4618      	mov	r0, r3
    2b44:	4b03      	ldr	r3, [pc, #12]	; (2b54 <_mac_async_enable+0x20>)
    2b46:	4798      	blx	r3
	return ERR_NONE;
    2b48:	2300      	movs	r3, #0
}
    2b4a:	4618      	mov	r0, r3
    2b4c:	3708      	adds	r7, #8
    2b4e:	46bd      	mov	sp, r7
    2b50:	bd80      	pop	{r7, pc}
    2b52:	bf00      	nop
    2b54:	00002731 	.word	0x00002731

00002b58 <hri_mclk_write_CPUDIV_reg>:
{
    2b58:	b480      	push	{r7}
    2b5a:	b083      	sub	sp, #12
    2b5c:	af00      	add	r7, sp, #0
    2b5e:	6078      	str	r0, [r7, #4]
    2b60:	460b      	mov	r3, r1
    2b62:	70fb      	strb	r3, [r7, #3]
	((Mclk *)hw)->CPUDIV.reg = data;
    2b64:	687b      	ldr	r3, [r7, #4]
    2b66:	78fa      	ldrb	r2, [r7, #3]
    2b68:	715a      	strb	r2, [r3, #5]
}
    2b6a:	bf00      	nop
    2b6c:	370c      	adds	r7, #12
    2b6e:	46bd      	mov	sp, r7
    2b70:	f85d 7b04 	ldr.w	r7, [sp], #4
    2b74:	4770      	bx	lr
	...

00002b78 <_mclk_init>:

/**
 * \brief Initialize master clock generator
 */
void _mclk_init(void)
{
    2b78:	b580      	push	{r7, lr}
    2b7a:	b082      	sub	sp, #8
    2b7c:	af00      	add	r7, sp, #0
	void *hw = (void *)MCLK;
    2b7e:	4b05      	ldr	r3, [pc, #20]	; (2b94 <_mclk_init+0x1c>)
    2b80:	607b      	str	r3, [r7, #4]
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
    2b82:	2101      	movs	r1, #1
    2b84:	6878      	ldr	r0, [r7, #4]
    2b86:	4b04      	ldr	r3, [pc, #16]	; (2b98 <_mclk_init+0x20>)
    2b88:	4798      	blx	r3
}
    2b8a:	bf00      	nop
    2b8c:	3708      	adds	r7, #8
    2b8e:	46bd      	mov	sp, r7
    2b90:	bd80      	pop	{r7, pc}
    2b92:	bf00      	nop
    2b94:	40000800 	.word	0x40000800
    2b98:	00002b59 	.word	0x00002b59

00002b9c <hri_osc32kctrl_write_RTCCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_RTCCTRL_reg(const void *const hw, hri_osc32kctrl_rtcctrl_reg_t data)
{
    2b9c:	b480      	push	{r7}
    2b9e:	b083      	sub	sp, #12
    2ba0:	af00      	add	r7, sp, #0
    2ba2:	6078      	str	r0, [r7, #4]
    2ba4:	460b      	mov	r3, r1
    2ba6:	70fb      	strb	r3, [r7, #3]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    2ba8:	687b      	ldr	r3, [r7, #4]
    2baa:	78fa      	ldrb	r2, [r7, #3]
    2bac:	741a      	strb	r2, [r3, #16]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
    2bae:	bf00      	nop
    2bb0:	370c      	adds	r7, #12
    2bb2:	46bd      	mov	sp, r7
    2bb4:	f85d 7b04 	ldr.w	r7, [sp], #4
    2bb8:	4770      	bx	lr

00002bba <hri_osc32kctrl_read_OSCULP32K_CALIB_bf>:
	((Osc32kctrl *)hw)->OSCULP32K.reg ^= OSC32KCTRL_OSCULP32K_CALIB(mask);
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
    2bba:	b480      	push	{r7}
    2bbc:	b085      	sub	sp, #20
    2bbe:	af00      	add	r7, sp, #0
    2bc0:	6078      	str	r0, [r7, #4]
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    2bc2:	687b      	ldr	r3, [r7, #4]
    2bc4:	69db      	ldr	r3, [r3, #28]
    2bc6:	60fb      	str	r3, [r7, #12]
	tmp = (tmp & OSC32KCTRL_OSCULP32K_CALIB_Msk) >> OSC32KCTRL_OSCULP32K_CALIB_Pos;
    2bc8:	68fb      	ldr	r3, [r7, #12]
    2bca:	0a1b      	lsrs	r3, r3, #8
    2bcc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    2bd0:	60fb      	str	r3, [r7, #12]
	return tmp;
    2bd2:	68fb      	ldr	r3, [r7, #12]
}
    2bd4:	4618      	mov	r0, r3
    2bd6:	3714      	adds	r7, #20
    2bd8:	46bd      	mov	sp, r7
    2bda:	f85d 7b04 	ldr.w	r7, [sp], #4
    2bde:	4770      	bx	lr

00002be0 <hri_osc32kctrl_write_OSCULP32K_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
    2be0:	b480      	push	{r7}
    2be2:	b083      	sub	sp, #12
    2be4:	af00      	add	r7, sp, #0
    2be6:	6078      	str	r0, [r7, #4]
    2be8:	6039      	str	r1, [r7, #0]
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    2bea:	687b      	ldr	r3, [r7, #4]
    2bec:	683a      	ldr	r2, [r7, #0]
    2bee:	61da      	str	r2, [r3, #28]
	OSC32KCTRL_CRITICAL_SECTION_LEAVE();
}
    2bf0:	bf00      	nop
    2bf2:	370c      	adds	r7, #12
    2bf4:	46bd      	mov	sp, r7
    2bf6:	f85d 7b04 	ldr.w	r7, [sp], #4
    2bfa:	4770      	bx	lr

00002bfc <_osc32kctrl_init_sources>:

/**
 * \brief Initialize 32 kHz clock sources
 */
void _osc32kctrl_init_sources(void)
{
    2bfc:	b580      	push	{r7, lr}
    2bfe:	b082      	sub	sp, #8
    2c00:	af00      	add	r7, sp, #0
	void *   hw    = (void *)OSC32KCTRL;
    2c02:	4b0c      	ldr	r3, [pc, #48]	; (2c34 <_osc32kctrl_init_sources+0x38>)
    2c04:	607b      	str	r3, [r7, #4]
	uint16_t calib = 0;
    2c06:	2300      	movs	r3, #0
    2c08:	807b      	strh	r3, [r7, #2]

	hri_osc32kctrl_write_EVCTRL_reg(hw, (CONF_XOSC32K_CFDEO << OSC32KCTRL_EVCTRL_CFDEO_Pos));
#endif

#if CONF_OSCULP32K_CONFIG == 1
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
    2c0a:	6878      	ldr	r0, [r7, #4]
    2c0c:	4b0a      	ldr	r3, [pc, #40]	; (2c38 <_osc32kctrl_init_sources+0x3c>)
    2c0e:	4798      	blx	r3
    2c10:	4603      	mov	r3, r0
    2c12:	807b      	strh	r3, [r7, #2]
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    2c14:	887b      	ldrh	r3, [r7, #2]
    2c16:	021b      	lsls	r3, r3, #8
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
    2c18:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
    2c1c:	4619      	mov	r1, r3
    2c1e:	6878      	ldr	r0, [r7, #4]
    2c20:	4b06      	ldr	r3, [pc, #24]	; (2c3c <_osc32kctrl_init_sources+0x40>)
    2c22:	4798      	blx	r3
	while (!hri_osc32kctrl_get_STATUS_XOSC32KRDY_bit(hw))
		;
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
    2c24:	2101      	movs	r1, #1
    2c26:	6878      	ldr	r0, [r7, #4]
    2c28:	4b05      	ldr	r3, [pc, #20]	; (2c40 <_osc32kctrl_init_sources+0x44>)
    2c2a:	4798      	blx	r3
	(void)calib;
}
    2c2c:	bf00      	nop
    2c2e:	3708      	adds	r7, #8
    2c30:	46bd      	mov	sp, r7
    2c32:	bd80      	pop	{r7, pc}
    2c34:	40001400 	.word	0x40001400
    2c38:	00002bbb 	.word	0x00002bbb
    2c3c:	00002be1 	.word	0x00002be1
    2c40:	00002b9d 	.word	0x00002b9d

00002c44 <hri_oscctrl_get_STATUS_XOSCRDY1_bit>:
{
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY0) >> OSCCTRL_STATUS_XOSCRDY0_Pos;
}

static inline bool hri_oscctrl_get_STATUS_XOSCRDY1_bit(const void *const hw)
{
    2c44:	b480      	push	{r7}
    2c46:	b083      	sub	sp, #12
    2c48:	af00      	add	r7, sp, #0
    2c4a:	6078      	str	r0, [r7, #4]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
    2c4c:	687b      	ldr	r3, [r7, #4]
    2c4e:	691b      	ldr	r3, [r3, #16]
    2c50:	085b      	lsrs	r3, r3, #1
    2c52:	f003 0301 	and.w	r3, r3, #1
    2c56:	2b00      	cmp	r3, #0
    2c58:	bf14      	ite	ne
    2c5a:	2301      	movne	r3, #1
    2c5c:	2300      	moveq	r3, #0
    2c5e:	b2db      	uxtb	r3, r3
}
    2c60:	4618      	mov	r0, r3
    2c62:	370c      	adds	r7, #12
    2c64:	46bd      	mov	sp, r7
    2c66:	f85d 7b04 	ldr.w	r7, [sp], #4
    2c6a:	4770      	bx	lr

00002c6c <hri_oscctrl_write_XOSCCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
    2c6c:	b480      	push	{r7}
    2c6e:	b085      	sub	sp, #20
    2c70:	af00      	add	r7, sp, #0
    2c72:	60f8      	str	r0, [r7, #12]
    2c74:	460b      	mov	r3, r1
    2c76:	607a      	str	r2, [r7, #4]
    2c78:	72fb      	strb	r3, [r7, #11]
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
    2c7a:	7afb      	ldrb	r3, [r7, #11]
    2c7c:	68fa      	ldr	r2, [r7, #12]
    2c7e:	3304      	adds	r3, #4
    2c80:	009b      	lsls	r3, r3, #2
    2c82:	4413      	add	r3, r2
    2c84:	687a      	ldr	r2, [r7, #4]
    2c86:	605a      	str	r2, [r3, #4]
	OSCCTRL_CRITICAL_SECTION_LEAVE();
}
    2c88:	bf00      	nop
    2c8a:	3714      	adds	r7, #20
    2c8c:	46bd      	mov	sp, r7
    2c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
    2c92:	4770      	bx	lr

00002c94 <_oscctrl_init_sources>:

/**
 * \brief Initialize clock sources
 */
void _oscctrl_init_sources(void)
{
    2c94:	b580      	push	{r7, lr}
    2c96:	b082      	sub	sp, #8
    2c98:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
    2c9a:	4b0a      	ldr	r3, [pc, #40]	; (2cc4 <_oscctrl_init_sources+0x30>)
    2c9c:	607b      	str	r3, [r7, #4]
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 0);
#endif
#endif

#if CONF_XOSC1_CONFIG == 1
	hri_oscctrl_write_XOSCCTRL_reg(
    2c9e:	4a0a      	ldr	r2, [pc, #40]	; (2cc8 <_oscctrl_init_sources+0x34>)
    2ca0:	2101      	movs	r1, #1
    2ca2:	6878      	ldr	r0, [r7, #4]
    2ca4:	4b09      	ldr	r3, [pc, #36]	; (2ccc <_oscctrl_init_sources+0x38>)
    2ca6:	4798      	blx	r3
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
    2ca8:	bf00      	nop
    2caa:	6878      	ldr	r0, [r7, #4]
    2cac:	4b08      	ldr	r3, [pc, #32]	; (2cd0 <_oscctrl_init_sources+0x3c>)
    2cae:	4798      	blx	r3
    2cb0:	4603      	mov	r3, r0
    2cb2:	f083 0301 	eor.w	r3, r3, #1
    2cb6:	b2db      	uxtb	r3, r3
    2cb8:	2b00      	cmp	r3, #0
    2cba:	d1f6      	bne.n	2caa <_oscctrl_init_sources+0x16>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    2cbc:	bf00      	nop
    2cbe:	3708      	adds	r7, #8
    2cc0:	46bd      	mov	sp, r7
    2cc2:	bd80      	pop	{r7, pc}
    2cc4:	40001000 	.word	0x40001000
    2cc8:	03002606 	.word	0x03002606
    2ccc:	00002c6d 	.word	0x00002c6d
    2cd0:	00002c45 	.word	0x00002c45

00002cd4 <_oscctrl_init_referenced_generators>:

void _oscctrl_init_referenced_generators(void)
{
    2cd4:	b480      	push	{r7}
    2cd6:	b083      	sub	sp, #12
    2cd8:	af00      	add	r7, sp, #0
	void *hw = (void *)OSCCTRL;
    2cda:	4b04      	ldr	r3, [pc, #16]	; (2cec <_oscctrl_init_referenced_generators+0x18>)
    2cdc:	607b      	str	r3, [r7, #4]
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
		;
#endif
	(void)hw;
}
    2cde:	bf00      	nop
    2ce0:	370c      	adds	r7, #12
    2ce2:	46bd      	mov	sp, r7
    2ce4:	f85d 7b04 	ldr.w	r7, [sp], #4
    2ce8:	4770      	bx	lr
    2cea:	bf00      	nop
    2cec:	40001000 	.word	0x40001000

00002cf0 <hri_ramecc_read_INTFLAG_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
    2cf0:	b480      	push	{r7}
    2cf2:	b083      	sub	sp, #12
    2cf4:	af00      	add	r7, sp, #0
    2cf6:	6078      	str	r0, [r7, #4]
	return ((Ramecc *)hw)->INTFLAG.reg;
    2cf8:	687b      	ldr	r3, [r7, #4]
    2cfa:	789b      	ldrb	r3, [r3, #2]
    2cfc:	b2db      	uxtb	r3, r3
}
    2cfe:	4618      	mov	r0, r3
    2d00:	370c      	adds	r7, #12
    2d02:	46bd      	mov	sp, r7
    2d04:	f85d 7b04 	ldr.w	r7, [sp], #4
    2d08:	4770      	bx	lr

00002d0a <hri_ramecc_read_ERRADDR_reg>:
	tmp &= mask;
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
    2d0a:	b480      	push	{r7}
    2d0c:	b083      	sub	sp, #12
    2d0e:	af00      	add	r7, sp, #0
    2d10:	6078      	str	r0, [r7, #4]
	return ((Ramecc *)hw)->ERRADDR.reg;
    2d12:	687b      	ldr	r3, [r7, #4]
    2d14:	685b      	ldr	r3, [r3, #4]
}
    2d16:	4618      	mov	r0, r3
    2d18:	370c      	adds	r7, #12
    2d1a:	46bd      	mov	sp, r7
    2d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2d20:	4770      	bx	lr
	...

00002d24 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    2d24:	b590      	push	{r4, r7, lr}
    2d26:	b083      	sub	sp, #12
    2d28:	af00      	add	r7, sp, #0
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
    2d2a:	4b17      	ldr	r3, [pc, #92]	; (2d88 <RAMECC_Handler+0x64>)
    2d2c:	607b      	str	r3, [r7, #4]
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    2d2e:	4817      	ldr	r0, [pc, #92]	; (2d8c <RAMECC_Handler+0x68>)
    2d30:	4b17      	ldr	r3, [pc, #92]	; (2d90 <RAMECC_Handler+0x6c>)
    2d32:	4798      	blx	r3
    2d34:	4603      	mov	r3, r0
    2d36:	603b      	str	r3, [r7, #0]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    2d38:	683b      	ldr	r3, [r7, #0]
    2d3a:	f003 0302 	and.w	r3, r3, #2
    2d3e:	2b00      	cmp	r3, #0
    2d40:	d00c      	beq.n	2d5c <RAMECC_Handler+0x38>
    2d42:	687b      	ldr	r3, [r7, #4]
    2d44:	681b      	ldr	r3, [r3, #0]
    2d46:	2b00      	cmp	r3, #0
    2d48:	d008      	beq.n	2d5c <RAMECC_Handler+0x38>
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    2d4a:	687b      	ldr	r3, [r7, #4]
    2d4c:	681c      	ldr	r4, [r3, #0]
    2d4e:	480f      	ldr	r0, [pc, #60]	; (2d8c <RAMECC_Handler+0x68>)
    2d50:	4b10      	ldr	r3, [pc, #64]	; (2d94 <RAMECC_Handler+0x70>)
    2d52:	4798      	blx	r3
    2d54:	4603      	mov	r3, r0
    2d56:	4618      	mov	r0, r3
    2d58:	47a0      	blx	r4
    2d5a:	e012      	b.n	2d82 <RAMECC_Handler+0x5e>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    2d5c:	683b      	ldr	r3, [r7, #0]
    2d5e:	f003 0301 	and.w	r3, r3, #1
    2d62:	2b00      	cmp	r3, #0
    2d64:	d00c      	beq.n	2d80 <RAMECC_Handler+0x5c>
    2d66:	687b      	ldr	r3, [r7, #4]
    2d68:	685b      	ldr	r3, [r3, #4]
    2d6a:	2b00      	cmp	r3, #0
    2d6c:	d008      	beq.n	2d80 <RAMECC_Handler+0x5c>
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    2d6e:	687b      	ldr	r3, [r7, #4]
    2d70:	685c      	ldr	r4, [r3, #4]
    2d72:	4806      	ldr	r0, [pc, #24]	; (2d8c <RAMECC_Handler+0x68>)
    2d74:	4b07      	ldr	r3, [pc, #28]	; (2d94 <RAMECC_Handler+0x70>)
    2d76:	4798      	blx	r3
    2d78:	4603      	mov	r3, r0
    2d7a:	4618      	mov	r0, r3
    2d7c:	47a0      	blx	r4
    2d7e:	e000      	b.n	2d82 <RAMECC_Handler+0x5e>
	} else {
		return;
    2d80:	bf00      	nop
	}
}
    2d82:	370c      	adds	r7, #12
    2d84:	46bd      	mov	sp, r7
    2d86:	bd90      	pop	{r4, r7, pc}
    2d88:	2000173c 	.word	0x2000173c
    2d8c:	41020000 	.word	0x41020000
    2d90:	00002cf1 	.word	0x00002cf1
    2d94:	00002d0b 	.word	0x00002d0b

00002d98 <hri_sercomusart_wait_for_sync>:
{
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
    2d98:	b480      	push	{r7}
    2d9a:	b083      	sub	sp, #12
    2d9c:	af00      	add	r7, sp, #0
    2d9e:	6078      	str	r0, [r7, #4]
    2da0:	6039      	str	r1, [r7, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
    2da2:	bf00      	nop
    2da4:	687b      	ldr	r3, [r7, #4]
    2da6:	69da      	ldr	r2, [r3, #28]
    2da8:	683b      	ldr	r3, [r7, #0]
    2daa:	4013      	ands	r3, r2
    2dac:	2b00      	cmp	r3, #0
    2dae:	d1f9      	bne.n	2da4 <hri_sercomusart_wait_for_sync+0xc>
	};
}
    2db0:	bf00      	nop
    2db2:	370c      	adds	r7, #12
    2db4:	46bd      	mov	sp, r7
    2db6:	f85d 7b04 	ldr.w	r7, [sp], #4
    2dba:	4770      	bx	lr

00002dbc <hri_sercomusart_is_syncing>:

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
    2dbc:	b480      	push	{r7}
    2dbe:	b083      	sub	sp, #12
    2dc0:	af00      	add	r7, sp, #0
    2dc2:	6078      	str	r0, [r7, #4]
    2dc4:	6039      	str	r1, [r7, #0]
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
    2dc6:	687b      	ldr	r3, [r7, #4]
    2dc8:	69da      	ldr	r2, [r3, #28]
    2dca:	683b      	ldr	r3, [r7, #0]
    2dcc:	4013      	ands	r3, r2
    2dce:	2b00      	cmp	r3, #0
    2dd0:	bf14      	ite	ne
    2dd2:	2301      	movne	r3, #1
    2dd4:	2300      	moveq	r3, #0
    2dd6:	b2db      	uxtb	r3, r3
}
    2dd8:	4618      	mov	r0, r3
    2dda:	370c      	adds	r7, #12
    2ddc:	46bd      	mov	sp, r7
    2dde:	f85d 7b04 	ldr.w	r7, [sp], #4
    2de2:	4770      	bx	lr

00002de4 <hri_sercomusart_get_interrupt_DRE_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
}

static inline bool hri_sercomusart_get_interrupt_DRE_bit(const void *const hw)
{
    2de4:	b480      	push	{r7}
    2de6:	b083      	sub	sp, #12
    2de8:	af00      	add	r7, sp, #0
    2dea:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
    2dec:	687b      	ldr	r3, [r7, #4]
    2dee:	7e1b      	ldrb	r3, [r3, #24]
    2df0:	b2db      	uxtb	r3, r3
    2df2:	f003 0301 	and.w	r3, r3, #1
    2df6:	2b00      	cmp	r3, #0
    2df8:	bf14      	ite	ne
    2dfa:	2301      	movne	r3, #1
    2dfc:	2300      	moveq	r3, #0
    2dfe:	b2db      	uxtb	r3, r3
}
    2e00:	4618      	mov	r0, r3
    2e02:	370c      	adds	r7, #12
    2e04:	46bd      	mov	sp, r7
    2e06:	f85d 7b04 	ldr.w	r7, [sp], #4
    2e0a:	4770      	bx	lr

00002e0c <hri_sercomusart_get_interrupt_TXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_DRE;
}

static inline bool hri_sercomusart_get_interrupt_TXC_bit(const void *const hw)
{
    2e0c:	b480      	push	{r7}
    2e0e:	b083      	sub	sp, #12
    2e10:	af00      	add	r7, sp, #0
    2e12:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
    2e14:	687b      	ldr	r3, [r7, #4]
    2e16:	7e1b      	ldrb	r3, [r3, #24]
    2e18:	b2db      	uxtb	r3, r3
    2e1a:	085b      	lsrs	r3, r3, #1
    2e1c:	f003 0301 	and.w	r3, r3, #1
    2e20:	2b00      	cmp	r3, #0
    2e22:	bf14      	ite	ne
    2e24:	2301      	movne	r3, #1
    2e26:	2300      	moveq	r3, #0
    2e28:	b2db      	uxtb	r3, r3
}
    2e2a:	4618      	mov	r0, r3
    2e2c:	370c      	adds	r7, #12
    2e2e:	46bd      	mov	sp, r7
    2e30:	f85d 7b04 	ldr.w	r7, [sp], #4
    2e34:	4770      	bx	lr

00002e36 <hri_sercomusart_get_interrupt_RXC_bit>:
{
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_TXC;
}

static inline bool hri_sercomusart_get_interrupt_RXC_bit(const void *const hw)
{
    2e36:	b480      	push	{r7}
    2e38:	b083      	sub	sp, #12
    2e3a:	af00      	add	r7, sp, #0
    2e3c:	6078      	str	r0, [r7, #4]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
    2e3e:	687b      	ldr	r3, [r7, #4]
    2e40:	7e1b      	ldrb	r3, [r3, #24]
    2e42:	b2db      	uxtb	r3, r3
    2e44:	089b      	lsrs	r3, r3, #2
    2e46:	f003 0301 	and.w	r3, r3, #1
    2e4a:	2b00      	cmp	r3, #0
    2e4c:	bf14      	ite	ne
    2e4e:	2301      	movne	r3, #1
    2e50:	2300      	moveq	r3, #0
    2e52:	b2db      	uxtb	r3, r3
}
    2e54:	4618      	mov	r0, r3
    2e56:	370c      	adds	r7, #12
    2e58:	46bd      	mov	sp, r7
    2e5a:	f85d 7b04 	ldr.w	r7, [sp], #4
    2e5e:	4770      	bx	lr

00002e60 <hri_sercomusart_set_CTRLA_ENABLE_bit>:
	tmp = (tmp & SERCOM_USART_CTRLA_SWRST) >> SERCOM_USART_CTRLA_SWRST_Pos;
	return (bool)tmp;
}

static inline void hri_sercomusart_set_CTRLA_ENABLE_bit(const void *const hw)
{
    2e60:	b580      	push	{r7, lr}
    2e62:	b082      	sub	sp, #8
    2e64:	af00      	add	r7, sp, #0
    2e66:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    2e68:	687b      	ldr	r3, [r7, #4]
    2e6a:	681b      	ldr	r3, [r3, #0]
    2e6c:	f043 0202 	orr.w	r2, r3, #2
    2e70:	687b      	ldr	r3, [r7, #4]
    2e72:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    2e74:	2103      	movs	r1, #3
    2e76:	6878      	ldr	r0, [r7, #4]
    2e78:	4b02      	ldr	r3, [pc, #8]	; (2e84 <hri_sercomusart_set_CTRLA_ENABLE_bit+0x24>)
    2e7a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2e7c:	bf00      	nop
    2e7e:	3708      	adds	r7, #8
    2e80:	46bd      	mov	sp, r7
    2e82:	bd80      	pop	{r7, pc}
    2e84:	00002d99 	.word	0x00002d99

00002e88 <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    2e88:	b580      	push	{r7, lr}
    2e8a:	b082      	sub	sp, #8
    2e8c:	af00      	add	r7, sp, #0
    2e8e:	6078      	str	r0, [r7, #4]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    2e90:	687b      	ldr	r3, [r7, #4]
    2e92:	681b      	ldr	r3, [r3, #0]
    2e94:	f023 0202 	bic.w	r2, r3, #2
    2e98:	687b      	ldr	r3, [r7, #4]
    2e9a:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    2e9c:	2103      	movs	r1, #3
    2e9e:	6878      	ldr	r0, [r7, #4]
    2ea0:	4b02      	ldr	r3, [pc, #8]	; (2eac <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x24>)
    2ea2:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2ea4:	bf00      	nop
    2ea6:	3708      	adds	r7, #8
    2ea8:	46bd      	mov	sp, r7
    2eaa:	bd80      	pop	{r7, pc}
    2eac:	00002d99 	.word	0x00002d99

00002eb0 <hri_sercomusart_get_CTRLA_reg>:
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
    2eb0:	b580      	push	{r7, lr}
    2eb2:	b084      	sub	sp, #16
    2eb4:	af00      	add	r7, sp, #0
    2eb6:	6078      	str	r0, [r7, #4]
    2eb8:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    2eba:	2103      	movs	r1, #3
    2ebc:	6878      	ldr	r0, [r7, #4]
    2ebe:	4b07      	ldr	r3, [pc, #28]	; (2edc <hri_sercomusart_get_CTRLA_reg+0x2c>)
    2ec0:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
    2ec2:	687b      	ldr	r3, [r7, #4]
    2ec4:	681b      	ldr	r3, [r3, #0]
    2ec6:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    2ec8:	68fa      	ldr	r2, [r7, #12]
    2eca:	683b      	ldr	r3, [r7, #0]
    2ecc:	4013      	ands	r3, r2
    2ece:	60fb      	str	r3, [r7, #12]
	return tmp;
    2ed0:	68fb      	ldr	r3, [r7, #12]
}
    2ed2:	4618      	mov	r0, r3
    2ed4:	3710      	adds	r7, #16
    2ed6:	46bd      	mov	sp, r7
    2ed8:	bd80      	pop	{r7, pc}
    2eda:	bf00      	nop
    2edc:	00002d99 	.word	0x00002d99

00002ee0 <hri_sercomusart_write_CTRLA_reg>:

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
    2ee0:	b580      	push	{r7, lr}
    2ee2:	b082      	sub	sp, #8
    2ee4:	af00      	add	r7, sp, #0
    2ee6:	6078      	str	r0, [r7, #4]
    2ee8:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
    2eea:	687b      	ldr	r3, [r7, #4]
    2eec:	683a      	ldr	r2, [r7, #0]
    2eee:	601a      	str	r2, [r3, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
    2ef0:	2103      	movs	r1, #3
    2ef2:	6878      	ldr	r0, [r7, #4]
    2ef4:	4b02      	ldr	r3, [pc, #8]	; (2f00 <hri_sercomusart_write_CTRLA_reg+0x20>)
    2ef6:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2ef8:	bf00      	nop
    2efa:	3708      	adds	r7, #8
    2efc:	46bd      	mov	sp, r7
    2efe:	bd80      	pop	{r7, pc}
    2f00:	00002d99 	.word	0x00002d99

00002f04 <hri_sercomusart_write_CTRLB_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
    2f04:	b580      	push	{r7, lr}
    2f06:	b082      	sub	sp, #8
    2f08:	af00      	add	r7, sp, #0
    2f0a:	6078      	str	r0, [r7, #4]
    2f0c:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
    2f0e:	687b      	ldr	r3, [r7, #4]
    2f10:	683a      	ldr	r2, [r7, #0]
    2f12:	605a      	str	r2, [r3, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
    2f14:	211f      	movs	r1, #31
    2f16:	6878      	ldr	r0, [r7, #4]
    2f18:	4b02      	ldr	r3, [pc, #8]	; (2f24 <hri_sercomusart_write_CTRLB_reg+0x20>)
    2f1a:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2f1c:	bf00      	nop
    2f1e:	3708      	adds	r7, #8
    2f20:	46bd      	mov	sp, r7
    2f22:	bd80      	pop	{r7, pc}
    2f24:	00002d99 	.word	0x00002d99

00002f28 <hri_sercomusart_write_CTRLC_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_CTRLC_reg(const void *const hw, hri_sercomusart_ctrlc_reg_t data)
{
    2f28:	b480      	push	{r7}
    2f2a:	b083      	sub	sp, #12
    2f2c:	af00      	add	r7, sp, #0
    2f2e:	6078      	str	r0, [r7, #4]
    2f30:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLC.reg = data;
    2f32:	687b      	ldr	r3, [r7, #4]
    2f34:	683a      	ldr	r2, [r7, #0]
    2f36:	609a      	str	r2, [r3, #8]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2f38:	bf00      	nop
    2f3a:	370c      	adds	r7, #12
    2f3c:	46bd      	mov	sp, r7
    2f3e:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f42:	4770      	bx	lr

00002f44 <hri_sercomusart_write_BAUD_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
    2f44:	b480      	push	{r7}
    2f46:	b083      	sub	sp, #12
    2f48:	af00      	add	r7, sp, #0
    2f4a:	6078      	str	r0, [r7, #4]
    2f4c:	460b      	mov	r3, r1
    2f4e:	807b      	strh	r3, [r7, #2]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
    2f50:	687b      	ldr	r3, [r7, #4]
    2f52:	887a      	ldrh	r2, [r7, #2]
    2f54:	819a      	strh	r2, [r3, #12]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2f56:	bf00      	nop
    2f58:	370c      	adds	r7, #12
    2f5a:	46bd      	mov	sp, r7
    2f5c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f60:	4770      	bx	lr

00002f62 <hri_sercomusart_write_RXPL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
    2f62:	b480      	push	{r7}
    2f64:	b083      	sub	sp, #12
    2f66:	af00      	add	r7, sp, #0
    2f68:	6078      	str	r0, [r7, #4]
    2f6a:	460b      	mov	r3, r1
    2f6c:	70fb      	strb	r3, [r7, #3]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
    2f6e:	687b      	ldr	r3, [r7, #4]
    2f70:	78fa      	ldrb	r2, [r7, #3]
    2f72:	739a      	strb	r2, [r3, #14]
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2f74:	bf00      	nop
    2f76:	370c      	adds	r7, #12
    2f78:	46bd      	mov	sp, r7
    2f7a:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f7e:	4770      	bx	lr

00002f80 <hri_sercomusart_write_DATA_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DATA_reg(const void *const hw, hri_sercomusart_data_reg_t data)
{
    2f80:	b480      	push	{r7}
    2f82:	b083      	sub	sp, #12
    2f84:	af00      	add	r7, sp, #0
    2f86:	6078      	str	r0, [r7, #4]
    2f88:	6039      	str	r1, [r7, #0]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DATA.reg = data;
    2f8a:	687b      	ldr	r3, [r7, #4]
    2f8c:	683a      	ldr	r2, [r7, #0]
    2f8e:	629a      	str	r2, [r3, #40]	; 0x28
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2f90:	bf00      	nop
    2f92:	370c      	adds	r7, #12
    2f94:	46bd      	mov	sp, r7
    2f96:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f9a:	4770      	bx	lr

00002f9c <hri_sercomusart_read_DATA_reg>:
	((Sercom *)hw)->USART.DATA.reg ^= mask;
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_data_reg_t hri_sercomusart_read_DATA_reg(const void *const hw)
{
    2f9c:	b480      	push	{r7}
    2f9e:	b083      	sub	sp, #12
    2fa0:	af00      	add	r7, sp, #0
    2fa2:	6078      	str	r0, [r7, #4]
	return ((Sercom *)hw)->USART.DATA.reg;
    2fa4:	687b      	ldr	r3, [r7, #4]
    2fa6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
    2fa8:	4618      	mov	r0, r3
    2faa:	370c      	adds	r7, #12
    2fac:	46bd      	mov	sp, r7
    2fae:	f85d 7b04 	ldr.w	r7, [sp], #4
    2fb2:	4770      	bx	lr

00002fb4 <hri_sercomusart_write_DBGCTRL_reg>:
	tmp &= mask;
	return tmp;
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
    2fb4:	b480      	push	{r7}
    2fb6:	b083      	sub	sp, #12
    2fb8:	af00      	add	r7, sp, #0
    2fba:	6078      	str	r0, [r7, #4]
    2fbc:	460b      	mov	r3, r1
    2fbe:	70fb      	strb	r3, [r7, #3]
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
    2fc0:	687b      	ldr	r3, [r7, #4]
    2fc2:	78fa      	ldrb	r2, [r7, #3]
    2fc4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	SERCOM_CRITICAL_SECTION_LEAVE();
}
    2fc8:	bf00      	nop
    2fca:	370c      	adds	r7, #12
    2fcc:	46bd      	mov	sp, r7
    2fce:	f85d 7b04 	ldr.w	r7, [sp], #4
    2fd2:	4770      	bx	lr

00002fd4 <_usart_sync_init>:

/**
 * \brief Initialize synchronous SERCOM USART
 */
int32_t _usart_sync_init(struct _usart_sync_device *const device, void *const hw)
{
    2fd4:	b580      	push	{r7, lr}
    2fd6:	b082      	sub	sp, #8
    2fd8:	af00      	add	r7, sp, #0
    2fda:	6078      	str	r0, [r7, #4]
    2fdc:	6039      	str	r1, [r7, #0]
	ASSERT(device);
    2fde:	687b      	ldr	r3, [r7, #4]
    2fe0:	2b00      	cmp	r3, #0
    2fe2:	bf14      	ite	ne
    2fe4:	2301      	movne	r3, #1
    2fe6:	2300      	moveq	r3, #0
    2fe8:	b2db      	uxtb	r3, r3
    2fea:	22bb      	movs	r2, #187	; 0xbb
    2fec:	4907      	ldr	r1, [pc, #28]	; (300c <_usart_sync_init+0x38>)
    2fee:	4618      	mov	r0, r3
    2ff0:	4b07      	ldr	r3, [pc, #28]	; (3010 <_usart_sync_init+0x3c>)
    2ff2:	4798      	blx	r3

	device->hw = hw;
    2ff4:	687b      	ldr	r3, [r7, #4]
    2ff6:	683a      	ldr	r2, [r7, #0]
    2ff8:	601a      	str	r2, [r3, #0]

	return _usart_init(hw);
    2ffa:	6838      	ldr	r0, [r7, #0]
    2ffc:	4b05      	ldr	r3, [pc, #20]	; (3014 <_usart_sync_init+0x40>)
    2ffe:	4798      	blx	r3
    3000:	4603      	mov	r3, r0
}
    3002:	4618      	mov	r0, r3
    3004:	3708      	adds	r7, #8
    3006:	46bd      	mov	sp, r7
    3008:	bd80      	pop	{r7, pc}
    300a:	bf00      	nop
    300c:	0000474c 	.word	0x0000474c
    3010:	0000168d 	.word	0x0000168d
    3014:	000031a5 	.word	0x000031a5

00003018 <_usart_sync_enable>:

/**
 * \brief Enable SERCOM module
 */
void _usart_sync_enable(struct _usart_sync_device *const device)
{
    3018:	b580      	push	{r7, lr}
    301a:	b082      	sub	sp, #8
    301c:	af00      	add	r7, sp, #0
    301e:	6078      	str	r0, [r7, #4]
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
    3020:	687b      	ldr	r3, [r7, #4]
    3022:	681b      	ldr	r3, [r3, #0]
    3024:	4618      	mov	r0, r3
    3026:	4b03      	ldr	r3, [pc, #12]	; (3034 <_usart_sync_enable+0x1c>)
    3028:	4798      	blx	r3
}
    302a:	bf00      	nop
    302c:	3708      	adds	r7, #8
    302e:	46bd      	mov	sp, r7
    3030:	bd80      	pop	{r7, pc}
    3032:	bf00      	nop
    3034:	00002e61 	.word	0x00002e61

00003038 <_usart_sync_write_byte>:

/**
 * \brief Write a byte to the given SERCOM USART instance
 */
void _usart_sync_write_byte(struct _usart_sync_device *const device, uint8_t data)
{
    3038:	b580      	push	{r7, lr}
    303a:	b082      	sub	sp, #8
    303c:	af00      	add	r7, sp, #0
    303e:	6078      	str	r0, [r7, #4]
    3040:	460b      	mov	r3, r1
    3042:	70fb      	strb	r3, [r7, #3]
	hri_sercomusart_write_DATA_reg(device->hw, data);
    3044:	687b      	ldr	r3, [r7, #4]
    3046:	681b      	ldr	r3, [r3, #0]
    3048:	78fa      	ldrb	r2, [r7, #3]
    304a:	4611      	mov	r1, r2
    304c:	4618      	mov	r0, r3
    304e:	4b03      	ldr	r3, [pc, #12]	; (305c <_usart_sync_write_byte+0x24>)
    3050:	4798      	blx	r3
}
    3052:	bf00      	nop
    3054:	3708      	adds	r7, #8
    3056:	46bd      	mov	sp, r7
    3058:	bd80      	pop	{r7, pc}
    305a:	bf00      	nop
    305c:	00002f81 	.word	0x00002f81

00003060 <_usart_sync_read_byte>:

/**
 * \brief Read a byte from the given SERCOM USART instance
 */
uint8_t _usart_sync_read_byte(const struct _usart_sync_device *const device)
{
    3060:	b580      	push	{r7, lr}
    3062:	b082      	sub	sp, #8
    3064:	af00      	add	r7, sp, #0
    3066:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_read_DATA_reg(device->hw);
    3068:	687b      	ldr	r3, [r7, #4]
    306a:	681b      	ldr	r3, [r3, #0]
    306c:	4618      	mov	r0, r3
    306e:	4b04      	ldr	r3, [pc, #16]	; (3080 <_usart_sync_read_byte+0x20>)
    3070:	4798      	blx	r3
    3072:	4603      	mov	r3, r0
    3074:	b2db      	uxtb	r3, r3
}
    3076:	4618      	mov	r0, r3
    3078:	3708      	adds	r7, #8
    307a:	46bd      	mov	sp, r7
    307c:	bd80      	pop	{r7, pc}
    307e:	bf00      	nop
    3080:	00002f9d 	.word	0x00002f9d

00003084 <_usart_sync_is_ready_to_send>:

/**
 * \brief Check if USART is ready to send next byte
 */
bool _usart_sync_is_ready_to_send(const struct _usart_sync_device *const device)
{
    3084:	b580      	push	{r7, lr}
    3086:	b082      	sub	sp, #8
    3088:	af00      	add	r7, sp, #0
    308a:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
    308c:	687b      	ldr	r3, [r7, #4]
    308e:	681b      	ldr	r3, [r3, #0]
    3090:	4618      	mov	r0, r3
    3092:	4b03      	ldr	r3, [pc, #12]	; (30a0 <_usart_sync_is_ready_to_send+0x1c>)
    3094:	4798      	blx	r3
    3096:	4603      	mov	r3, r0
}
    3098:	4618      	mov	r0, r3
    309a:	3708      	adds	r7, #8
    309c:	46bd      	mov	sp, r7
    309e:	bd80      	pop	{r7, pc}
    30a0:	00002de5 	.word	0x00002de5

000030a4 <_usart_sync_is_transmit_done>:

/**
 * \brief Check if USART transmission complete
 */
bool _usart_sync_is_transmit_done(const struct _usart_sync_device *const device)
{
    30a4:	b580      	push	{r7, lr}
    30a6:	b082      	sub	sp, #8
    30a8:	af00      	add	r7, sp, #0
    30aa:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
    30ac:	687b      	ldr	r3, [r7, #4]
    30ae:	681b      	ldr	r3, [r3, #0]
    30b0:	4618      	mov	r0, r3
    30b2:	4b03      	ldr	r3, [pc, #12]	; (30c0 <_usart_sync_is_transmit_done+0x1c>)
    30b4:	4798      	blx	r3
    30b6:	4603      	mov	r3, r0
}
    30b8:	4618      	mov	r0, r3
    30ba:	3708      	adds	r7, #8
    30bc:	46bd      	mov	sp, r7
    30be:	bd80      	pop	{r7, pc}
    30c0:	00002e0d 	.word	0x00002e0d

000030c4 <_usart_sync_is_byte_received>:

/**
 * \brief Check if there is data received by USART
 */
bool _usart_sync_is_byte_received(const struct _usart_sync_device *const device)
{
    30c4:	b580      	push	{r7, lr}
    30c6:	b082      	sub	sp, #8
    30c8:	af00      	add	r7, sp, #0
    30ca:	6078      	str	r0, [r7, #4]
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
    30cc:	687b      	ldr	r3, [r7, #4]
    30ce:	681b      	ldr	r3, [r3, #0]
    30d0:	4618      	mov	r0, r3
    30d2:	4b03      	ldr	r3, [pc, #12]	; (30e0 <_usart_sync_is_byte_received+0x1c>)
    30d4:	4798      	blx	r3
    30d6:	4603      	mov	r3, r0
}
    30d8:	4618      	mov	r0, r3
    30da:	3708      	adds	r7, #8
    30dc:	46bd      	mov	sp, r7
    30de:	bd80      	pop	{r7, pc}
    30e0:	00002e37 	.word	0x00002e37

000030e4 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
    30e4:	b4b0      	push	{r4, r5, r7}
    30e6:	b08d      	sub	sp, #52	; 0x34
    30e8:	af00      	add	r7, sp, #0
    30ea:	6078      	str	r0, [r7, #4]
	Sercom *const sercom_modules[] = SERCOM_INSTS;
    30ec:	4b13      	ldr	r3, [pc, #76]	; (313c <_sercom_get_hardware_index+0x58>)
    30ee:	f107 040c 	add.w	r4, r7, #12
    30f2:	461d      	mov	r5, r3
    30f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    30f6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    30f8:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    30fc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    3100:	2300      	movs	r3, #0
    3102:	62fb      	str	r3, [r7, #44]	; 0x2c
    3104:	e010      	b.n	3128 <_sercom_get_hardware_index+0x44>
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
    3106:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3108:	009b      	lsls	r3, r3, #2
    310a:	f107 0230 	add.w	r2, r7, #48	; 0x30
    310e:	4413      	add	r3, r2
    3110:	f853 3c24 	ldr.w	r3, [r3, #-36]
    3114:	461a      	mov	r2, r3
    3116:	687b      	ldr	r3, [r7, #4]
    3118:	429a      	cmp	r2, r3
    311a:	d102      	bne.n	3122 <_sercom_get_hardware_index+0x3e>
			return i;
    311c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    311e:	b2db      	uxtb	r3, r3
    3120:	e006      	b.n	3130 <_sercom_get_hardware_index+0x4c>
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    3122:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    3124:	3301      	adds	r3, #1
    3126:	62fb      	str	r3, [r7, #44]	; 0x2c
    3128:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    312a:	2b07      	cmp	r3, #7
    312c:	d9eb      	bls.n	3106 <_sercom_get_hardware_index+0x22>
		}
	}
	return 0;
    312e:	2300      	movs	r3, #0
}
    3130:	4618      	mov	r0, r3
    3132:	3734      	adds	r7, #52	; 0x34
    3134:	46bd      	mov	sp, r7
    3136:	bcb0      	pop	{r4, r5, r7}
    3138:	4770      	bx	lr
    313a:	bf00      	nop
    313c:	00004768 	.word	0x00004768

00003140 <_get_sercom_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static uint8_t _get_sercom_index(const void *const hw)
{
    3140:	b580      	push	{r7, lr}
    3142:	b084      	sub	sp, #16
    3144:	af00      	add	r7, sp, #0
    3146:	6078      	str	r0, [r7, #4]
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
    3148:	6878      	ldr	r0, [r7, #4]
    314a:	4b12      	ldr	r3, [pc, #72]	; (3194 <_get_sercom_index+0x54>)
    314c:	4798      	blx	r3
    314e:	4603      	mov	r3, r0
    3150:	73bb      	strb	r3, [r7, #14]
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    3152:	2300      	movs	r3, #0
    3154:	73fb      	strb	r3, [r7, #15]
    3156:	e00f      	b.n	3178 <_get_sercom_index+0x38>
		if (_usarts[i].number == sercom_offset) {
    3158:	7bfa      	ldrb	r2, [r7, #15]
    315a:	490f      	ldr	r1, [pc, #60]	; (3198 <_get_sercom_index+0x58>)
    315c:	4613      	mov	r3, r2
    315e:	005b      	lsls	r3, r3, #1
    3160:	4413      	add	r3, r2
    3162:	00db      	lsls	r3, r3, #3
    3164:	440b      	add	r3, r1
    3166:	781b      	ldrb	r3, [r3, #0]
    3168:	7bba      	ldrb	r2, [r7, #14]
    316a:	429a      	cmp	r2, r3
    316c:	d101      	bne.n	3172 <_get_sercom_index+0x32>
			return i;
    316e:	7bfb      	ldrb	r3, [r7, #15]
    3170:	e00c      	b.n	318c <_get_sercom_index+0x4c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
    3172:	7bfb      	ldrb	r3, [r7, #15]
    3174:	3301      	adds	r3, #1
    3176:	73fb      	strb	r3, [r7, #15]
    3178:	7bfb      	ldrb	r3, [r7, #15]
    317a:	2b00      	cmp	r3, #0
    317c:	d0ec      	beq.n	3158 <_get_sercom_index+0x18>
		}
	}

	ASSERT(false);
    317e:	f240 2247 	movw	r2, #583	; 0x247
    3182:	4906      	ldr	r1, [pc, #24]	; (319c <_get_sercom_index+0x5c>)
    3184:	2000      	movs	r0, #0
    3186:	4b06      	ldr	r3, [pc, #24]	; (31a0 <_get_sercom_index+0x60>)
    3188:	4798      	blx	r3
	return 0;
    318a:	2300      	movs	r3, #0
}
    318c:	4618      	mov	r0, r3
    318e:	3710      	adds	r7, #16
    3190:	46bd      	mov	sp, r7
    3192:	bd80      	pop	{r7, pc}
    3194:	000030e5 	.word	0x000030e5
    3198:	20000018 	.word	0x20000018
    319c:	0000474c 	.word	0x0000474c
    31a0:	0000168d 	.word	0x0000168d

000031a4 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
    31a4:	b580      	push	{r7, lr}
    31a6:	b084      	sub	sp, #16
    31a8:	af00      	add	r7, sp, #0
    31aa:	6078      	str	r0, [r7, #4]
	uint8_t i = _get_sercom_index(hw);
    31ac:	6878      	ldr	r0, [r7, #4]
    31ae:	4b61      	ldr	r3, [pc, #388]	; (3334 <_usart_init+0x190>)
    31b0:	4798      	blx	r3
    31b2:	4603      	mov	r3, r0
    31b4:	73fb      	strb	r3, [r7, #15]

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
    31b6:	2101      	movs	r1, #1
    31b8:	6878      	ldr	r0, [r7, #4]
    31ba:	4b5f      	ldr	r3, [pc, #380]	; (3338 <_usart_init+0x194>)
    31bc:	4798      	blx	r3
    31be:	4603      	mov	r3, r0
    31c0:	f083 0301 	eor.w	r3, r3, #1
    31c4:	b2db      	uxtb	r3, r3
    31c6:	2b00      	cmp	r3, #0
    31c8:	d020      	beq.n	320c <_usart_init+0x68>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
    31ca:	7bfa      	ldrb	r2, [r7, #15]
    31cc:	495b      	ldr	r1, [pc, #364]	; (333c <_usart_init+0x198>)
    31ce:	4613      	mov	r3, r2
    31d0:	005b      	lsls	r3, r3, #1
    31d2:	4413      	add	r3, r2
    31d4:	00db      	lsls	r3, r3, #3
    31d6:	440b      	add	r3, r1
    31d8:	3304      	adds	r3, #4
    31da:	681b      	ldr	r3, [r3, #0]
    31dc:	f003 031c 	and.w	r3, r3, #28
    31e0:	60bb      	str	r3, [r7, #8]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
    31e2:	2102      	movs	r1, #2
    31e4:	6878      	ldr	r0, [r7, #4]
    31e6:	4b56      	ldr	r3, [pc, #344]	; (3340 <_usart_init+0x19c>)
    31e8:	4798      	blx	r3
    31ea:	4603      	mov	r3, r0
    31ec:	2b00      	cmp	r3, #0
    31ee:	d006      	beq.n	31fe <_usart_init+0x5a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
    31f0:	6878      	ldr	r0, [r7, #4]
    31f2:	4b54      	ldr	r3, [pc, #336]	; (3344 <_usart_init+0x1a0>)
    31f4:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
    31f6:	2102      	movs	r1, #2
    31f8:	6878      	ldr	r0, [r7, #4]
    31fa:	4b53      	ldr	r3, [pc, #332]	; (3348 <_usart_init+0x1a4>)
    31fc:	4798      	blx	r3
		}
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
    31fe:	68bb      	ldr	r3, [r7, #8]
    3200:	f043 0301 	orr.w	r3, r3, #1
    3204:	4619      	mov	r1, r3
    3206:	6878      	ldr	r0, [r7, #4]
    3208:	4b50      	ldr	r3, [pc, #320]	; (334c <_usart_init+0x1a8>)
    320a:	4798      	blx	r3
	}
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
    320c:	2101      	movs	r1, #1
    320e:	6878      	ldr	r0, [r7, #4]
    3210:	4b4d      	ldr	r3, [pc, #308]	; (3348 <_usart_init+0x1a4>)
    3212:	4798      	blx	r3

	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
    3214:	7bfa      	ldrb	r2, [r7, #15]
    3216:	4949      	ldr	r1, [pc, #292]	; (333c <_usart_init+0x198>)
    3218:	4613      	mov	r3, r2
    321a:	005b      	lsls	r3, r3, #1
    321c:	4413      	add	r3, r2
    321e:	00db      	lsls	r3, r3, #3
    3220:	440b      	add	r3, r1
    3222:	3304      	adds	r3, #4
    3224:	681b      	ldr	r3, [r3, #0]
    3226:	4619      	mov	r1, r3
    3228:	6878      	ldr	r0, [r7, #4]
    322a:	4b48      	ldr	r3, [pc, #288]	; (334c <_usart_init+0x1a8>)
    322c:	4798      	blx	r3
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
    322e:	7bfa      	ldrb	r2, [r7, #15]
    3230:	4942      	ldr	r1, [pc, #264]	; (333c <_usart_init+0x198>)
    3232:	4613      	mov	r3, r2
    3234:	005b      	lsls	r3, r3, #1
    3236:	4413      	add	r3, r2
    3238:	00db      	lsls	r3, r3, #3
    323a:	440b      	add	r3, r1
    323c:	3308      	adds	r3, #8
    323e:	681b      	ldr	r3, [r3, #0]
    3240:	4619      	mov	r1, r3
    3242:	6878      	ldr	r0, [r7, #4]
    3244:	4b42      	ldr	r3, [pc, #264]	; (3350 <_usart_init+0x1ac>)
    3246:	4798      	blx	r3
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
    3248:	7bfa      	ldrb	r2, [r7, #15]
    324a:	493c      	ldr	r1, [pc, #240]	; (333c <_usart_init+0x198>)
    324c:	4613      	mov	r3, r2
    324e:	005b      	lsls	r3, r3, #1
    3250:	4413      	add	r3, r2
    3252:	00db      	lsls	r3, r3, #3
    3254:	440b      	add	r3, r1
    3256:	330c      	adds	r3, #12
    3258:	681b      	ldr	r3, [r3, #0]
    325a:	4619      	mov	r1, r3
    325c:	6878      	ldr	r0, [r7, #4]
    325e:	4b3d      	ldr	r3, [pc, #244]	; (3354 <_usart_init+0x1b0>)
    3260:	4798      	blx	r3
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
    3262:	7bfa      	ldrb	r2, [r7, #15]
    3264:	4935      	ldr	r1, [pc, #212]	; (333c <_usart_init+0x198>)
    3266:	4613      	mov	r3, r2
    3268:	005b      	lsls	r3, r3, #1
    326a:	4413      	add	r3, r2
    326c:	00db      	lsls	r3, r3, #3
    326e:	440b      	add	r3, r1
    3270:	3304      	adds	r3, #4
    3272:	681b      	ldr	r3, [r3, #0]
    3274:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
    3278:	2b00      	cmp	r3, #0
    327a:	d10c      	bne.n	3296 <_usart_init+0xf2>
    327c:	7bfa      	ldrb	r2, [r7, #15]
    327e:	492f      	ldr	r1, [pc, #188]	; (333c <_usart_init+0x198>)
    3280:	4613      	mov	r3, r2
    3282:	005b      	lsls	r3, r3, #1
    3284:	4413      	add	r3, r2
    3286:	00db      	lsls	r3, r3, #3
    3288:	440b      	add	r3, r1
    328a:	3304      	adds	r3, #4
    328c:	681b      	ldr	r3, [r3, #0]
    328e:	f403 43c0 	and.w	r3, r3, #24576	; 0x6000
    3292:	2b00      	cmp	r3, #0
    3294:	d022      	beq.n	32dc <_usart_init+0x138>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
    3296:	7bfa      	ldrb	r2, [r7, #15]
    3298:	4928      	ldr	r1, [pc, #160]	; (333c <_usart_init+0x198>)
    329a:	4613      	mov	r3, r2
    329c:	005b      	lsls	r3, r3, #1
    329e:	4413      	add	r3, r2
    32a0:	00db      	lsls	r3, r3, #3
    32a2:	440b      	add	r3, r1
    32a4:	3310      	adds	r3, #16
    32a6:	881b      	ldrh	r3, [r3, #0]
    32a8:	f3c3 030c 	ubfx	r3, r3, #0, #13
    32ac:	b299      	uxth	r1, r3
    32ae:	687a      	ldr	r2, [r7, #4]
    32b0:	8993      	ldrh	r3, [r2, #12]
    32b2:	f361 030c 	bfi	r3, r1, #0, #13
    32b6:	8193      	strh	r3, [r2, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
    32b8:	7bfa      	ldrb	r2, [r7, #15]
    32ba:	4920      	ldr	r1, [pc, #128]	; (333c <_usart_init+0x198>)
    32bc:	4613      	mov	r3, r2
    32be:	005b      	lsls	r3, r3, #1
    32c0:	4413      	add	r3, r2
    32c2:	00db      	lsls	r3, r3, #3
    32c4:	440b      	add	r3, r1
    32c6:	3312      	adds	r3, #18
    32c8:	781b      	ldrb	r3, [r3, #0]
    32ca:	f003 0307 	and.w	r3, r3, #7
    32ce:	b2d9      	uxtb	r1, r3
    32d0:	687a      	ldr	r2, [r7, #4]
    32d2:	8993      	ldrh	r3, [r2, #12]
    32d4:	f361 334f 	bfi	r3, r1, #13, #3
    32d8:	8193      	strh	r3, [r2, #12]
    32da:	e00c      	b.n	32f6 <_usart_init+0x152>
	} else {
		hri_sercomusart_write_BAUD_reg(hw, _usarts[i].baud);
    32dc:	7bfa      	ldrb	r2, [r7, #15]
    32de:	4917      	ldr	r1, [pc, #92]	; (333c <_usart_init+0x198>)
    32e0:	4613      	mov	r3, r2
    32e2:	005b      	lsls	r3, r3, #1
    32e4:	4413      	add	r3, r2
    32e6:	00db      	lsls	r3, r3, #3
    32e8:	440b      	add	r3, r1
    32ea:	3310      	adds	r3, #16
    32ec:	881b      	ldrh	r3, [r3, #0]
    32ee:	4619      	mov	r1, r3
    32f0:	6878      	ldr	r0, [r7, #4]
    32f2:	4b19      	ldr	r3, [pc, #100]	; (3358 <_usart_init+0x1b4>)
    32f4:	4798      	blx	r3
	}

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
    32f6:	7bfa      	ldrb	r2, [r7, #15]
    32f8:	4910      	ldr	r1, [pc, #64]	; (333c <_usart_init+0x198>)
    32fa:	4613      	mov	r3, r2
    32fc:	005b      	lsls	r3, r3, #1
    32fe:	4413      	add	r3, r2
    3300:	00db      	lsls	r3, r3, #3
    3302:	440b      	add	r3, r1
    3304:	3313      	adds	r3, #19
    3306:	781b      	ldrb	r3, [r3, #0]
    3308:	4619      	mov	r1, r3
    330a:	6878      	ldr	r0, [r7, #4]
    330c:	4b13      	ldr	r3, [pc, #76]	; (335c <_usart_init+0x1b8>)
    330e:	4798      	blx	r3
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);
    3310:	7bfa      	ldrb	r2, [r7, #15]
    3312:	490a      	ldr	r1, [pc, #40]	; (333c <_usart_init+0x198>)
    3314:	4613      	mov	r3, r2
    3316:	005b      	lsls	r3, r3, #1
    3318:	4413      	add	r3, r2
    331a:	00db      	lsls	r3, r3, #3
    331c:	440b      	add	r3, r1
    331e:	3314      	adds	r3, #20
    3320:	781b      	ldrb	r3, [r3, #0]
    3322:	4619      	mov	r1, r3
    3324:	6878      	ldr	r0, [r7, #4]
    3326:	4b0e      	ldr	r3, [pc, #56]	; (3360 <_usart_init+0x1bc>)
    3328:	4798      	blx	r3

	return ERR_NONE;
    332a:	2300      	movs	r3, #0
}
    332c:	4618      	mov	r0, r3
    332e:	3710      	adds	r7, #16
    3330:	46bd      	mov	sp, r7
    3332:	bd80      	pop	{r7, pc}
    3334:	00003141 	.word	0x00003141
    3338:	00002dbd 	.word	0x00002dbd
    333c:	20000018 	.word	0x20000018
    3340:	00002eb1 	.word	0x00002eb1
    3344:	00002e89 	.word	0x00002e89
    3348:	00002d99 	.word	0x00002d99
    334c:	00002ee1 	.word	0x00002ee1
    3350:	00002f05 	.word	0x00002f05
    3354:	00002f29 	.word	0x00002f29
    3358:	00002f45 	.word	0x00002f45
    335c:	00002f63 	.word	0x00002f63
    3360:	00002fb5 	.word	0x00002fb5

00003364 <hri_tcc_wait_for_sync>:
typedef uint32_t hri_tcc_wexctrl_reg_t;
typedef uint8_t  hri_tcc_ctrlbset_reg_t;
typedef uint8_t  hri_tcc_dbgctrl_reg_t;

static inline void hri_tcc_wait_for_sync(const void *const hw, hri_tcc_syncbusy_reg_t reg)
{
    3364:	b480      	push	{r7}
    3366:	b083      	sub	sp, #12
    3368:	af00      	add	r7, sp, #0
    336a:	6078      	str	r0, [r7, #4]
    336c:	6039      	str	r1, [r7, #0]
	while (((Tcc *)hw)->SYNCBUSY.reg & reg) {
    336e:	bf00      	nop
    3370:	687b      	ldr	r3, [r7, #4]
    3372:	689a      	ldr	r2, [r3, #8]
    3374:	683b      	ldr	r3, [r7, #0]
    3376:	4013      	ands	r3, r2
    3378:	2b00      	cmp	r3, #0
    337a:	d1f9      	bne.n	3370 <hri_tcc_wait_for_sync+0xc>
	};
}
    337c:	bf00      	nop
    337e:	370c      	adds	r7, #12
    3380:	46bd      	mov	sp, r7
    3382:	f85d 7b04 	ldr.w	r7, [sp], #4
    3386:	4770      	bx	lr

00003388 <hri_tcc_is_syncing>:

static inline bool hri_tcc_is_syncing(const void *const hw, hri_tcc_syncbusy_reg_t reg)
{
    3388:	b480      	push	{r7}
    338a:	b083      	sub	sp, #12
    338c:	af00      	add	r7, sp, #0
    338e:	6078      	str	r0, [r7, #4]
    3390:	6039      	str	r1, [r7, #0]
	return ((Tcc *)hw)->SYNCBUSY.reg & reg;
    3392:	687b      	ldr	r3, [r7, #4]
    3394:	689a      	ldr	r2, [r3, #8]
    3396:	683b      	ldr	r3, [r7, #0]
    3398:	4013      	ands	r3, r2
    339a:	2b00      	cmp	r3, #0
    339c:	bf14      	ite	ne
    339e:	2301      	movne	r3, #1
    33a0:	2300      	moveq	r3, #0
    33a2:	b2db      	uxtb	r3, r3
}
    33a4:	4618      	mov	r0, r3
    33a6:	370c      	adds	r7, #12
    33a8:	46bd      	mov	sp, r7
    33aa:	f85d 7b04 	ldr.w	r7, [sp], #4
    33ae:	4770      	bx	lr

000033b0 <hri_tcc_write_CTRLA_ENABLE_bit>:
	tmp = (tmp & TCC_CTRLA_ENABLE) >> TCC_CTRLA_ENABLE_Pos;
	return (bool)tmp;
}

static inline void hri_tcc_write_CTRLA_ENABLE_bit(const void *const hw, bool value)
{
    33b0:	b580      	push	{r7, lr}
    33b2:	b084      	sub	sp, #16
    33b4:	af00      	add	r7, sp, #0
    33b6:	6078      	str	r0, [r7, #4]
    33b8:	460b      	mov	r3, r1
    33ba:	70fb      	strb	r3, [r7, #3]
	uint32_t tmp;
	TCC_CRITICAL_SECTION_ENTER();
	tmp = ((Tcc *)hw)->CTRLA.reg;
    33bc:	687b      	ldr	r3, [r7, #4]
    33be:	681b      	ldr	r3, [r3, #0]
    33c0:	60fb      	str	r3, [r7, #12]
	tmp &= ~TCC_CTRLA_ENABLE;
    33c2:	68fb      	ldr	r3, [r7, #12]
    33c4:	f023 0302 	bic.w	r3, r3, #2
    33c8:	60fb      	str	r3, [r7, #12]
	tmp |= value << TCC_CTRLA_ENABLE_Pos;
    33ca:	78fb      	ldrb	r3, [r7, #3]
    33cc:	005b      	lsls	r3, r3, #1
    33ce:	461a      	mov	r2, r3
    33d0:	68fb      	ldr	r3, [r7, #12]
    33d2:	4313      	orrs	r3, r2
    33d4:	60fb      	str	r3, [r7, #12]
	((Tcc *)hw)->CTRLA.reg = tmp;
    33d6:	687b      	ldr	r3, [r7, #4]
    33d8:	68fa      	ldr	r2, [r7, #12]
    33da:	601a      	str	r2, [r3, #0]
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    33dc:	2103      	movs	r1, #3
    33de:	6878      	ldr	r0, [r7, #4]
    33e0:	4b02      	ldr	r3, [pc, #8]	; (33ec <hri_tcc_write_CTRLA_ENABLE_bit+0x3c>)
    33e2:	4798      	blx	r3
	TCC_CRITICAL_SECTION_LEAVE();
}
    33e4:	bf00      	nop
    33e6:	3710      	adds	r7, #16
    33e8:	46bd      	mov	sp, r7
    33ea:	bd80      	pop	{r7, pc}
    33ec:	00003365 	.word	0x00003365

000033f0 <hri_tcc_clear_CTRLA_ENABLE_bit>:

static inline void hri_tcc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
    33f0:	b580      	push	{r7, lr}
    33f2:	b082      	sub	sp, #8
    33f4:	af00      	add	r7, sp, #0
    33f6:	6078      	str	r0, [r7, #4]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->CTRLA.reg &= ~TCC_CTRLA_ENABLE;
    33f8:	687b      	ldr	r3, [r7, #4]
    33fa:	681b      	ldr	r3, [r3, #0]
    33fc:	f023 0202 	bic.w	r2, r3, #2
    3400:	687b      	ldr	r3, [r7, #4]
    3402:	601a      	str	r2, [r3, #0]
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    3404:	2103      	movs	r1, #3
    3406:	6878      	ldr	r0, [r7, #4]
    3408:	4b02      	ldr	r3, [pc, #8]	; (3414 <hri_tcc_clear_CTRLA_ENABLE_bit+0x24>)
    340a:	4798      	blx	r3
	TCC_CRITICAL_SECTION_LEAVE();
}
    340c:	bf00      	nop
    340e:	3708      	adds	r7, #8
    3410:	46bd      	mov	sp, r7
    3412:	bd80      	pop	{r7, pc}
    3414:	00003365 	.word	0x00003365

00003418 <hri_tcc_get_CTRLA_reg>:
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
	TCC_CRITICAL_SECTION_LEAVE();
}

static inline hri_tcc_ctrla_reg_t hri_tcc_get_CTRLA_reg(const void *const hw, hri_tcc_ctrla_reg_t mask)
{
    3418:	b580      	push	{r7, lr}
    341a:	b084      	sub	sp, #16
    341c:	af00      	add	r7, sp, #0
    341e:	6078      	str	r0, [r7, #4]
    3420:	6039      	str	r1, [r7, #0]
	uint32_t tmp;
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    3422:	2103      	movs	r1, #3
    3424:	6878      	ldr	r0, [r7, #4]
    3426:	4b07      	ldr	r3, [pc, #28]	; (3444 <hri_tcc_get_CTRLA_reg+0x2c>)
    3428:	4798      	blx	r3
	tmp = ((Tcc *)hw)->CTRLA.reg;
    342a:	687b      	ldr	r3, [r7, #4]
    342c:	681b      	ldr	r3, [r3, #0]
    342e:	60fb      	str	r3, [r7, #12]
	tmp &= mask;
    3430:	68fa      	ldr	r2, [r7, #12]
    3432:	683b      	ldr	r3, [r7, #0]
    3434:	4013      	ands	r3, r2
    3436:	60fb      	str	r3, [r7, #12]
	return tmp;
    3438:	68fb      	ldr	r3, [r7, #12]
}
    343a:	4618      	mov	r0, r3
    343c:	3710      	adds	r7, #16
    343e:	46bd      	mov	sp, r7
    3440:	bd80      	pop	{r7, pc}
    3442:	bf00      	nop
    3444:	00003365 	.word	0x00003365

00003448 <hri_tcc_write_CTRLA_reg>:

static inline void hri_tcc_write_CTRLA_reg(const void *const hw, hri_tcc_ctrla_reg_t data)
{
    3448:	b580      	push	{r7, lr}
    344a:	b082      	sub	sp, #8
    344c:	af00      	add	r7, sp, #0
    344e:	6078      	str	r0, [r7, #4]
    3450:	6039      	str	r1, [r7, #0]
	TCC_CRITICAL_SECTION_ENTER();
	((Tcc *)hw)->CTRLA.reg = data;
    3452:	687b      	ldr	r3, [r7, #4]
    3454:	683a      	ldr	r2, [r7, #0]
    3456:	601a      	str	r2, [r3, #0]
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_SWRST | TCC_SYNCBUSY_ENABLE);
    3458:	2103      	movs	r1, #3
    345a:	6878      	ldr	r0, [r7, #4]
    345c:	4b02      	ldr	r3, [pc, #8]	; (3468 <hri_tcc_write_CTRLA_reg+0x20>)
    345e:	4798      	blx	r3
	TCC_CRITICAL_SECTION_LEAVE();
}
    3460:	bf00      	nop
    3462:	3708      	adds	r7, #8
    3464:	46bd      	mov	sp, r7
    3466:	bd80      	pop	{r7, pc}
    3468:	00003365 	.word	0x00003365

0000346c <PWM_0_init>:

/**
 * \brief Initialize TCC interface
 */
int8_t PWM_0_init()
{
    346c:	b580      	push	{r7, lr}
    346e:	af00      	add	r7, sp, #0

	if (!hri_tcc_is_syncing(TCC1, TCC_SYNCBUSY_SWRST)) {
    3470:	2101      	movs	r1, #1
    3472:	4813      	ldr	r0, [pc, #76]	; (34c0 <PWM_0_init+0x54>)
    3474:	4b13      	ldr	r3, [pc, #76]	; (34c4 <PWM_0_init+0x58>)
    3476:	4798      	blx	r3
    3478:	4603      	mov	r3, r0
    347a:	f083 0301 	eor.w	r3, r3, #1
    347e:	b2db      	uxtb	r3, r3
    3480:	2b00      	cmp	r3, #0
    3482:	d011      	beq.n	34a8 <PWM_0_init+0x3c>
		if (hri_tcc_get_CTRLA_reg(TCC1, TCC_CTRLA_ENABLE)) {
    3484:	2102      	movs	r1, #2
    3486:	480e      	ldr	r0, [pc, #56]	; (34c0 <PWM_0_init+0x54>)
    3488:	4b0f      	ldr	r3, [pc, #60]	; (34c8 <PWM_0_init+0x5c>)
    348a:	4798      	blx	r3
    348c:	4603      	mov	r3, r0
    348e:	2b00      	cmp	r3, #0
    3490:	d006      	beq.n	34a0 <PWM_0_init+0x34>
			hri_tcc_clear_CTRLA_ENABLE_bit(TCC1);
    3492:	480b      	ldr	r0, [pc, #44]	; (34c0 <PWM_0_init+0x54>)
    3494:	4b0d      	ldr	r3, [pc, #52]	; (34cc <PWM_0_init+0x60>)
    3496:	4798      	blx	r3
			hri_tcc_wait_for_sync(TCC1, TCC_SYNCBUSY_ENABLE);
    3498:	2102      	movs	r1, #2
    349a:	4809      	ldr	r0, [pc, #36]	; (34c0 <PWM_0_init+0x54>)
    349c:	4b0c      	ldr	r3, [pc, #48]	; (34d0 <PWM_0_init+0x64>)
    349e:	4798      	blx	r3
		}
		hri_tcc_write_CTRLA_reg(TCC1, TCC_CTRLA_SWRST);
    34a0:	2101      	movs	r1, #1
    34a2:	4807      	ldr	r0, [pc, #28]	; (34c0 <PWM_0_init+0x54>)
    34a4:	4b0b      	ldr	r3, [pc, #44]	; (34d4 <PWM_0_init+0x68>)
    34a6:	4798      	blx	r3
	}
	hri_tcc_wait_for_sync(TCC1, TCC_SYNCBUSY_SWRST);
    34a8:	2101      	movs	r1, #1
    34aa:	4805      	ldr	r0, [pc, #20]	; (34c0 <PWM_0_init+0x54>)
    34ac:	4b08      	ldr	r3, [pc, #32]	; (34d0 <PWM_0_init+0x64>)
    34ae:	4798      	blx	r3
	//		 | 0 << TCC_INTENSET_ERR_Pos /* Error Interrupt Enable: disabled */
	//		 | 0 << TCC_INTENSET_CNT_Pos /* Counter Interrupt Enable: disabled */
	//		 | 0 << TCC_INTENSET_TRG_Pos /* Retrigger Interrupt Enable: disabled */
	//		 | 0 << TCC_INTENSET_OVF_Pos); /* Overflow Interrupt enable: disabled */

	hri_tcc_write_CTRLA_ENABLE_bit(TCC1, 1 << TCC_CTRLA_ENABLE_Pos); /* Enable: enabled */
    34b0:	2101      	movs	r1, #1
    34b2:	4803      	ldr	r0, [pc, #12]	; (34c0 <PWM_0_init+0x54>)
    34b4:	4b08      	ldr	r3, [pc, #32]	; (34d8 <PWM_0_init+0x6c>)
    34b6:	4798      	blx	r3

	return 0;
    34b8:	2300      	movs	r3, #0
}
    34ba:	4618      	mov	r0, r3
    34bc:	bd80      	pop	{r7, pc}
    34be:	bf00      	nop
    34c0:	41018000 	.word	0x41018000
    34c4:	00003389 	.word	0x00003389
    34c8:	00003419 	.word	0x00003419
    34cc:	000033f1 	.word	0x000033f1
    34d0:	00003365 	.word	0x00003365
    34d4:	00003449 	.word	0x00003449
    34d8:	000033b1 	.word	0x000033b1

000034dc <GetCurrentTime>:
 * #define LWIP_TIMEVAL_PRIVATE		0
 *
 */

 unsigned long long GetCurrentTime()
 {
    34dc:	b490      	push	{r4, r7}
    34de:	af00      	add	r7, sp, #0
	//TODO: Implement mechanism to count time from clock ticks or timer or RTC, or something idk
 }
    34e0:	bf00      	nop
    34e2:	4618      	mov	r0, r3
    34e4:	4621      	mov	r1, r4
    34e6:	46bd      	mov	sp, r7
    34e8:	bc90      	pop	{r4, r7}
    34ea:	4770      	bx	lr

000034ec <ProcessAlgorithms>:

 void ProcessAlgorithms(unsigned long long microseconds_elapsed, dbw_inputs_t* inputs)
 {
    34ec:	b580      	push	{r7, lr}
    34ee:	b084      	sub	sp, #16
    34f0:	af00      	add	r7, sp, #0
    34f2:	e9c7 0102 	strd	r0, r1, [r7, #8]
    34f6:	607a      	str	r2, [r7, #4]
	//Calculate new outputs etc. Call SetBlah()...
	//If an some output is complicated. i.e. something like a PID controller, make a new function or .c/.h file.

	SetReverseDrive(inputs->reverse_commanded);
    34f8:	687b      	ldr	r3, [r7, #4]
    34fa:	691b      	ldr	r3, [r3, #16]
    34fc:	4618      	mov	r0, r3
    34fe:	4b03      	ldr	r3, [pc, #12]	; (350c <ProcessAlgorithms+0x20>)
    3500:	4798      	blx	r3

	return;
    3502:	bf00      	nop
 }
    3504:	3710      	adds	r7, #16
    3506:	46bd      	mov	sp, r7
    3508:	bd80      	pop	{r7, pc}
    350a:	bf00      	nop
    350c:	0000054d 	.word	0x0000054d

00003510 <main>:

int main(void)
{
    3510:	b590      	push	{r4, r7, lr}
    3512:	b085      	sub	sp, #20
    3514:	af00      	add	r7, sp, #0
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
    3516:	4b1a      	ldr	r3, [pc, #104]	; (3580 <main+0x70>)
    3518:	4798      	blx	r3

	/*Handles Socket API */
	//printf("\r\nSocket API implementation\r\n");
	//basic_socket();

	int keep_running = 1;
    351a:	2301      	movs	r3, #1
    351c:	60fb      	str	r3, [r7, #12]
	unsigned long long current_time_us;
	dbw_inputs_t* inputs = NULL;
    351e:	2300      	movs	r3, #0
    3520:	60bb      	str	r3, [r7, #8]
	while (keep_running)
    3522:	e024      	b.n	356e <main+0x5e>
	{
		//TODO: Calculate time elapsed in microseconds since last loop start
		current_time_us = GetCurrentTime();
    3524:	4b17      	ldr	r3, [pc, #92]	; (3584 <main+0x74>)
    3526:	4798      	blx	r3
    3528:	e9c7 0100 	strd	r0, r1, [r7]

		ProcessCurrentInputs(current_time_us);
    352c:	4b16      	ldr	r3, [pc, #88]	; (3588 <main+0x78>)
    352e:	e9d7 0100 	ldrd	r0, r1, [r7]
    3532:	4798      	blx	r3
    3534:	4603      	mov	r3, r0
    3536:	460c      	mov	r4, r1
    3538:	4618      	mov	r0, r3
    353a:	4621      	mov	r1, r4
    353c:	4b13      	ldr	r3, [pc, #76]	; (358c <main+0x7c>)
    353e:	4798      	blx	r3

		inputs = GetCurrentInputs();
    3540:	4b13      	ldr	r3, [pc, #76]	; (3590 <main+0x80>)
    3542:	4798      	blx	r3
    3544:	60b8      	str	r0, [r7, #8]

		ProcessAlgorithms(current_time_us, inputs);
    3546:	68ba      	ldr	r2, [r7, #8]
    3548:	e9d7 0100 	ldrd	r0, r1, [r7]
    354c:	4b11      	ldr	r3, [pc, #68]	; (3594 <main+0x84>)
    354e:	4798      	blx	r3

		ProcessCurrentOutputs(current_time_us);
    3550:	4b0d      	ldr	r3, [pc, #52]	; (3588 <main+0x78>)
    3552:	e9d7 0100 	ldrd	r0, r1, [r7]
    3556:	4798      	blx	r3
    3558:	4603      	mov	r3, r0
    355a:	460c      	mov	r4, r1
    355c:	4618      	mov	r0, r3
    355e:	4621      	mov	r1, r4
    3560:	4b0d      	ldr	r3, [pc, #52]	; (3598 <main+0x88>)
    3562:	4798      	blx	r3

		SendUpdateToPC();
    3564:	4b0d      	ldr	r3, [pc, #52]	; (359c <main+0x8c>)
    3566:	4798      	blx	r3

		//arbitrary throttling of main loop. 
		delay_us(100);
    3568:	2064      	movs	r0, #100	; 0x64
    356a:	4b0d      	ldr	r3, [pc, #52]	; (35a0 <main+0x90>)
    356c:	4798      	blx	r3
	while (keep_running)
    356e:	68fb      	ldr	r3, [r7, #12]
    3570:	2b00      	cmp	r3, #0
    3572:	d1d7      	bne.n	3524 <main+0x14>
	}
	return 0;
    3574:	2300      	movs	r3, #0
}
    3576:	4618      	mov	r0, r3
    3578:	3714      	adds	r7, #20
    357a:	46bd      	mov	sp, r7
    357c:	bd90      	pop	{r4, r7, pc}
    357e:	bf00      	nop
    3580:	000002d1 	.word	0x000002d1
    3584:	000034dd 	.word	0x000034dd
    3588:	00003e01 	.word	0x00003e01
    358c:	000004f1 	.word	0x000004f1
    3590:	00000515 	.word	0x00000515
    3594:	000034ed 	.word	0x000034ed
    3598:	00000529 	.word	0x00000529
    359c:	0000053f 	.word	0x0000053f
    35a0:	00001325 	.word	0x00001325

000035a4 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
    35a4:	b580      	push	{r7, lr}
    35a6:	b086      	sub	sp, #24
    35a8:	af00      	add	r7, sp, #0
    35aa:	60f8      	str	r0, [r7, #12]
    35ac:	60b9      	str	r1, [r7, #8]
    35ae:	607a      	str	r2, [r7, #4]
	int n = 0;
    35b0:	2300      	movs	r3, #0
    35b2:	617b      	str	r3, [r7, #20]

	if (file != 0) {
    35b4:	68fb      	ldr	r3, [r7, #12]
    35b6:	2b00      	cmp	r3, #0
    35b8:	d002      	beq.n	35c0 <_read+0x1c>
		return -1;
    35ba:	f04f 33ff 	mov.w	r3, #4294967295
    35be:	e00b      	b.n	35d8 <_read+0x34>
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    35c0:	6879      	ldr	r1, [r7, #4]
    35c2:	68b8      	ldr	r0, [r7, #8]
    35c4:	4b06      	ldr	r3, [pc, #24]	; (35e0 <_read+0x3c>)
    35c6:	4798      	blx	r3
    35c8:	6178      	str	r0, [r7, #20]
	if (n < 0) {
    35ca:	697b      	ldr	r3, [r7, #20]
    35cc:	2b00      	cmp	r3, #0
    35ce:	da02      	bge.n	35d6 <_read+0x32>
		return -1;
    35d0:	f04f 33ff 	mov.w	r3, #4294967295
    35d4:	e000      	b.n	35d8 <_read+0x34>
	}

	return n;
    35d6:	697b      	ldr	r3, [r7, #20]
}
    35d8:	4618      	mov	r0, r3
    35da:	3718      	adds	r7, #24
    35dc:	46bd      	mov	sp, r7
    35de:	bd80      	pop	{r7, pc}
    35e0:	00003671 	.word	0x00003671

000035e4 <_write>:
#include <stdio.h>

int __attribute__((weak)) _write(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
    35e4:	b580      	push	{r7, lr}
    35e6:	b086      	sub	sp, #24
    35e8:	af00      	add	r7, sp, #0
    35ea:	60f8      	str	r0, [r7, #12]
    35ec:	60b9      	str	r1, [r7, #8]
    35ee:	607a      	str	r2, [r7, #4]
	int n = 0;
    35f0:	2300      	movs	r3, #0
    35f2:	617b      	str	r3, [r7, #20]

	if ((file != 1) && (file != 2) && (file != 3)) {
    35f4:	68fb      	ldr	r3, [r7, #12]
    35f6:	2b01      	cmp	r3, #1
    35f8:	d008      	beq.n	360c <_write+0x28>
    35fa:	68fb      	ldr	r3, [r7, #12]
    35fc:	2b02      	cmp	r3, #2
    35fe:	d005      	beq.n	360c <_write+0x28>
    3600:	68fb      	ldr	r3, [r7, #12]
    3602:	2b03      	cmp	r3, #3
    3604:	d002      	beq.n	360c <_write+0x28>
		return -1;
    3606:	f04f 33ff 	mov.w	r3, #4294967295
    360a:	e00b      	b.n	3624 <_write+0x40>
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    360c:	6879      	ldr	r1, [r7, #4]
    360e:	68b8      	ldr	r0, [r7, #8]
    3610:	4b06      	ldr	r3, [pc, #24]	; (362c <_write+0x48>)
    3612:	4798      	blx	r3
    3614:	6178      	str	r0, [r7, #20]
	if (n < 0) {
    3616:	697b      	ldr	r3, [r7, #20]
    3618:	2b00      	cmp	r3, #0
    361a:	da02      	bge.n	3622 <_write+0x3e>
		return -1;
    361c:	f04f 33ff 	mov.w	r3, #4294967295
    3620:	e000      	b.n	3624 <_write+0x40>
	}

	return n;
    3622:	697b      	ldr	r3, [r7, #20]
}
    3624:	4618      	mov	r0, r3
    3626:	3718      	adds	r7, #24
    3628:	46bd      	mov	sp, r7
    362a:	bd80      	pop	{r7, pc}
    362c:	000036a9 	.word	0x000036a9

00003630 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    3630:	b580      	push	{r7, lr}
    3632:	b082      	sub	sp, #8
    3634:	af00      	add	r7, sp, #0
    3636:	6078      	str	r0, [r7, #4]
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    3638:	4b0a      	ldr	r3, [pc, #40]	; (3664 <stdio_io_init+0x34>)
    363a:	681b      	ldr	r3, [r3, #0]
    363c:	689b      	ldr	r3, [r3, #8]
    363e:	2100      	movs	r1, #0
    3640:	4618      	mov	r0, r3
    3642:	4b09      	ldr	r3, [pc, #36]	; (3668 <stdio_io_init+0x38>)
    3644:	4798      	blx	r3
	setbuf(stdin, NULL);
    3646:	4b07      	ldr	r3, [pc, #28]	; (3664 <stdio_io_init+0x34>)
    3648:	681b      	ldr	r3, [r3, #0]
    364a:	685b      	ldr	r3, [r3, #4]
    364c:	2100      	movs	r1, #0
    364e:	4618      	mov	r0, r3
    3650:	4b05      	ldr	r3, [pc, #20]	; (3668 <stdio_io_init+0x38>)
    3652:	4798      	blx	r3
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    3654:	4a05      	ldr	r2, [pc, #20]	; (366c <stdio_io_init+0x3c>)
    3656:	687b      	ldr	r3, [r7, #4]
    3658:	6013      	str	r3, [r2, #0]
}
    365a:	bf00      	nop
    365c:	3708      	adds	r7, #8
    365e:	46bd      	mov	sp, r7
    3660:	bd80      	pop	{r7, pc}
    3662:	bf00      	nop
    3664:	20000030 	.word	0x20000030
    3668:	00003ec5 	.word	0x00003ec5
    366c:	20001570 	.word	0x20001570

00003670 <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
    3670:	b580      	push	{r7, lr}
    3672:	b082      	sub	sp, #8
    3674:	af00      	add	r7, sp, #0
    3676:	6078      	str	r0, [r7, #4]
    3678:	6039      	str	r1, [r7, #0]
	if (stdio_io == NULL) {
    367a:	4b09      	ldr	r3, [pc, #36]	; (36a0 <stdio_io_read+0x30>)
    367c:	681b      	ldr	r3, [r3, #0]
    367e:	2b00      	cmp	r3, #0
    3680:	d101      	bne.n	3686 <stdio_io_read+0x16>
		return 0;
    3682:	2300      	movs	r3, #0
    3684:	e008      	b.n	3698 <stdio_io_read+0x28>
	}
	return io_read(stdio_io, buf, len);
    3686:	4b06      	ldr	r3, [pc, #24]	; (36a0 <stdio_io_read+0x30>)
    3688:	681b      	ldr	r3, [r3, #0]
    368a:	683a      	ldr	r2, [r7, #0]
    368c:	b292      	uxth	r2, r2
    368e:	6879      	ldr	r1, [r7, #4]
    3690:	4618      	mov	r0, r3
    3692:	4b04      	ldr	r3, [pc, #16]	; (36a4 <stdio_io_read+0x34>)
    3694:	4798      	blx	r3
    3696:	4603      	mov	r3, r0
}
    3698:	4618      	mov	r0, r3
    369a:	3708      	adds	r7, #8
    369c:	46bd      	mov	sp, r7
    369e:	bd80      	pop	{r7, pc}
    36a0:	20001570 	.word	0x20001570
    36a4:	000013a9 	.word	0x000013a9

000036a8 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
    36a8:	b580      	push	{r7, lr}
    36aa:	b082      	sub	sp, #8
    36ac:	af00      	add	r7, sp, #0
    36ae:	6078      	str	r0, [r7, #4]
    36b0:	6039      	str	r1, [r7, #0]
	if (stdio_io == NULL) {
    36b2:	4b09      	ldr	r3, [pc, #36]	; (36d8 <stdio_io_write+0x30>)
    36b4:	681b      	ldr	r3, [r3, #0]
    36b6:	2b00      	cmp	r3, #0
    36b8:	d101      	bne.n	36be <stdio_io_write+0x16>
		return 0;
    36ba:	2300      	movs	r3, #0
    36bc:	e008      	b.n	36d0 <stdio_io_write+0x28>
	}
	return io_write(stdio_io, buf, len);
    36be:	4b06      	ldr	r3, [pc, #24]	; (36d8 <stdio_io_write+0x30>)
    36c0:	681b      	ldr	r3, [r3, #0]
    36c2:	683a      	ldr	r2, [r7, #0]
    36c4:	b292      	uxth	r2, r2
    36c6:	6879      	ldr	r1, [r7, #4]
    36c8:	4618      	mov	r0, r3
    36ca:	4b04      	ldr	r3, [pc, #16]	; (36dc <stdio_io_write+0x34>)
    36cc:	4798      	blx	r3
    36ce:	4603      	mov	r3, r0
}
    36d0:	4618      	mov	r0, r3
    36d2:	3708      	adds	r7, #8
    36d4:	46bd      	mov	sp, r7
    36d6:	bd80      	pop	{r7, pc}
    36d8:	20001570 	.word	0x20001570
    36dc:	00001359 	.word	0x00001359

000036e0 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    36e0:	b580      	push	{r7, lr}
    36e2:	af00      	add	r7, sp, #0

	usart_sync_enable(&TARGET_IO);
    36e4:	4803      	ldr	r0, [pc, #12]	; (36f4 <stdio_redirect_init+0x14>)
    36e6:	4b04      	ldr	r3, [pc, #16]	; (36f8 <stdio_redirect_init+0x18>)
    36e8:	4798      	blx	r3
	stdio_io_init(&TARGET_IO.io);
    36ea:	4802      	ldr	r0, [pc, #8]	; (36f4 <stdio_redirect_init+0x14>)
    36ec:	4b03      	ldr	r3, [pc, #12]	; (36fc <stdio_redirect_init+0x1c>)
    36ee:	4798      	blx	r3
}
    36f0:	bf00      	nop
    36f2:	bd80      	pop	{r7, pc}
    36f4:	200016d0 	.word	0x200016d0
    36f8:	000014f1 	.word	0x000014f1
    36fc:	00003631 	.word	0x00003631

00003700 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    3700:	b480      	push	{r7}
    3702:	b085      	sub	sp, #20
    3704:	af00      	add	r7, sp, #0
    3706:	6078      	str	r0, [r7, #4]
    3708:	6039      	str	r1, [r7, #0]
	ListItem_t *const pxIndex = pxList->pxIndex;
    370a:	687b      	ldr	r3, [r7, #4]
    370c:	685b      	ldr	r3, [r3, #4]
    370e:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    3710:	683b      	ldr	r3, [r7, #0]
    3712:	68fa      	ldr	r2, [r7, #12]
    3714:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3716:	68fb      	ldr	r3, [r7, #12]
    3718:	689a      	ldr	r2, [r3, #8]
    371a:	683b      	ldr	r3, [r7, #0]
    371c:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    371e:	68fb      	ldr	r3, [r7, #12]
    3720:	689b      	ldr	r3, [r3, #8]
    3722:	683a      	ldr	r2, [r7, #0]
    3724:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    3726:	68fb      	ldr	r3, [r7, #12]
    3728:	683a      	ldr	r2, [r7, #0]
    372a:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;
    372c:	683b      	ldr	r3, [r7, #0]
    372e:	687a      	ldr	r2, [r7, #4]
    3730:	611a      	str	r2, [r3, #16]

	(pxList->uxNumberOfItems)++;
    3732:	687b      	ldr	r3, [r7, #4]
    3734:	681b      	ldr	r3, [r3, #0]
    3736:	1c5a      	adds	r2, r3, #1
    3738:	687b      	ldr	r3, [r7, #4]
    373a:	601a      	str	r2, [r3, #0]
}
    373c:	bf00      	nop
    373e:	3714      	adds	r7, #20
    3740:	46bd      	mov	sp, r7
    3742:	f85d 7b04 	ldr.w	r7, [sp], #4
    3746:	4770      	bx	lr

00003748 <uxListRemove>:
	(pxList->uxNumberOfItems)++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove(ListItem_t *const pxItemToRemove)
{
    3748:	b480      	push	{r7}
    374a:	b085      	sub	sp, #20
    374c:	af00      	add	r7, sp, #0
    374e:	6078      	str	r0, [r7, #4]
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    3750:	687b      	ldr	r3, [r7, #4]
    3752:	691b      	ldr	r3, [r3, #16]
    3754:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3756:	687b      	ldr	r3, [r7, #4]
    3758:	685b      	ldr	r3, [r3, #4]
    375a:	687a      	ldr	r2, [r7, #4]
    375c:	6892      	ldr	r2, [r2, #8]
    375e:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3760:	687b      	ldr	r3, [r7, #4]
    3762:	689b      	ldr	r3, [r3, #8]
    3764:	687a      	ldr	r2, [r7, #4]
    3766:	6852      	ldr	r2, [r2, #4]
    3768:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    376a:	68fb      	ldr	r3, [r7, #12]
    376c:	685a      	ldr	r2, [r3, #4]
    376e:	687b      	ldr	r3, [r7, #4]
    3770:	429a      	cmp	r2, r3
    3772:	d103      	bne.n	377c <uxListRemove+0x34>
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3774:	687b      	ldr	r3, [r7, #4]
    3776:	689a      	ldr	r2, [r3, #8]
    3778:	68fb      	ldr	r3, [r7, #12]
    377a:	605a      	str	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    377c:	687b      	ldr	r3, [r7, #4]
    377e:	2200      	movs	r2, #0
    3780:	611a      	str	r2, [r3, #16]
	(pxList->uxNumberOfItems)--;
    3782:	68fb      	ldr	r3, [r7, #12]
    3784:	681b      	ldr	r3, [r3, #0]
    3786:	1e5a      	subs	r2, r3, #1
    3788:	68fb      	ldr	r3, [r7, #12]
    378a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    378c:	68fb      	ldr	r3, [r7, #12]
    378e:	681b      	ldr	r3, [r3, #0]
}
    3790:	4618      	mov	r0, r3
    3792:	3714      	adds	r7, #20
    3794:	46bd      	mov	sp, r7
    3796:	f85d 7b04 	ldr.w	r7, [sp], #4
    379a:	4770      	bx	lr

0000379c <SVCall_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler(void)
{
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    379c:	4b06      	ldr	r3, [pc, #24]	; (37b8 <pxCurrentTCBConst2>)
    379e:	6819      	ldr	r1, [r3, #0]
    37a0:	6808      	ldr	r0, [r1, #0]
    37a2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    37a6:	f380 8809 	msr	PSP, r0
    37aa:	f3bf 8f6f 	isb	sy
    37ae:	f04f 0000 	mov.w	r0, #0
    37b2:	f380 8811 	msr	BASEPRI, r0
    37b6:	4770      	bx	lr

000037b8 <pxCurrentTCBConst2>:
    37b8:	20001574 	.word	0x20001574
	               "	msr	basepri, r0					\n"
	               "	bx r14							\n"
	               "									\n"
	               "	.align 2						\n"
	               "pxCurrentTCBConst2: .word pxCurrentTCB				\n");
}
    37bc:	bf00      	nop
    37be:	bf00      	nop

000037c0 <PendSV_Handler>:

void xPortPendSVHandler(void)
{
	/* This is a naked function. */

	__asm volatile(
    37c0:	f3ef 8009 	mrs	r0, PSP
    37c4:	f3bf 8f6f 	isb	sy
    37c8:	4b14      	ldr	r3, [pc, #80]	; (381c <pxCurrentTCBConst>)
    37ca:	681a      	ldr	r2, [r3, #0]
    37cc:	f01e 0f10 	tst.w	lr, #16
    37d0:	bf08      	it	eq
    37d2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    37d6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    37da:	6010      	str	r0, [r2, #0]
    37dc:	f84d 3d04 	str.w	r3, [sp, #-4]!
    37e0:	f04f 0080 	mov.w	r0, #128	; 0x80
    37e4:	f380 8811 	msr	BASEPRI, r0
    37e8:	f3bf 8f4f 	dsb	sy
    37ec:	f3bf 8f6f 	isb	sy
    37f0:	f000 f902 	bl	39f8 <vTaskSwitchContext>
    37f4:	f04f 0000 	mov.w	r0, #0
    37f8:	f380 8811 	msr	BASEPRI, r0
    37fc:	bc08      	pop	{r3}
    37fe:	6819      	ldr	r1, [r3, #0]
    3800:	6808      	ldr	r0, [r1, #0]
    3802:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3806:	f01e 0f10 	tst.w	lr, #16
    380a:	bf08      	it	eq
    380c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    3810:	f380 8809 	msr	PSP, r0
    3814:	f3bf 8f6f 	isb	sy
    3818:	4770      	bx	lr
    381a:	bf00      	nop

0000381c <pxCurrentTCBConst>:
    381c:	20001574 	.word	0x20001574
	    "										\n"
	    "	bx r14								\n"
	    "										\n"
	    "	.align 2							\n"
	    "pxCurrentTCBConst: .word pxCurrentTCB	\n" ::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY));
}
    3820:	bf00      	nop
    3822:	bf00      	nop

00003824 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler(void)
{
    3824:	b580      	push	{r7, lr}
    3826:	b084      	sub	sp, #16
    3828:	af00      	add	r7, sp, #0

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI(void)
{
	uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile("	mrs %0, basepri											\n"
    382a:	f3ef 8211 	mrs	r2, BASEPRI
    382e:	f04f 0380 	mov.w	r3, #128	; 0x80
    3832:	f383 8811 	msr	BASEPRI, r3
    3836:	f3bf 8f6f 	isb	sy
    383a:	f3bf 8f4f 	dsb	sy
    383e:	60fa      	str	r2, [r7, #12]
    3840:	60bb      	str	r3, [r7, #8]
	save and then restore the interrupt mask value as its value is already
	known. */
	(void)portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Increment the RTOS tick. */
		if (xTaskIncrementTick() != pdFALSE) {
    3842:	4b09      	ldr	r3, [pc, #36]	; (3868 <SysTick_Handler+0x44>)
    3844:	4798      	blx	r3
    3846:	4603      	mov	r3, r0
    3848:	2b00      	cmp	r3, #0
    384a:	d003      	beq.n	3854 <SysTick_Handler+0x30>
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    384c:	4b07      	ldr	r3, [pc, #28]	; (386c <SysTick_Handler+0x48>)
    384e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    3852:	601a      	str	r2, [r3, #0]
    3854:	2300      	movs	r3, #0
    3856:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue));
    3858:	687b      	ldr	r3, [r7, #4]
    385a:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(0);
}
    385e:	bf00      	nop
    3860:	3710      	adds	r7, #16
    3862:	46bd      	mov	sp, r7
    3864:	bd80      	pop	{r7, pc}
    3866:	bf00      	nop
    3868:	00003871 	.word	0x00003871
    386c:	e000ed04 	.word	0xe000ed04

00003870 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick(void)
{
    3870:	b580      	push	{r7, lr}
    3872:	b086      	sub	sp, #24
    3874:	af00      	add	r7, sp, #0
	TCB_t *    pxTCB;
	TickType_t xItemValue;
	BaseType_t xSwitchRequired = pdFALSE;
    3876:	2300      	movs	r3, #0
    3878:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK(xTickCount);
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
    387a:	4b51      	ldr	r3, [pc, #324]	; (39c0 <xTaskIncrementTick+0x150>)
    387c:	681b      	ldr	r3, [r3, #0]
    387e:	2b00      	cmp	r3, #0
    3880:	f040 808e 	bne.w	39a0 <xTaskIncrementTick+0x130>
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    3884:	4b4f      	ldr	r3, [pc, #316]	; (39c4 <xTaskIncrementTick+0x154>)
    3886:	681b      	ldr	r3, [r3, #0]
    3888:	3301      	adds	r3, #1
    388a:	4a4e      	ldr	r2, [pc, #312]	; (39c4 <xTaskIncrementTick+0x154>)
    388c:	6013      	str	r3, [r2, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    388e:	4b4d      	ldr	r3, [pc, #308]	; (39c4 <xTaskIncrementTick+0x154>)
    3890:	681b      	ldr	r3, [r3, #0]
    3892:	613b      	str	r3, [r7, #16]

			if (xConstTickCount == (TickType_t)0U) {
    3894:	693b      	ldr	r3, [r7, #16]
    3896:	2b00      	cmp	r3, #0
    3898:	d11f      	bne.n	38da <xTaskIncrementTick+0x6a>
				taskSWITCH_DELAYED_LISTS();
    389a:	4b4b      	ldr	r3, [pc, #300]	; (39c8 <xTaskIncrementTick+0x158>)
    389c:	681b      	ldr	r3, [r3, #0]
    389e:	681b      	ldr	r3, [r3, #0]
    38a0:	2b00      	cmp	r3, #0
    38a2:	d009      	beq.n	38b8 <xTaskIncrementTick+0x48>
	__asm volatile("	mov %0, %1												\n"
    38a4:	f04f 0380 	mov.w	r3, #128	; 0x80
    38a8:	f383 8811 	msr	BASEPRI, r3
    38ac:	f3bf 8f6f 	isb	sy
    38b0:	f3bf 8f4f 	dsb	sy
    38b4:	603b      	str	r3, [r7, #0]
    38b6:	e7fe      	b.n	38b6 <xTaskIncrementTick+0x46>
    38b8:	4b43      	ldr	r3, [pc, #268]	; (39c8 <xTaskIncrementTick+0x158>)
    38ba:	681b      	ldr	r3, [r3, #0]
    38bc:	60fb      	str	r3, [r7, #12]
    38be:	4b43      	ldr	r3, [pc, #268]	; (39cc <xTaskIncrementTick+0x15c>)
    38c0:	681b      	ldr	r3, [r3, #0]
    38c2:	4a41      	ldr	r2, [pc, #260]	; (39c8 <xTaskIncrementTick+0x158>)
    38c4:	6013      	str	r3, [r2, #0]
    38c6:	4a41      	ldr	r2, [pc, #260]	; (39cc <xTaskIncrementTick+0x15c>)
    38c8:	68fb      	ldr	r3, [r7, #12]
    38ca:	6013      	str	r3, [r2, #0]
    38cc:	4b40      	ldr	r3, [pc, #256]	; (39d0 <xTaskIncrementTick+0x160>)
    38ce:	681b      	ldr	r3, [r3, #0]
    38d0:	3301      	adds	r3, #1
    38d2:	4a3f      	ldr	r2, [pc, #252]	; (39d0 <xTaskIncrementTick+0x160>)
    38d4:	6013      	str	r3, [r2, #0]
    38d6:	4b3f      	ldr	r3, [pc, #252]	; (39d4 <xTaskIncrementTick+0x164>)
    38d8:	4798      	blx	r3

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if (xConstTickCount >= xNextTaskUnblockTime) {
    38da:	4b3f      	ldr	r3, [pc, #252]	; (39d8 <xTaskIncrementTick+0x168>)
    38dc:	681b      	ldr	r3, [r3, #0]
    38de:	693a      	ldr	r2, [r7, #16]
    38e0:	429a      	cmp	r2, r3
    38e2:	d34e      	bcc.n	3982 <xTaskIncrementTick+0x112>
				for (;;) {
					if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    38e4:	4b38      	ldr	r3, [pc, #224]	; (39c8 <xTaskIncrementTick+0x158>)
    38e6:	681b      	ldr	r3, [r3, #0]
    38e8:	681b      	ldr	r3, [r3, #0]
    38ea:	2b00      	cmp	r3, #0
    38ec:	d101      	bne.n	38f2 <xTaskIncrementTick+0x82>
    38ee:	2301      	movs	r3, #1
    38f0:	e000      	b.n	38f4 <xTaskIncrementTick+0x84>
    38f2:	2300      	movs	r3, #0
    38f4:	2b00      	cmp	r3, #0
    38f6:	d004      	beq.n	3902 <xTaskIncrementTick+0x92>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    38f8:	4b37      	ldr	r3, [pc, #220]	; (39d8 <xTaskIncrementTick+0x168>)
    38fa:	f04f 32ff 	mov.w	r2, #4294967295
    38fe:	601a      	str	r2, [r3, #0]
						break;
    3900:	e03f      	b.n	3982 <xTaskIncrementTick+0x112>
					} else {
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    3902:	4b31      	ldr	r3, [pc, #196]	; (39c8 <xTaskIncrementTick+0x158>)
    3904:	681b      	ldr	r3, [r3, #0]
    3906:	68db      	ldr	r3, [r3, #12]
    3908:	68db      	ldr	r3, [r3, #12]
    390a:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xGenericListItem));
    390c:	68bb      	ldr	r3, [r7, #8]
    390e:	685b      	ldr	r3, [r3, #4]
    3910:	607b      	str	r3, [r7, #4]

						if (xConstTickCount < xItemValue) {
    3912:	693a      	ldr	r2, [r7, #16]
    3914:	687b      	ldr	r3, [r7, #4]
    3916:	429a      	cmp	r2, r3
    3918:	d203      	bcs.n	3922 <xTaskIncrementTick+0xb2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    391a:	4a2f      	ldr	r2, [pc, #188]	; (39d8 <xTaskIncrementTick+0x168>)
    391c:	687b      	ldr	r3, [r7, #4]
    391e:	6013      	str	r3, [r2, #0]
							break;
    3920:	e02f      	b.n	3982 <xTaskIncrementTick+0x112>
						} else {
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						(void)uxListRemove(&(pxTCB->xGenericListItem));
    3922:	68bb      	ldr	r3, [r7, #8]
    3924:	3304      	adds	r3, #4
    3926:	4618      	mov	r0, r3
    3928:	4b2c      	ldr	r3, [pc, #176]	; (39dc <xTaskIncrementTick+0x16c>)
    392a:	4798      	blx	r3

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
    392c:	68bb      	ldr	r3, [r7, #8]
    392e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3930:	2b00      	cmp	r3, #0
    3932:	d004      	beq.n	393e <xTaskIncrementTick+0xce>
							(void)uxListRemove(&(pxTCB->xEventListItem));
    3934:	68bb      	ldr	r3, [r7, #8]
    3936:	3318      	adds	r3, #24
    3938:	4618      	mov	r0, r3
    393a:	4b28      	ldr	r3, [pc, #160]	; (39dc <xTaskIncrementTick+0x16c>)
    393c:	4798      	blx	r3
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList(pxTCB);
    393e:	68bb      	ldr	r3, [r7, #8]
    3940:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3942:	4b27      	ldr	r3, [pc, #156]	; (39e0 <xTaskIncrementTick+0x170>)
    3944:	681b      	ldr	r3, [r3, #0]
    3946:	429a      	cmp	r2, r3
    3948:	d903      	bls.n	3952 <xTaskIncrementTick+0xe2>
    394a:	68bb      	ldr	r3, [r7, #8]
    394c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    394e:	4a24      	ldr	r2, [pc, #144]	; (39e0 <xTaskIncrementTick+0x170>)
    3950:	6013      	str	r3, [r2, #0]
    3952:	68bb      	ldr	r3, [r7, #8]
    3954:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3956:	4613      	mov	r3, r2
    3958:	009b      	lsls	r3, r3, #2
    395a:	4413      	add	r3, r2
    395c:	009b      	lsls	r3, r3, #2
    395e:	4a21      	ldr	r2, [pc, #132]	; (39e4 <xTaskIncrementTick+0x174>)
    3960:	441a      	add	r2, r3
    3962:	68bb      	ldr	r3, [r7, #8]
    3964:	3304      	adds	r3, #4
    3966:	4619      	mov	r1, r3
    3968:	4610      	mov	r0, r2
    396a:	4b1f      	ldr	r3, [pc, #124]	; (39e8 <xTaskIncrementTick+0x178>)
    396c:	4798      	blx	r3
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
    396e:	68bb      	ldr	r3, [r7, #8]
    3970:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3972:	4b1e      	ldr	r3, [pc, #120]	; (39ec <xTaskIncrementTick+0x17c>)
    3974:	681b      	ldr	r3, [r3, #0]
    3976:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3978:	429a      	cmp	r2, r3
    397a:	d3b3      	bcc.n	38e4 <xTaskIncrementTick+0x74>
								xSwitchRequired = pdTRUE;
    397c:	2301      	movs	r3, #1
    397e:	617b      	str	r3, [r7, #20]
					if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    3980:	e7b0      	b.n	38e4 <xTaskIncrementTick+0x74>
/* Tasks of equal priority to the currently running task will share
processing time (time slice) if preemption is on, and the application
writer has not explicitly turned time slicing off. */
#if ((configUSE_PREEMPTION == 1) && (configUSE_TIME_SLICING == 1))
		{
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
    3982:	4b1a      	ldr	r3, [pc, #104]	; (39ec <xTaskIncrementTick+0x17c>)
    3984:	681b      	ldr	r3, [r3, #0]
    3986:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3988:	4916      	ldr	r1, [pc, #88]	; (39e4 <xTaskIncrementTick+0x174>)
    398a:	4613      	mov	r3, r2
    398c:	009b      	lsls	r3, r3, #2
    398e:	4413      	add	r3, r2
    3990:	009b      	lsls	r3, r3, #2
    3992:	440b      	add	r3, r1
    3994:	681b      	ldr	r3, [r3, #0]
    3996:	2b01      	cmp	r3, #1
    3998:	d907      	bls.n	39aa <xTaskIncrementTick+0x13a>
				xSwitchRequired = pdTRUE;
    399a:	2301      	movs	r3, #1
    399c:	617b      	str	r3, [r7, #20]
    399e:	e004      	b.n	39aa <xTaskIncrementTick+0x13a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
#endif /* configUSE_TICK_HOOK */
	} else {
		++uxPendedTicks;
    39a0:	4b13      	ldr	r3, [pc, #76]	; (39f0 <xTaskIncrementTick+0x180>)
    39a2:	681b      	ldr	r3, [r3, #0]
    39a4:	3301      	adds	r3, #1
    39a6:	4a12      	ldr	r2, [pc, #72]	; (39f0 <xTaskIncrementTick+0x180>)
    39a8:	6013      	str	r3, [r2, #0]
#endif
	}

#if (configUSE_PREEMPTION == 1)
	{
		if (xYieldPending != pdFALSE) {
    39aa:	4b12      	ldr	r3, [pc, #72]	; (39f4 <xTaskIncrementTick+0x184>)
    39ac:	681b      	ldr	r3, [r3, #0]
    39ae:	2b00      	cmp	r3, #0
    39b0:	d001      	beq.n	39b6 <xTaskIncrementTick+0x146>
			xSwitchRequired = pdTRUE;
    39b2:	2301      	movs	r3, #1
    39b4:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    39b6:	697b      	ldr	r3, [r7, #20]
}
    39b8:	4618      	mov	r0, r3
    39ba:	3718      	adds	r7, #24
    39bc:	46bd      	mov	sp, r7
    39be:	bd80      	pop	{r7, pc}
    39c0:	20001670 	.word	0x20001670
    39c4:	20001650 	.word	0x20001650
    39c8:	20001604 	.word	0x20001604
    39cc:	20001608 	.word	0x20001608
    39d0:	20001664 	.word	0x20001664
    39d4:	00003ab1 	.word	0x00003ab1
    39d8:	2000166c 	.word	0x2000166c
    39dc:	00003749 	.word	0x00003749
    39e0:	20001654 	.word	0x20001654
    39e4:	20001578 	.word	0x20001578
    39e8:	00003701 	.word	0x00003701
    39ec:	20001574 	.word	0x20001574
    39f0:	2000165c 	.word	0x2000165c
    39f4:	20001660 	.word	0x20001660

000039f8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext(void)
{
    39f8:	b480      	push	{r7}
    39fa:	b083      	sub	sp, #12
    39fc:	af00      	add	r7, sp, #0
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
    39fe:	4b27      	ldr	r3, [pc, #156]	; (3a9c <vTaskSwitchContext+0xa4>)
    3a00:	681b      	ldr	r3, [r3, #0]
    3a02:	2b00      	cmp	r3, #0
    3a04:	d003      	beq.n	3a0e <vTaskSwitchContext+0x16>
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3a06:	4b26      	ldr	r3, [pc, #152]	; (3aa0 <vTaskSwitchContext+0xa8>)
    3a08:	2201      	movs	r2, #1
    3a0a:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &(pxCurrentTCB->xNewLib_reent);
		}
#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3a0c:	e03f      	b.n	3a8e <vTaskSwitchContext+0x96>
		xYieldPending = pdFALSE;
    3a0e:	4b24      	ldr	r3, [pc, #144]	; (3aa0 <vTaskSwitchContext+0xa8>)
    3a10:	2200      	movs	r2, #0
    3a12:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
    3a14:	e012      	b.n	3a3c <vTaskSwitchContext+0x44>
    3a16:	4b23      	ldr	r3, [pc, #140]	; (3aa4 <vTaskSwitchContext+0xac>)
    3a18:	681b      	ldr	r3, [r3, #0]
    3a1a:	2b00      	cmp	r3, #0
    3a1c:	d109      	bne.n	3a32 <vTaskSwitchContext+0x3a>
    3a1e:	f04f 0380 	mov.w	r3, #128	; 0x80
    3a22:	f383 8811 	msr	BASEPRI, r3
    3a26:	f3bf 8f6f 	isb	sy
    3a2a:	f3bf 8f4f 	dsb	sy
    3a2e:	603b      	str	r3, [r7, #0]
    3a30:	e7fe      	b.n	3a30 <vTaskSwitchContext+0x38>
    3a32:	4b1c      	ldr	r3, [pc, #112]	; (3aa4 <vTaskSwitchContext+0xac>)
    3a34:	681b      	ldr	r3, [r3, #0]
    3a36:	3b01      	subs	r3, #1
    3a38:	4a1a      	ldr	r2, [pc, #104]	; (3aa4 <vTaskSwitchContext+0xac>)
    3a3a:	6013      	str	r3, [r2, #0]
    3a3c:	4b19      	ldr	r3, [pc, #100]	; (3aa4 <vTaskSwitchContext+0xac>)
    3a3e:	681a      	ldr	r2, [r3, #0]
    3a40:	4919      	ldr	r1, [pc, #100]	; (3aa8 <vTaskSwitchContext+0xb0>)
    3a42:	4613      	mov	r3, r2
    3a44:	009b      	lsls	r3, r3, #2
    3a46:	4413      	add	r3, r2
    3a48:	009b      	lsls	r3, r3, #2
    3a4a:	440b      	add	r3, r1
    3a4c:	681b      	ldr	r3, [r3, #0]
    3a4e:	2b00      	cmp	r3, #0
    3a50:	d0e1      	beq.n	3a16 <vTaskSwitchContext+0x1e>
    3a52:	4b14      	ldr	r3, [pc, #80]	; (3aa4 <vTaskSwitchContext+0xac>)
    3a54:	681a      	ldr	r2, [r3, #0]
    3a56:	4613      	mov	r3, r2
    3a58:	009b      	lsls	r3, r3, #2
    3a5a:	4413      	add	r3, r2
    3a5c:	009b      	lsls	r3, r3, #2
    3a5e:	4a12      	ldr	r2, [pc, #72]	; (3aa8 <vTaskSwitchContext+0xb0>)
    3a60:	4413      	add	r3, r2
    3a62:	607b      	str	r3, [r7, #4]
    3a64:	687b      	ldr	r3, [r7, #4]
    3a66:	685b      	ldr	r3, [r3, #4]
    3a68:	685a      	ldr	r2, [r3, #4]
    3a6a:	687b      	ldr	r3, [r7, #4]
    3a6c:	605a      	str	r2, [r3, #4]
    3a6e:	687b      	ldr	r3, [r7, #4]
    3a70:	685a      	ldr	r2, [r3, #4]
    3a72:	687b      	ldr	r3, [r7, #4]
    3a74:	3308      	adds	r3, #8
    3a76:	429a      	cmp	r2, r3
    3a78:	d104      	bne.n	3a84 <vTaskSwitchContext+0x8c>
    3a7a:	687b      	ldr	r3, [r7, #4]
    3a7c:	685b      	ldr	r3, [r3, #4]
    3a7e:	685a      	ldr	r2, [r3, #4]
    3a80:	687b      	ldr	r3, [r7, #4]
    3a82:	605a      	str	r2, [r3, #4]
    3a84:	687b      	ldr	r3, [r7, #4]
    3a86:	685b      	ldr	r3, [r3, #4]
    3a88:	68db      	ldr	r3, [r3, #12]
    3a8a:	4a08      	ldr	r2, [pc, #32]	; (3aac <vTaskSwitchContext+0xb4>)
    3a8c:	6013      	str	r3, [r2, #0]
}
    3a8e:	bf00      	nop
    3a90:	370c      	adds	r7, #12
    3a92:	46bd      	mov	sp, r7
    3a94:	f85d 7b04 	ldr.w	r7, [sp], #4
    3a98:	4770      	bx	lr
    3a9a:	bf00      	nop
    3a9c:	20001670 	.word	0x20001670
    3aa0:	20001660 	.word	0x20001660
    3aa4:	20001654 	.word	0x20001654
    3aa8:	20001578 	.word	0x20001578
    3aac:	20001574 	.word	0x20001574

00003ab0 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime(void)
{
    3ab0:	b480      	push	{r7}
    3ab2:	b083      	sub	sp, #12
    3ab4:	af00      	add	r7, sp, #0
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
    3ab6:	4b0f      	ldr	r3, [pc, #60]	; (3af4 <prvResetNextTaskUnblockTime+0x44>)
    3ab8:	681b      	ldr	r3, [r3, #0]
    3aba:	681b      	ldr	r3, [r3, #0]
    3abc:	2b00      	cmp	r3, #0
    3abe:	d101      	bne.n	3ac4 <prvResetNextTaskUnblockTime+0x14>
    3ac0:	2301      	movs	r3, #1
    3ac2:	e000      	b.n	3ac6 <prvResetNextTaskUnblockTime+0x16>
    3ac4:	2300      	movs	r3, #0
    3ac6:	2b00      	cmp	r3, #0
    3ac8:	d004      	beq.n	3ad4 <prvResetNextTaskUnblockTime+0x24>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3aca:	4b0b      	ldr	r3, [pc, #44]	; (3af8 <prvResetNextTaskUnblockTime+0x48>)
    3acc:	f04f 32ff 	mov.w	r2, #4294967295
    3ad0:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
	}
}
    3ad2:	e008      	b.n	3ae6 <prvResetNextTaskUnblockTime+0x36>
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
    3ad4:	4b07      	ldr	r3, [pc, #28]	; (3af4 <prvResetNextTaskUnblockTime+0x44>)
    3ad6:	681b      	ldr	r3, [r3, #0]
    3ad8:	68db      	ldr	r3, [r3, #12]
    3ada:	68db      	ldr	r3, [r3, #12]
    3adc:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xGenericListItem));
    3ade:	687b      	ldr	r3, [r7, #4]
    3ae0:	685b      	ldr	r3, [r3, #4]
    3ae2:	4a05      	ldr	r2, [pc, #20]	; (3af8 <prvResetNextTaskUnblockTime+0x48>)
    3ae4:	6013      	str	r3, [r2, #0]
}
    3ae6:	bf00      	nop
    3ae8:	370c      	adds	r7, #12
    3aea:	46bd      	mov	sp, r7
    3aec:	f85d 7b04 	ldr.w	r7, [sp], #4
    3af0:	4770      	bx	lr
    3af2:	bf00      	nop
    3af4:	20001604 	.word	0x20001604
    3af8:	2000166c 	.word	0x2000166c

00003afc <__aeabi_drsub>:
    3afc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    3b00:	e002      	b.n	3b08 <__adddf3>
    3b02:	bf00      	nop

00003b04 <__aeabi_dsub>:
    3b04:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00003b08 <__adddf3>:
    3b08:	b530      	push	{r4, r5, lr}
    3b0a:	ea4f 0441 	mov.w	r4, r1, lsl #1
    3b0e:	ea4f 0543 	mov.w	r5, r3, lsl #1
    3b12:	ea94 0f05 	teq	r4, r5
    3b16:	bf08      	it	eq
    3b18:	ea90 0f02 	teqeq	r0, r2
    3b1c:	bf1f      	itttt	ne
    3b1e:	ea54 0c00 	orrsne.w	ip, r4, r0
    3b22:	ea55 0c02 	orrsne.w	ip, r5, r2
    3b26:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    3b2a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    3b2e:	f000 80e2 	beq.w	3cf6 <__adddf3+0x1ee>
    3b32:	ea4f 5454 	mov.w	r4, r4, lsr #21
    3b36:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    3b3a:	bfb8      	it	lt
    3b3c:	426d      	neglt	r5, r5
    3b3e:	dd0c      	ble.n	3b5a <__adddf3+0x52>
    3b40:	442c      	add	r4, r5
    3b42:	ea80 0202 	eor.w	r2, r0, r2
    3b46:	ea81 0303 	eor.w	r3, r1, r3
    3b4a:	ea82 0000 	eor.w	r0, r2, r0
    3b4e:	ea83 0101 	eor.w	r1, r3, r1
    3b52:	ea80 0202 	eor.w	r2, r0, r2
    3b56:	ea81 0303 	eor.w	r3, r1, r3
    3b5a:	2d36      	cmp	r5, #54	; 0x36
    3b5c:	bf88      	it	hi
    3b5e:	bd30      	pophi	{r4, r5, pc}
    3b60:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    3b64:	ea4f 3101 	mov.w	r1, r1, lsl #12
    3b68:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    3b6c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    3b70:	d002      	beq.n	3b78 <__adddf3+0x70>
    3b72:	4240      	negs	r0, r0
    3b74:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    3b78:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    3b7c:	ea4f 3303 	mov.w	r3, r3, lsl #12
    3b80:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    3b84:	d002      	beq.n	3b8c <__adddf3+0x84>
    3b86:	4252      	negs	r2, r2
    3b88:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    3b8c:	ea94 0f05 	teq	r4, r5
    3b90:	f000 80a7 	beq.w	3ce2 <__adddf3+0x1da>
    3b94:	f1a4 0401 	sub.w	r4, r4, #1
    3b98:	f1d5 0e20 	rsbs	lr, r5, #32
    3b9c:	db0d      	blt.n	3bba <__adddf3+0xb2>
    3b9e:	fa02 fc0e 	lsl.w	ip, r2, lr
    3ba2:	fa22 f205 	lsr.w	r2, r2, r5
    3ba6:	1880      	adds	r0, r0, r2
    3ba8:	f141 0100 	adc.w	r1, r1, #0
    3bac:	fa03 f20e 	lsl.w	r2, r3, lr
    3bb0:	1880      	adds	r0, r0, r2
    3bb2:	fa43 f305 	asr.w	r3, r3, r5
    3bb6:	4159      	adcs	r1, r3
    3bb8:	e00e      	b.n	3bd8 <__adddf3+0xd0>
    3bba:	f1a5 0520 	sub.w	r5, r5, #32
    3bbe:	f10e 0e20 	add.w	lr, lr, #32
    3bc2:	2a01      	cmp	r2, #1
    3bc4:	fa03 fc0e 	lsl.w	ip, r3, lr
    3bc8:	bf28      	it	cs
    3bca:	f04c 0c02 	orrcs.w	ip, ip, #2
    3bce:	fa43 f305 	asr.w	r3, r3, r5
    3bd2:	18c0      	adds	r0, r0, r3
    3bd4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    3bd8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    3bdc:	d507      	bpl.n	3bee <__adddf3+0xe6>
    3bde:	f04f 0e00 	mov.w	lr, #0
    3be2:	f1dc 0c00 	rsbs	ip, ip, #0
    3be6:	eb7e 0000 	sbcs.w	r0, lr, r0
    3bea:	eb6e 0101 	sbc.w	r1, lr, r1
    3bee:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    3bf2:	d31b      	bcc.n	3c2c <__adddf3+0x124>
    3bf4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    3bf8:	d30c      	bcc.n	3c14 <__adddf3+0x10c>
    3bfa:	0849      	lsrs	r1, r1, #1
    3bfc:	ea5f 0030 	movs.w	r0, r0, rrx
    3c00:	ea4f 0c3c 	mov.w	ip, ip, rrx
    3c04:	f104 0401 	add.w	r4, r4, #1
    3c08:	ea4f 5244 	mov.w	r2, r4, lsl #21
    3c0c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    3c10:	f080 809a 	bcs.w	3d48 <__adddf3+0x240>
    3c14:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    3c18:	bf08      	it	eq
    3c1a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    3c1e:	f150 0000 	adcs.w	r0, r0, #0
    3c22:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    3c26:	ea41 0105 	orr.w	r1, r1, r5
    3c2a:	bd30      	pop	{r4, r5, pc}
    3c2c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    3c30:	4140      	adcs	r0, r0
    3c32:	eb41 0101 	adc.w	r1, r1, r1
    3c36:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    3c3a:	f1a4 0401 	sub.w	r4, r4, #1
    3c3e:	d1e9      	bne.n	3c14 <__adddf3+0x10c>
    3c40:	f091 0f00 	teq	r1, #0
    3c44:	bf04      	itt	eq
    3c46:	4601      	moveq	r1, r0
    3c48:	2000      	moveq	r0, #0
    3c4a:	fab1 f381 	clz	r3, r1
    3c4e:	bf08      	it	eq
    3c50:	3320      	addeq	r3, #32
    3c52:	f1a3 030b 	sub.w	r3, r3, #11
    3c56:	f1b3 0220 	subs.w	r2, r3, #32
    3c5a:	da0c      	bge.n	3c76 <__adddf3+0x16e>
    3c5c:	320c      	adds	r2, #12
    3c5e:	dd08      	ble.n	3c72 <__adddf3+0x16a>
    3c60:	f102 0c14 	add.w	ip, r2, #20
    3c64:	f1c2 020c 	rsb	r2, r2, #12
    3c68:	fa01 f00c 	lsl.w	r0, r1, ip
    3c6c:	fa21 f102 	lsr.w	r1, r1, r2
    3c70:	e00c      	b.n	3c8c <__adddf3+0x184>
    3c72:	f102 0214 	add.w	r2, r2, #20
    3c76:	bfd8      	it	le
    3c78:	f1c2 0c20 	rsble	ip, r2, #32
    3c7c:	fa01 f102 	lsl.w	r1, r1, r2
    3c80:	fa20 fc0c 	lsr.w	ip, r0, ip
    3c84:	bfdc      	itt	le
    3c86:	ea41 010c 	orrle.w	r1, r1, ip
    3c8a:	4090      	lslle	r0, r2
    3c8c:	1ae4      	subs	r4, r4, r3
    3c8e:	bfa2      	ittt	ge
    3c90:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    3c94:	4329      	orrge	r1, r5
    3c96:	bd30      	popge	{r4, r5, pc}
    3c98:	ea6f 0404 	mvn.w	r4, r4
    3c9c:	3c1f      	subs	r4, #31
    3c9e:	da1c      	bge.n	3cda <__adddf3+0x1d2>
    3ca0:	340c      	adds	r4, #12
    3ca2:	dc0e      	bgt.n	3cc2 <__adddf3+0x1ba>
    3ca4:	f104 0414 	add.w	r4, r4, #20
    3ca8:	f1c4 0220 	rsb	r2, r4, #32
    3cac:	fa20 f004 	lsr.w	r0, r0, r4
    3cb0:	fa01 f302 	lsl.w	r3, r1, r2
    3cb4:	ea40 0003 	orr.w	r0, r0, r3
    3cb8:	fa21 f304 	lsr.w	r3, r1, r4
    3cbc:	ea45 0103 	orr.w	r1, r5, r3
    3cc0:	bd30      	pop	{r4, r5, pc}
    3cc2:	f1c4 040c 	rsb	r4, r4, #12
    3cc6:	f1c4 0220 	rsb	r2, r4, #32
    3cca:	fa20 f002 	lsr.w	r0, r0, r2
    3cce:	fa01 f304 	lsl.w	r3, r1, r4
    3cd2:	ea40 0003 	orr.w	r0, r0, r3
    3cd6:	4629      	mov	r1, r5
    3cd8:	bd30      	pop	{r4, r5, pc}
    3cda:	fa21 f004 	lsr.w	r0, r1, r4
    3cde:	4629      	mov	r1, r5
    3ce0:	bd30      	pop	{r4, r5, pc}
    3ce2:	f094 0f00 	teq	r4, #0
    3ce6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    3cea:	bf06      	itte	eq
    3cec:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    3cf0:	3401      	addeq	r4, #1
    3cf2:	3d01      	subne	r5, #1
    3cf4:	e74e      	b.n	3b94 <__adddf3+0x8c>
    3cf6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    3cfa:	bf18      	it	ne
    3cfc:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    3d00:	d029      	beq.n	3d56 <__adddf3+0x24e>
    3d02:	ea94 0f05 	teq	r4, r5
    3d06:	bf08      	it	eq
    3d08:	ea90 0f02 	teqeq	r0, r2
    3d0c:	d005      	beq.n	3d1a <__adddf3+0x212>
    3d0e:	ea54 0c00 	orrs.w	ip, r4, r0
    3d12:	bf04      	itt	eq
    3d14:	4619      	moveq	r1, r3
    3d16:	4610      	moveq	r0, r2
    3d18:	bd30      	pop	{r4, r5, pc}
    3d1a:	ea91 0f03 	teq	r1, r3
    3d1e:	bf1e      	ittt	ne
    3d20:	2100      	movne	r1, #0
    3d22:	2000      	movne	r0, #0
    3d24:	bd30      	popne	{r4, r5, pc}
    3d26:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    3d2a:	d105      	bne.n	3d38 <__adddf3+0x230>
    3d2c:	0040      	lsls	r0, r0, #1
    3d2e:	4149      	adcs	r1, r1
    3d30:	bf28      	it	cs
    3d32:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    3d36:	bd30      	pop	{r4, r5, pc}
    3d38:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    3d3c:	bf3c      	itt	cc
    3d3e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    3d42:	bd30      	popcc	{r4, r5, pc}
    3d44:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    3d48:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    3d4c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    3d50:	f04f 0000 	mov.w	r0, #0
    3d54:	bd30      	pop	{r4, r5, pc}
    3d56:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    3d5a:	bf1a      	itte	ne
    3d5c:	4619      	movne	r1, r3
    3d5e:	4610      	movne	r0, r2
    3d60:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    3d64:	bf1c      	itt	ne
    3d66:	460b      	movne	r3, r1
    3d68:	4602      	movne	r2, r0
    3d6a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    3d6e:	bf06      	itte	eq
    3d70:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    3d74:	ea91 0f03 	teqeq	r1, r3
    3d78:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    3d7c:	bd30      	pop	{r4, r5, pc}
    3d7e:	bf00      	nop

00003d80 <__aeabi_ui2d>:
    3d80:	f090 0f00 	teq	r0, #0
    3d84:	bf04      	itt	eq
    3d86:	2100      	moveq	r1, #0
    3d88:	4770      	bxeq	lr
    3d8a:	b530      	push	{r4, r5, lr}
    3d8c:	f44f 6480 	mov.w	r4, #1024	; 0x400
    3d90:	f104 0432 	add.w	r4, r4, #50	; 0x32
    3d94:	f04f 0500 	mov.w	r5, #0
    3d98:	f04f 0100 	mov.w	r1, #0
    3d9c:	e750      	b.n	3c40 <__adddf3+0x138>
    3d9e:	bf00      	nop

00003da0 <__aeabi_i2d>:
    3da0:	f090 0f00 	teq	r0, #0
    3da4:	bf04      	itt	eq
    3da6:	2100      	moveq	r1, #0
    3da8:	4770      	bxeq	lr
    3daa:	b530      	push	{r4, r5, lr}
    3dac:	f44f 6480 	mov.w	r4, #1024	; 0x400
    3db0:	f104 0432 	add.w	r4, r4, #50	; 0x32
    3db4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    3db8:	bf48      	it	mi
    3dba:	4240      	negmi	r0, r0
    3dbc:	f04f 0100 	mov.w	r1, #0
    3dc0:	e73e      	b.n	3c40 <__adddf3+0x138>
    3dc2:	bf00      	nop

00003dc4 <__aeabi_f2d>:
    3dc4:	0042      	lsls	r2, r0, #1
    3dc6:	ea4f 01e2 	mov.w	r1, r2, asr #3
    3dca:	ea4f 0131 	mov.w	r1, r1, rrx
    3dce:	ea4f 7002 	mov.w	r0, r2, lsl #28
    3dd2:	bf1f      	itttt	ne
    3dd4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    3dd8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    3ddc:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    3de0:	4770      	bxne	lr
    3de2:	f092 0f00 	teq	r2, #0
    3de6:	bf14      	ite	ne
    3de8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    3dec:	4770      	bxeq	lr
    3dee:	b530      	push	{r4, r5, lr}
    3df0:	f44f 7460 	mov.w	r4, #896	; 0x380
    3df4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    3df8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    3dfc:	e720      	b.n	3c40 <__adddf3+0x138>
    3dfe:	bf00      	nop

00003e00 <__aeabi_ul2d>:
    3e00:	ea50 0201 	orrs.w	r2, r0, r1
    3e04:	bf08      	it	eq
    3e06:	4770      	bxeq	lr
    3e08:	b530      	push	{r4, r5, lr}
    3e0a:	f04f 0500 	mov.w	r5, #0
    3e0e:	e00a      	b.n	3e26 <__aeabi_l2d+0x16>

00003e10 <__aeabi_l2d>:
    3e10:	ea50 0201 	orrs.w	r2, r0, r1
    3e14:	bf08      	it	eq
    3e16:	4770      	bxeq	lr
    3e18:	b530      	push	{r4, r5, lr}
    3e1a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    3e1e:	d502      	bpl.n	3e26 <__aeabi_l2d+0x16>
    3e20:	4240      	negs	r0, r0
    3e22:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    3e26:	f44f 6480 	mov.w	r4, #1024	; 0x400
    3e2a:	f104 0432 	add.w	r4, r4, #50	; 0x32
    3e2e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    3e32:	f43f aedc 	beq.w	3bee <__adddf3+0xe6>
    3e36:	f04f 0203 	mov.w	r2, #3
    3e3a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    3e3e:	bf18      	it	ne
    3e40:	3203      	addne	r2, #3
    3e42:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    3e46:	bf18      	it	ne
    3e48:	3203      	addne	r2, #3
    3e4a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    3e4e:	f1c2 0320 	rsb	r3, r2, #32
    3e52:	fa00 fc03 	lsl.w	ip, r0, r3
    3e56:	fa20 f002 	lsr.w	r0, r0, r2
    3e5a:	fa01 fe03 	lsl.w	lr, r1, r3
    3e5e:	ea40 000e 	orr.w	r0, r0, lr
    3e62:	fa21 f102 	lsr.w	r1, r1, r2
    3e66:	4414      	add	r4, r2
    3e68:	e6c1      	b.n	3bee <__adddf3+0xe6>
    3e6a:	bf00      	nop

00003e6c <__libc_init_array>:
    3e6c:	b570      	push	{r4, r5, r6, lr}
    3e6e:	4e0d      	ldr	r6, [pc, #52]	; (3ea4 <__libc_init_array+0x38>)
    3e70:	4c0d      	ldr	r4, [pc, #52]	; (3ea8 <__libc_init_array+0x3c>)
    3e72:	1ba4      	subs	r4, r4, r6
    3e74:	10a4      	asrs	r4, r4, #2
    3e76:	2500      	movs	r5, #0
    3e78:	42a5      	cmp	r5, r4
    3e7a:	d109      	bne.n	3e90 <__libc_init_array+0x24>
    3e7c:	4e0b      	ldr	r6, [pc, #44]	; (3eac <__libc_init_array+0x40>)
    3e7e:	4c0c      	ldr	r4, [pc, #48]	; (3eb0 <__libc_init_array+0x44>)
    3e80:	f000 fcbe 	bl	4800 <_init>
    3e84:	1ba4      	subs	r4, r4, r6
    3e86:	10a4      	asrs	r4, r4, #2
    3e88:	2500      	movs	r5, #0
    3e8a:	42a5      	cmp	r5, r4
    3e8c:	d105      	bne.n	3e9a <__libc_init_array+0x2e>
    3e8e:	bd70      	pop	{r4, r5, r6, pc}
    3e90:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    3e94:	4798      	blx	r3
    3e96:	3501      	adds	r5, #1
    3e98:	e7ee      	b.n	3e78 <__libc_init_array+0xc>
    3e9a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    3e9e:	4798      	blx	r3
    3ea0:	3501      	adds	r5, #1
    3ea2:	e7f2      	b.n	3e8a <__libc_init_array+0x1e>
    3ea4:	0000480c 	.word	0x0000480c
    3ea8:	0000480c 	.word	0x0000480c
    3eac:	0000480c 	.word	0x0000480c
    3eb0:	00004810 	.word	0x00004810

00003eb4 <memset>:
    3eb4:	4402      	add	r2, r0
    3eb6:	4603      	mov	r3, r0
    3eb8:	4293      	cmp	r3, r2
    3eba:	d100      	bne.n	3ebe <memset+0xa>
    3ebc:	4770      	bx	lr
    3ebe:	f803 1b01 	strb.w	r1, [r3], #1
    3ec2:	e7f9      	b.n	3eb8 <memset+0x4>

00003ec4 <setbuf>:
    3ec4:	2900      	cmp	r1, #0
    3ec6:	f44f 6380 	mov.w	r3, #1024	; 0x400
    3eca:	bf0c      	ite	eq
    3ecc:	2202      	moveq	r2, #2
    3ece:	2200      	movne	r2, #0
    3ed0:	f000 b800 	b.w	3ed4 <setvbuf>

00003ed4 <setvbuf>:
    3ed4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    3ed8:	461d      	mov	r5, r3
    3eda:	4b51      	ldr	r3, [pc, #324]	; (4020 <setvbuf+0x14c>)
    3edc:	681e      	ldr	r6, [r3, #0]
    3ede:	4604      	mov	r4, r0
    3ee0:	460f      	mov	r7, r1
    3ee2:	4690      	mov	r8, r2
    3ee4:	b126      	cbz	r6, 3ef0 <setvbuf+0x1c>
    3ee6:	69b3      	ldr	r3, [r6, #24]
    3ee8:	b913      	cbnz	r3, 3ef0 <setvbuf+0x1c>
    3eea:	4630      	mov	r0, r6
    3eec:	f000 f992 	bl	4214 <__sinit>
    3ef0:	4b4c      	ldr	r3, [pc, #304]	; (4024 <setvbuf+0x150>)
    3ef2:	429c      	cmp	r4, r3
    3ef4:	d152      	bne.n	3f9c <setvbuf+0xc8>
    3ef6:	6874      	ldr	r4, [r6, #4]
    3ef8:	f1b8 0f02 	cmp.w	r8, #2
    3efc:	d006      	beq.n	3f0c <setvbuf+0x38>
    3efe:	f1b8 0f01 	cmp.w	r8, #1
    3f02:	f200 8089 	bhi.w	4018 <setvbuf+0x144>
    3f06:	2d00      	cmp	r5, #0
    3f08:	f2c0 8086 	blt.w	4018 <setvbuf+0x144>
    3f0c:	4621      	mov	r1, r4
    3f0e:	4630      	mov	r0, r6
    3f10:	f000 f916 	bl	4140 <_fflush_r>
    3f14:	6b61      	ldr	r1, [r4, #52]	; 0x34
    3f16:	b141      	cbz	r1, 3f2a <setvbuf+0x56>
    3f18:	f104 0344 	add.w	r3, r4, #68	; 0x44
    3f1c:	4299      	cmp	r1, r3
    3f1e:	d002      	beq.n	3f26 <setvbuf+0x52>
    3f20:	4630      	mov	r0, r6
    3f22:	f000 fa2d 	bl	4380 <_free_r>
    3f26:	2300      	movs	r3, #0
    3f28:	6363      	str	r3, [r4, #52]	; 0x34
    3f2a:	2300      	movs	r3, #0
    3f2c:	61a3      	str	r3, [r4, #24]
    3f2e:	6063      	str	r3, [r4, #4]
    3f30:	89a3      	ldrh	r3, [r4, #12]
    3f32:	061b      	lsls	r3, r3, #24
    3f34:	d503      	bpl.n	3f3e <setvbuf+0x6a>
    3f36:	6921      	ldr	r1, [r4, #16]
    3f38:	4630      	mov	r0, r6
    3f3a:	f000 fa21 	bl	4380 <_free_r>
    3f3e:	89a3      	ldrh	r3, [r4, #12]
    3f40:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
    3f44:	f023 0303 	bic.w	r3, r3, #3
    3f48:	f1b8 0f02 	cmp.w	r8, #2
    3f4c:	81a3      	strh	r3, [r4, #12]
    3f4e:	d05d      	beq.n	400c <setvbuf+0x138>
    3f50:	ab01      	add	r3, sp, #4
    3f52:	466a      	mov	r2, sp
    3f54:	4621      	mov	r1, r4
    3f56:	4630      	mov	r0, r6
    3f58:	f000 f9e6 	bl	4328 <__swhatbuf_r>
    3f5c:	89a3      	ldrh	r3, [r4, #12]
    3f5e:	4318      	orrs	r0, r3
    3f60:	81a0      	strh	r0, [r4, #12]
    3f62:	bb2d      	cbnz	r5, 3fb0 <setvbuf+0xdc>
    3f64:	9d00      	ldr	r5, [sp, #0]
    3f66:	4628      	mov	r0, r5
    3f68:	f000 fa02 	bl	4370 <malloc>
    3f6c:	4607      	mov	r7, r0
    3f6e:	2800      	cmp	r0, #0
    3f70:	d14e      	bne.n	4010 <setvbuf+0x13c>
    3f72:	f8dd 9000 	ldr.w	r9, [sp]
    3f76:	45a9      	cmp	r9, r5
    3f78:	d13c      	bne.n	3ff4 <setvbuf+0x120>
    3f7a:	f04f 30ff 	mov.w	r0, #4294967295
    3f7e:	89a3      	ldrh	r3, [r4, #12]
    3f80:	f043 0302 	orr.w	r3, r3, #2
    3f84:	81a3      	strh	r3, [r4, #12]
    3f86:	2300      	movs	r3, #0
    3f88:	60a3      	str	r3, [r4, #8]
    3f8a:	f104 0347 	add.w	r3, r4, #71	; 0x47
    3f8e:	6023      	str	r3, [r4, #0]
    3f90:	6123      	str	r3, [r4, #16]
    3f92:	2301      	movs	r3, #1
    3f94:	6163      	str	r3, [r4, #20]
    3f96:	b003      	add	sp, #12
    3f98:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    3f9c:	4b22      	ldr	r3, [pc, #136]	; (4028 <setvbuf+0x154>)
    3f9e:	429c      	cmp	r4, r3
    3fa0:	d101      	bne.n	3fa6 <setvbuf+0xd2>
    3fa2:	68b4      	ldr	r4, [r6, #8]
    3fa4:	e7a8      	b.n	3ef8 <setvbuf+0x24>
    3fa6:	4b21      	ldr	r3, [pc, #132]	; (402c <setvbuf+0x158>)
    3fa8:	429c      	cmp	r4, r3
    3faa:	bf08      	it	eq
    3fac:	68f4      	ldreq	r4, [r6, #12]
    3fae:	e7a3      	b.n	3ef8 <setvbuf+0x24>
    3fb0:	2f00      	cmp	r7, #0
    3fb2:	d0d8      	beq.n	3f66 <setvbuf+0x92>
    3fb4:	69b3      	ldr	r3, [r6, #24]
    3fb6:	b913      	cbnz	r3, 3fbe <setvbuf+0xea>
    3fb8:	4630      	mov	r0, r6
    3fba:	f000 f92b 	bl	4214 <__sinit>
    3fbe:	f1b8 0f01 	cmp.w	r8, #1
    3fc2:	bf08      	it	eq
    3fc4:	89a3      	ldrheq	r3, [r4, #12]
    3fc6:	6027      	str	r7, [r4, #0]
    3fc8:	bf04      	itt	eq
    3fca:	f043 0301 	orreq.w	r3, r3, #1
    3fce:	81a3      	strheq	r3, [r4, #12]
    3fd0:	89a3      	ldrh	r3, [r4, #12]
    3fd2:	6127      	str	r7, [r4, #16]
    3fd4:	f013 0008 	ands.w	r0, r3, #8
    3fd8:	6165      	str	r5, [r4, #20]
    3fda:	d01b      	beq.n	4014 <setvbuf+0x140>
    3fdc:	f013 0001 	ands.w	r0, r3, #1
    3fe0:	bf18      	it	ne
    3fe2:	426d      	negne	r5, r5
    3fe4:	f04f 0300 	mov.w	r3, #0
    3fe8:	bf1d      	ittte	ne
    3fea:	60a3      	strne	r3, [r4, #8]
    3fec:	61a5      	strne	r5, [r4, #24]
    3fee:	4618      	movne	r0, r3
    3ff0:	60a5      	streq	r5, [r4, #8]
    3ff2:	e7d0      	b.n	3f96 <setvbuf+0xc2>
    3ff4:	4648      	mov	r0, r9
    3ff6:	f000 f9bb 	bl	4370 <malloc>
    3ffa:	4607      	mov	r7, r0
    3ffc:	2800      	cmp	r0, #0
    3ffe:	d0bc      	beq.n	3f7a <setvbuf+0xa6>
    4000:	89a3      	ldrh	r3, [r4, #12]
    4002:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4006:	81a3      	strh	r3, [r4, #12]
    4008:	464d      	mov	r5, r9
    400a:	e7d3      	b.n	3fb4 <setvbuf+0xe0>
    400c:	2000      	movs	r0, #0
    400e:	e7b6      	b.n	3f7e <setvbuf+0xaa>
    4010:	46a9      	mov	r9, r5
    4012:	e7f5      	b.n	4000 <setvbuf+0x12c>
    4014:	60a0      	str	r0, [r4, #8]
    4016:	e7be      	b.n	3f96 <setvbuf+0xc2>
    4018:	f04f 30ff 	mov.w	r0, #4294967295
    401c:	e7bb      	b.n	3f96 <setvbuf+0xc2>
    401e:	bf00      	nop
    4020:	20000030 	.word	0x20000030
    4024:	000047c0 	.word	0x000047c0
    4028:	000047e0 	.word	0x000047e0
    402c:	000047a0 	.word	0x000047a0

00004030 <__sflush_r>:
    4030:	898a      	ldrh	r2, [r1, #12]
    4032:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4036:	4605      	mov	r5, r0
    4038:	0710      	lsls	r0, r2, #28
    403a:	460c      	mov	r4, r1
    403c:	d45a      	bmi.n	40f4 <__sflush_r+0xc4>
    403e:	684b      	ldr	r3, [r1, #4]
    4040:	2b00      	cmp	r3, #0
    4042:	dc05      	bgt.n	4050 <__sflush_r+0x20>
    4044:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    4046:	2b00      	cmp	r3, #0
    4048:	dc02      	bgt.n	4050 <__sflush_r+0x20>
    404a:	2000      	movs	r0, #0
    404c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4050:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    4052:	2e00      	cmp	r6, #0
    4054:	d0f9      	beq.n	404a <__sflush_r+0x1a>
    4056:	2300      	movs	r3, #0
    4058:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
    405c:	682f      	ldr	r7, [r5, #0]
    405e:	602b      	str	r3, [r5, #0]
    4060:	d033      	beq.n	40ca <__sflush_r+0x9a>
    4062:	6d60      	ldr	r0, [r4, #84]	; 0x54
    4064:	89a3      	ldrh	r3, [r4, #12]
    4066:	075a      	lsls	r2, r3, #29
    4068:	d505      	bpl.n	4076 <__sflush_r+0x46>
    406a:	6863      	ldr	r3, [r4, #4]
    406c:	1ac0      	subs	r0, r0, r3
    406e:	6b63      	ldr	r3, [r4, #52]	; 0x34
    4070:	b10b      	cbz	r3, 4076 <__sflush_r+0x46>
    4072:	6c23      	ldr	r3, [r4, #64]	; 0x40
    4074:	1ac0      	subs	r0, r0, r3
    4076:	2300      	movs	r3, #0
    4078:	4602      	mov	r2, r0
    407a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    407c:	6a21      	ldr	r1, [r4, #32]
    407e:	4628      	mov	r0, r5
    4080:	47b0      	blx	r6
    4082:	1c43      	adds	r3, r0, #1
    4084:	89a3      	ldrh	r3, [r4, #12]
    4086:	d106      	bne.n	4096 <__sflush_r+0x66>
    4088:	6829      	ldr	r1, [r5, #0]
    408a:	291d      	cmp	r1, #29
    408c:	d84b      	bhi.n	4126 <__sflush_r+0xf6>
    408e:	4a2b      	ldr	r2, [pc, #172]	; (413c <__sflush_r+0x10c>)
    4090:	40ca      	lsrs	r2, r1
    4092:	07d6      	lsls	r6, r2, #31
    4094:	d547      	bpl.n	4126 <__sflush_r+0xf6>
    4096:	2200      	movs	r2, #0
    4098:	6062      	str	r2, [r4, #4]
    409a:	04d9      	lsls	r1, r3, #19
    409c:	6922      	ldr	r2, [r4, #16]
    409e:	6022      	str	r2, [r4, #0]
    40a0:	d504      	bpl.n	40ac <__sflush_r+0x7c>
    40a2:	1c42      	adds	r2, r0, #1
    40a4:	d101      	bne.n	40aa <__sflush_r+0x7a>
    40a6:	682b      	ldr	r3, [r5, #0]
    40a8:	b903      	cbnz	r3, 40ac <__sflush_r+0x7c>
    40aa:	6560      	str	r0, [r4, #84]	; 0x54
    40ac:	6b61      	ldr	r1, [r4, #52]	; 0x34
    40ae:	602f      	str	r7, [r5, #0]
    40b0:	2900      	cmp	r1, #0
    40b2:	d0ca      	beq.n	404a <__sflush_r+0x1a>
    40b4:	f104 0344 	add.w	r3, r4, #68	; 0x44
    40b8:	4299      	cmp	r1, r3
    40ba:	d002      	beq.n	40c2 <__sflush_r+0x92>
    40bc:	4628      	mov	r0, r5
    40be:	f000 f95f 	bl	4380 <_free_r>
    40c2:	2000      	movs	r0, #0
    40c4:	6360      	str	r0, [r4, #52]	; 0x34
    40c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    40ca:	6a21      	ldr	r1, [r4, #32]
    40cc:	2301      	movs	r3, #1
    40ce:	4628      	mov	r0, r5
    40d0:	47b0      	blx	r6
    40d2:	1c41      	adds	r1, r0, #1
    40d4:	d1c6      	bne.n	4064 <__sflush_r+0x34>
    40d6:	682b      	ldr	r3, [r5, #0]
    40d8:	2b00      	cmp	r3, #0
    40da:	d0c3      	beq.n	4064 <__sflush_r+0x34>
    40dc:	2b1d      	cmp	r3, #29
    40de:	d001      	beq.n	40e4 <__sflush_r+0xb4>
    40e0:	2b16      	cmp	r3, #22
    40e2:	d101      	bne.n	40e8 <__sflush_r+0xb8>
    40e4:	602f      	str	r7, [r5, #0]
    40e6:	e7b0      	b.n	404a <__sflush_r+0x1a>
    40e8:	89a3      	ldrh	r3, [r4, #12]
    40ea:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    40ee:	81a3      	strh	r3, [r4, #12]
    40f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    40f4:	690f      	ldr	r7, [r1, #16]
    40f6:	2f00      	cmp	r7, #0
    40f8:	d0a7      	beq.n	404a <__sflush_r+0x1a>
    40fa:	0793      	lsls	r3, r2, #30
    40fc:	680e      	ldr	r6, [r1, #0]
    40fe:	bf08      	it	eq
    4100:	694b      	ldreq	r3, [r1, #20]
    4102:	600f      	str	r7, [r1, #0]
    4104:	bf18      	it	ne
    4106:	2300      	movne	r3, #0
    4108:	eba6 0807 	sub.w	r8, r6, r7
    410c:	608b      	str	r3, [r1, #8]
    410e:	f1b8 0f00 	cmp.w	r8, #0
    4112:	dd9a      	ble.n	404a <__sflush_r+0x1a>
    4114:	4643      	mov	r3, r8
    4116:	463a      	mov	r2, r7
    4118:	6a21      	ldr	r1, [r4, #32]
    411a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    411c:	4628      	mov	r0, r5
    411e:	47b0      	blx	r6
    4120:	2800      	cmp	r0, #0
    4122:	dc07      	bgt.n	4134 <__sflush_r+0x104>
    4124:	89a3      	ldrh	r3, [r4, #12]
    4126:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    412a:	81a3      	strh	r3, [r4, #12]
    412c:	f04f 30ff 	mov.w	r0, #4294967295
    4130:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4134:	4407      	add	r7, r0
    4136:	eba8 0800 	sub.w	r8, r8, r0
    413a:	e7e8      	b.n	410e <__sflush_r+0xde>
    413c:	20400001 	.word	0x20400001

00004140 <_fflush_r>:
    4140:	b538      	push	{r3, r4, r5, lr}
    4142:	690b      	ldr	r3, [r1, #16]
    4144:	4605      	mov	r5, r0
    4146:	460c      	mov	r4, r1
    4148:	b1db      	cbz	r3, 4182 <_fflush_r+0x42>
    414a:	b118      	cbz	r0, 4154 <_fflush_r+0x14>
    414c:	6983      	ldr	r3, [r0, #24]
    414e:	b90b      	cbnz	r3, 4154 <_fflush_r+0x14>
    4150:	f000 f860 	bl	4214 <__sinit>
    4154:	4b0c      	ldr	r3, [pc, #48]	; (4188 <_fflush_r+0x48>)
    4156:	429c      	cmp	r4, r3
    4158:	d109      	bne.n	416e <_fflush_r+0x2e>
    415a:	686c      	ldr	r4, [r5, #4]
    415c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
    4160:	b17b      	cbz	r3, 4182 <_fflush_r+0x42>
    4162:	4621      	mov	r1, r4
    4164:	4628      	mov	r0, r5
    4166:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    416a:	f7ff bf61 	b.w	4030 <__sflush_r>
    416e:	4b07      	ldr	r3, [pc, #28]	; (418c <_fflush_r+0x4c>)
    4170:	429c      	cmp	r4, r3
    4172:	d101      	bne.n	4178 <_fflush_r+0x38>
    4174:	68ac      	ldr	r4, [r5, #8]
    4176:	e7f1      	b.n	415c <_fflush_r+0x1c>
    4178:	4b05      	ldr	r3, [pc, #20]	; (4190 <_fflush_r+0x50>)
    417a:	429c      	cmp	r4, r3
    417c:	bf08      	it	eq
    417e:	68ec      	ldreq	r4, [r5, #12]
    4180:	e7ec      	b.n	415c <_fflush_r+0x1c>
    4182:	2000      	movs	r0, #0
    4184:	bd38      	pop	{r3, r4, r5, pc}
    4186:	bf00      	nop
    4188:	000047c0 	.word	0x000047c0
    418c:	000047e0 	.word	0x000047e0
    4190:	000047a0 	.word	0x000047a0

00004194 <_cleanup_r>:
    4194:	4901      	ldr	r1, [pc, #4]	; (419c <_cleanup_r+0x8>)
    4196:	f000 b8a9 	b.w	42ec <_fwalk_reent>
    419a:	bf00      	nop
    419c:	00004141 	.word	0x00004141

000041a0 <std.isra.0>:
    41a0:	2300      	movs	r3, #0
    41a2:	b510      	push	{r4, lr}
    41a4:	4604      	mov	r4, r0
    41a6:	6003      	str	r3, [r0, #0]
    41a8:	6043      	str	r3, [r0, #4]
    41aa:	6083      	str	r3, [r0, #8]
    41ac:	8181      	strh	r1, [r0, #12]
    41ae:	6643      	str	r3, [r0, #100]	; 0x64
    41b0:	81c2      	strh	r2, [r0, #14]
    41b2:	6103      	str	r3, [r0, #16]
    41b4:	6143      	str	r3, [r0, #20]
    41b6:	6183      	str	r3, [r0, #24]
    41b8:	4619      	mov	r1, r3
    41ba:	2208      	movs	r2, #8
    41bc:	305c      	adds	r0, #92	; 0x5c
    41be:	f7ff fe79 	bl	3eb4 <memset>
    41c2:	4b05      	ldr	r3, [pc, #20]	; (41d8 <std.isra.0+0x38>)
    41c4:	6263      	str	r3, [r4, #36]	; 0x24
    41c6:	4b05      	ldr	r3, [pc, #20]	; (41dc <std.isra.0+0x3c>)
    41c8:	62a3      	str	r3, [r4, #40]	; 0x28
    41ca:	4b05      	ldr	r3, [pc, #20]	; (41e0 <std.isra.0+0x40>)
    41cc:	62e3      	str	r3, [r4, #44]	; 0x2c
    41ce:	4b05      	ldr	r3, [pc, #20]	; (41e4 <std.isra.0+0x44>)
    41d0:	6224      	str	r4, [r4, #32]
    41d2:	6323      	str	r3, [r4, #48]	; 0x30
    41d4:	bd10      	pop	{r4, pc}
    41d6:	bf00      	nop
    41d8:	000044f9 	.word	0x000044f9
    41dc:	0000451b 	.word	0x0000451b
    41e0:	00004553 	.word	0x00004553
    41e4:	00004577 	.word	0x00004577

000041e8 <__sfmoreglue>:
    41e8:	b570      	push	{r4, r5, r6, lr}
    41ea:	1e4a      	subs	r2, r1, #1
    41ec:	2568      	movs	r5, #104	; 0x68
    41ee:	4355      	muls	r5, r2
    41f0:	460e      	mov	r6, r1
    41f2:	f105 0174 	add.w	r1, r5, #116	; 0x74
    41f6:	f000 f911 	bl	441c <_malloc_r>
    41fa:	4604      	mov	r4, r0
    41fc:	b140      	cbz	r0, 4210 <__sfmoreglue+0x28>
    41fe:	2100      	movs	r1, #0
    4200:	e880 0042 	stmia.w	r0, {r1, r6}
    4204:	300c      	adds	r0, #12
    4206:	60a0      	str	r0, [r4, #8]
    4208:	f105 0268 	add.w	r2, r5, #104	; 0x68
    420c:	f7ff fe52 	bl	3eb4 <memset>
    4210:	4620      	mov	r0, r4
    4212:	bd70      	pop	{r4, r5, r6, pc}

00004214 <__sinit>:
    4214:	6983      	ldr	r3, [r0, #24]
    4216:	b510      	push	{r4, lr}
    4218:	4604      	mov	r4, r0
    421a:	bb33      	cbnz	r3, 426a <__sinit+0x56>
    421c:	6483      	str	r3, [r0, #72]	; 0x48
    421e:	64c3      	str	r3, [r0, #76]	; 0x4c
    4220:	6503      	str	r3, [r0, #80]	; 0x50
    4222:	4b12      	ldr	r3, [pc, #72]	; (426c <__sinit+0x58>)
    4224:	4a12      	ldr	r2, [pc, #72]	; (4270 <__sinit+0x5c>)
    4226:	681b      	ldr	r3, [r3, #0]
    4228:	6282      	str	r2, [r0, #40]	; 0x28
    422a:	4298      	cmp	r0, r3
    422c:	bf04      	itt	eq
    422e:	2301      	moveq	r3, #1
    4230:	6183      	streq	r3, [r0, #24]
    4232:	f000 f81f 	bl	4274 <__sfp>
    4236:	6060      	str	r0, [r4, #4]
    4238:	4620      	mov	r0, r4
    423a:	f000 f81b 	bl	4274 <__sfp>
    423e:	60a0      	str	r0, [r4, #8]
    4240:	4620      	mov	r0, r4
    4242:	f000 f817 	bl	4274 <__sfp>
    4246:	2200      	movs	r2, #0
    4248:	60e0      	str	r0, [r4, #12]
    424a:	2104      	movs	r1, #4
    424c:	6860      	ldr	r0, [r4, #4]
    424e:	f7ff ffa7 	bl	41a0 <std.isra.0>
    4252:	2201      	movs	r2, #1
    4254:	2109      	movs	r1, #9
    4256:	68a0      	ldr	r0, [r4, #8]
    4258:	f7ff ffa2 	bl	41a0 <std.isra.0>
    425c:	2202      	movs	r2, #2
    425e:	2112      	movs	r1, #18
    4260:	68e0      	ldr	r0, [r4, #12]
    4262:	f7ff ff9d 	bl	41a0 <std.isra.0>
    4266:	2301      	movs	r3, #1
    4268:	61a3      	str	r3, [r4, #24]
    426a:	bd10      	pop	{r4, pc}
    426c:	0000479c 	.word	0x0000479c
    4270:	00004195 	.word	0x00004195

00004274 <__sfp>:
    4274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4276:	4b1c      	ldr	r3, [pc, #112]	; (42e8 <__sfp+0x74>)
    4278:	681e      	ldr	r6, [r3, #0]
    427a:	69b3      	ldr	r3, [r6, #24]
    427c:	4607      	mov	r7, r0
    427e:	b913      	cbnz	r3, 4286 <__sfp+0x12>
    4280:	4630      	mov	r0, r6
    4282:	f7ff ffc7 	bl	4214 <__sinit>
    4286:	3648      	adds	r6, #72	; 0x48
    4288:	68b4      	ldr	r4, [r6, #8]
    428a:	6873      	ldr	r3, [r6, #4]
    428c:	3b01      	subs	r3, #1
    428e:	d503      	bpl.n	4298 <__sfp+0x24>
    4290:	6833      	ldr	r3, [r6, #0]
    4292:	b133      	cbz	r3, 42a2 <__sfp+0x2e>
    4294:	6836      	ldr	r6, [r6, #0]
    4296:	e7f7      	b.n	4288 <__sfp+0x14>
    4298:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
    429c:	b16d      	cbz	r5, 42ba <__sfp+0x46>
    429e:	3468      	adds	r4, #104	; 0x68
    42a0:	e7f4      	b.n	428c <__sfp+0x18>
    42a2:	2104      	movs	r1, #4
    42a4:	4638      	mov	r0, r7
    42a6:	f7ff ff9f 	bl	41e8 <__sfmoreglue>
    42aa:	6030      	str	r0, [r6, #0]
    42ac:	2800      	cmp	r0, #0
    42ae:	d1f1      	bne.n	4294 <__sfp+0x20>
    42b0:	230c      	movs	r3, #12
    42b2:	603b      	str	r3, [r7, #0]
    42b4:	4604      	mov	r4, r0
    42b6:	4620      	mov	r0, r4
    42b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    42ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
    42be:	81e3      	strh	r3, [r4, #14]
    42c0:	2301      	movs	r3, #1
    42c2:	81a3      	strh	r3, [r4, #12]
    42c4:	6665      	str	r5, [r4, #100]	; 0x64
    42c6:	6025      	str	r5, [r4, #0]
    42c8:	60a5      	str	r5, [r4, #8]
    42ca:	6065      	str	r5, [r4, #4]
    42cc:	6125      	str	r5, [r4, #16]
    42ce:	6165      	str	r5, [r4, #20]
    42d0:	61a5      	str	r5, [r4, #24]
    42d2:	2208      	movs	r2, #8
    42d4:	4629      	mov	r1, r5
    42d6:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    42da:	f7ff fdeb 	bl	3eb4 <memset>
    42de:	6365      	str	r5, [r4, #52]	; 0x34
    42e0:	63a5      	str	r5, [r4, #56]	; 0x38
    42e2:	64a5      	str	r5, [r4, #72]	; 0x48
    42e4:	64e5      	str	r5, [r4, #76]	; 0x4c
    42e6:	e7e6      	b.n	42b6 <__sfp+0x42>
    42e8:	0000479c 	.word	0x0000479c

000042ec <_fwalk_reent>:
    42ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    42f0:	4680      	mov	r8, r0
    42f2:	4689      	mov	r9, r1
    42f4:	f100 0448 	add.w	r4, r0, #72	; 0x48
    42f8:	2600      	movs	r6, #0
    42fa:	b914      	cbnz	r4, 4302 <_fwalk_reent+0x16>
    42fc:	4630      	mov	r0, r6
    42fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    4302:	68a5      	ldr	r5, [r4, #8]
    4304:	6867      	ldr	r7, [r4, #4]
    4306:	3f01      	subs	r7, #1
    4308:	d501      	bpl.n	430e <_fwalk_reent+0x22>
    430a:	6824      	ldr	r4, [r4, #0]
    430c:	e7f5      	b.n	42fa <_fwalk_reent+0xe>
    430e:	89ab      	ldrh	r3, [r5, #12]
    4310:	2b01      	cmp	r3, #1
    4312:	d907      	bls.n	4324 <_fwalk_reent+0x38>
    4314:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
    4318:	3301      	adds	r3, #1
    431a:	d003      	beq.n	4324 <_fwalk_reent+0x38>
    431c:	4629      	mov	r1, r5
    431e:	4640      	mov	r0, r8
    4320:	47c8      	blx	r9
    4322:	4306      	orrs	r6, r0
    4324:	3568      	adds	r5, #104	; 0x68
    4326:	e7ee      	b.n	4306 <_fwalk_reent+0x1a>

00004328 <__swhatbuf_r>:
    4328:	b570      	push	{r4, r5, r6, lr}
    432a:	460e      	mov	r6, r1
    432c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    4330:	2900      	cmp	r1, #0
    4332:	b090      	sub	sp, #64	; 0x40
    4334:	4614      	mov	r4, r2
    4336:	461d      	mov	r5, r3
    4338:	da07      	bge.n	434a <__swhatbuf_r+0x22>
    433a:	2300      	movs	r3, #0
    433c:	602b      	str	r3, [r5, #0]
    433e:	89b3      	ldrh	r3, [r6, #12]
    4340:	061a      	lsls	r2, r3, #24
    4342:	d410      	bmi.n	4366 <__swhatbuf_r+0x3e>
    4344:	f44f 6380 	mov.w	r3, #1024	; 0x400
    4348:	e00e      	b.n	4368 <__swhatbuf_r+0x40>
    434a:	aa01      	add	r2, sp, #4
    434c:	f000 f93a 	bl	45c4 <_fstat_r>
    4350:	2800      	cmp	r0, #0
    4352:	dbf2      	blt.n	433a <__swhatbuf_r+0x12>
    4354:	9a02      	ldr	r2, [sp, #8]
    4356:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
    435a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
    435e:	425a      	negs	r2, r3
    4360:	415a      	adcs	r2, r3
    4362:	602a      	str	r2, [r5, #0]
    4364:	e7ee      	b.n	4344 <__swhatbuf_r+0x1c>
    4366:	2340      	movs	r3, #64	; 0x40
    4368:	2000      	movs	r0, #0
    436a:	6023      	str	r3, [r4, #0]
    436c:	b010      	add	sp, #64	; 0x40
    436e:	bd70      	pop	{r4, r5, r6, pc}

00004370 <malloc>:
    4370:	4b02      	ldr	r3, [pc, #8]	; (437c <malloc+0xc>)
    4372:	4601      	mov	r1, r0
    4374:	6818      	ldr	r0, [r3, #0]
    4376:	f000 b851 	b.w	441c <_malloc_r>
    437a:	bf00      	nop
    437c:	20000030 	.word	0x20000030

00004380 <_free_r>:
    4380:	b538      	push	{r3, r4, r5, lr}
    4382:	4605      	mov	r5, r0
    4384:	2900      	cmp	r1, #0
    4386:	d045      	beq.n	4414 <_free_r+0x94>
    4388:	f851 3c04 	ldr.w	r3, [r1, #-4]
    438c:	1f0c      	subs	r4, r1, #4
    438e:	2b00      	cmp	r3, #0
    4390:	bfb8      	it	lt
    4392:	18e4      	addlt	r4, r4, r3
    4394:	f000 f93a 	bl	460c <__malloc_lock>
    4398:	4a1f      	ldr	r2, [pc, #124]	; (4418 <_free_r+0x98>)
    439a:	6813      	ldr	r3, [r2, #0]
    439c:	4610      	mov	r0, r2
    439e:	b933      	cbnz	r3, 43ae <_free_r+0x2e>
    43a0:	6063      	str	r3, [r4, #4]
    43a2:	6014      	str	r4, [r2, #0]
    43a4:	4628      	mov	r0, r5
    43a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    43aa:	f000 b930 	b.w	460e <__malloc_unlock>
    43ae:	42a3      	cmp	r3, r4
    43b0:	d90c      	bls.n	43cc <_free_r+0x4c>
    43b2:	6821      	ldr	r1, [r4, #0]
    43b4:	1862      	adds	r2, r4, r1
    43b6:	4293      	cmp	r3, r2
    43b8:	bf04      	itt	eq
    43ba:	681a      	ldreq	r2, [r3, #0]
    43bc:	685b      	ldreq	r3, [r3, #4]
    43be:	6063      	str	r3, [r4, #4]
    43c0:	bf04      	itt	eq
    43c2:	1852      	addeq	r2, r2, r1
    43c4:	6022      	streq	r2, [r4, #0]
    43c6:	6004      	str	r4, [r0, #0]
    43c8:	e7ec      	b.n	43a4 <_free_r+0x24>
    43ca:	4613      	mov	r3, r2
    43cc:	685a      	ldr	r2, [r3, #4]
    43ce:	b10a      	cbz	r2, 43d4 <_free_r+0x54>
    43d0:	42a2      	cmp	r2, r4
    43d2:	d9fa      	bls.n	43ca <_free_r+0x4a>
    43d4:	6819      	ldr	r1, [r3, #0]
    43d6:	1858      	adds	r0, r3, r1
    43d8:	42a0      	cmp	r0, r4
    43da:	d10b      	bne.n	43f4 <_free_r+0x74>
    43dc:	6820      	ldr	r0, [r4, #0]
    43de:	4401      	add	r1, r0
    43e0:	1858      	adds	r0, r3, r1
    43e2:	4282      	cmp	r2, r0
    43e4:	6019      	str	r1, [r3, #0]
    43e6:	d1dd      	bne.n	43a4 <_free_r+0x24>
    43e8:	6810      	ldr	r0, [r2, #0]
    43ea:	6852      	ldr	r2, [r2, #4]
    43ec:	605a      	str	r2, [r3, #4]
    43ee:	4401      	add	r1, r0
    43f0:	6019      	str	r1, [r3, #0]
    43f2:	e7d7      	b.n	43a4 <_free_r+0x24>
    43f4:	d902      	bls.n	43fc <_free_r+0x7c>
    43f6:	230c      	movs	r3, #12
    43f8:	602b      	str	r3, [r5, #0]
    43fa:	e7d3      	b.n	43a4 <_free_r+0x24>
    43fc:	6820      	ldr	r0, [r4, #0]
    43fe:	1821      	adds	r1, r4, r0
    4400:	428a      	cmp	r2, r1
    4402:	bf04      	itt	eq
    4404:	6811      	ldreq	r1, [r2, #0]
    4406:	6852      	ldreq	r2, [r2, #4]
    4408:	6062      	str	r2, [r4, #4]
    440a:	bf04      	itt	eq
    440c:	1809      	addeq	r1, r1, r0
    440e:	6021      	streq	r1, [r4, #0]
    4410:	605c      	str	r4, [r3, #4]
    4412:	e7c7      	b.n	43a4 <_free_r+0x24>
    4414:	bd38      	pop	{r3, r4, r5, pc}
    4416:	bf00      	nop
    4418:	20001674 	.word	0x20001674

0000441c <_malloc_r>:
    441c:	b570      	push	{r4, r5, r6, lr}
    441e:	1ccd      	adds	r5, r1, #3
    4420:	f025 0503 	bic.w	r5, r5, #3
    4424:	3508      	adds	r5, #8
    4426:	2d0c      	cmp	r5, #12
    4428:	bf38      	it	cc
    442a:	250c      	movcc	r5, #12
    442c:	2d00      	cmp	r5, #0
    442e:	4606      	mov	r6, r0
    4430:	db01      	blt.n	4436 <_malloc_r+0x1a>
    4432:	42a9      	cmp	r1, r5
    4434:	d903      	bls.n	443e <_malloc_r+0x22>
    4436:	230c      	movs	r3, #12
    4438:	6033      	str	r3, [r6, #0]
    443a:	2000      	movs	r0, #0
    443c:	bd70      	pop	{r4, r5, r6, pc}
    443e:	f000 f8e5 	bl	460c <__malloc_lock>
    4442:	4a23      	ldr	r2, [pc, #140]	; (44d0 <_malloc_r+0xb4>)
    4444:	6814      	ldr	r4, [r2, #0]
    4446:	4621      	mov	r1, r4
    4448:	b991      	cbnz	r1, 4470 <_malloc_r+0x54>
    444a:	4c22      	ldr	r4, [pc, #136]	; (44d4 <_malloc_r+0xb8>)
    444c:	6823      	ldr	r3, [r4, #0]
    444e:	b91b      	cbnz	r3, 4458 <_malloc_r+0x3c>
    4450:	4630      	mov	r0, r6
    4452:	f000 f841 	bl	44d8 <_sbrk_r>
    4456:	6020      	str	r0, [r4, #0]
    4458:	4629      	mov	r1, r5
    445a:	4630      	mov	r0, r6
    445c:	f000 f83c 	bl	44d8 <_sbrk_r>
    4460:	1c43      	adds	r3, r0, #1
    4462:	d126      	bne.n	44b2 <_malloc_r+0x96>
    4464:	230c      	movs	r3, #12
    4466:	6033      	str	r3, [r6, #0]
    4468:	4630      	mov	r0, r6
    446a:	f000 f8d0 	bl	460e <__malloc_unlock>
    446e:	e7e4      	b.n	443a <_malloc_r+0x1e>
    4470:	680b      	ldr	r3, [r1, #0]
    4472:	1b5b      	subs	r3, r3, r5
    4474:	d41a      	bmi.n	44ac <_malloc_r+0x90>
    4476:	2b0b      	cmp	r3, #11
    4478:	d90f      	bls.n	449a <_malloc_r+0x7e>
    447a:	600b      	str	r3, [r1, #0]
    447c:	50cd      	str	r5, [r1, r3]
    447e:	18cc      	adds	r4, r1, r3
    4480:	4630      	mov	r0, r6
    4482:	f000 f8c4 	bl	460e <__malloc_unlock>
    4486:	f104 000b 	add.w	r0, r4, #11
    448a:	1d23      	adds	r3, r4, #4
    448c:	f020 0007 	bic.w	r0, r0, #7
    4490:	1ac3      	subs	r3, r0, r3
    4492:	d01b      	beq.n	44cc <_malloc_r+0xb0>
    4494:	425a      	negs	r2, r3
    4496:	50e2      	str	r2, [r4, r3]
    4498:	bd70      	pop	{r4, r5, r6, pc}
    449a:	428c      	cmp	r4, r1
    449c:	bf0d      	iteet	eq
    449e:	6863      	ldreq	r3, [r4, #4]
    44a0:	684b      	ldrne	r3, [r1, #4]
    44a2:	6063      	strne	r3, [r4, #4]
    44a4:	6013      	streq	r3, [r2, #0]
    44a6:	bf18      	it	ne
    44a8:	460c      	movne	r4, r1
    44aa:	e7e9      	b.n	4480 <_malloc_r+0x64>
    44ac:	460c      	mov	r4, r1
    44ae:	6849      	ldr	r1, [r1, #4]
    44b0:	e7ca      	b.n	4448 <_malloc_r+0x2c>
    44b2:	1cc4      	adds	r4, r0, #3
    44b4:	f024 0403 	bic.w	r4, r4, #3
    44b8:	42a0      	cmp	r0, r4
    44ba:	d005      	beq.n	44c8 <_malloc_r+0xac>
    44bc:	1a21      	subs	r1, r4, r0
    44be:	4630      	mov	r0, r6
    44c0:	f000 f80a 	bl	44d8 <_sbrk_r>
    44c4:	3001      	adds	r0, #1
    44c6:	d0cd      	beq.n	4464 <_malloc_r+0x48>
    44c8:	6025      	str	r5, [r4, #0]
    44ca:	e7d9      	b.n	4480 <_malloc_r+0x64>
    44cc:	bd70      	pop	{r4, r5, r6, pc}
    44ce:	bf00      	nop
    44d0:	20001674 	.word	0x20001674
    44d4:	20001678 	.word	0x20001678

000044d8 <_sbrk_r>:
    44d8:	b538      	push	{r3, r4, r5, lr}
    44da:	4c06      	ldr	r4, [pc, #24]	; (44f4 <_sbrk_r+0x1c>)
    44dc:	2300      	movs	r3, #0
    44de:	4605      	mov	r5, r0
    44e0:	4608      	mov	r0, r1
    44e2:	6023      	str	r3, [r4, #0]
    44e4:	f7fd f8e6 	bl	16b4 <_sbrk>
    44e8:	1c43      	adds	r3, r0, #1
    44ea:	d102      	bne.n	44f2 <_sbrk_r+0x1a>
    44ec:	6823      	ldr	r3, [r4, #0]
    44ee:	b103      	cbz	r3, 44f2 <_sbrk_r+0x1a>
    44f0:	602b      	str	r3, [r5, #0]
    44f2:	bd38      	pop	{r3, r4, r5, pc}
    44f4:	2000174c 	.word	0x2000174c

000044f8 <__sread>:
    44f8:	b510      	push	{r4, lr}
    44fa:	460c      	mov	r4, r1
    44fc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    4500:	f000 f886 	bl	4610 <_read_r>
    4504:	2800      	cmp	r0, #0
    4506:	bfab      	itete	ge
    4508:	6d63      	ldrge	r3, [r4, #84]	; 0x54
    450a:	89a3      	ldrhlt	r3, [r4, #12]
    450c:	181b      	addge	r3, r3, r0
    450e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    4512:	bfac      	ite	ge
    4514:	6563      	strge	r3, [r4, #84]	; 0x54
    4516:	81a3      	strhlt	r3, [r4, #12]
    4518:	bd10      	pop	{r4, pc}

0000451a <__swrite>:
    451a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    451e:	461f      	mov	r7, r3
    4520:	898b      	ldrh	r3, [r1, #12]
    4522:	05db      	lsls	r3, r3, #23
    4524:	4605      	mov	r5, r0
    4526:	460c      	mov	r4, r1
    4528:	4616      	mov	r6, r2
    452a:	d505      	bpl.n	4538 <__swrite+0x1e>
    452c:	2302      	movs	r3, #2
    452e:	2200      	movs	r2, #0
    4530:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    4534:	f000 f858 	bl	45e8 <_lseek_r>
    4538:	89a3      	ldrh	r3, [r4, #12]
    453a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
    453e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    4542:	81a3      	strh	r3, [r4, #12]
    4544:	4632      	mov	r2, r6
    4546:	463b      	mov	r3, r7
    4548:	4628      	mov	r0, r5
    454a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    454e:	f000 b817 	b.w	4580 <_write_r>

00004552 <__sseek>:
    4552:	b510      	push	{r4, lr}
    4554:	460c      	mov	r4, r1
    4556:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    455a:	f000 f845 	bl	45e8 <_lseek_r>
    455e:	1c43      	adds	r3, r0, #1
    4560:	89a3      	ldrh	r3, [r4, #12]
    4562:	bf15      	itete	ne
    4564:	6560      	strne	r0, [r4, #84]	; 0x54
    4566:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
    456a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    456e:	81a3      	strheq	r3, [r4, #12]
    4570:	bf18      	it	ne
    4572:	81a3      	strhne	r3, [r4, #12]
    4574:	bd10      	pop	{r4, pc}

00004576 <__sclose>:
    4576:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
    457a:	f000 b813 	b.w	45a4 <_close_r>
	...

00004580 <_write_r>:
    4580:	b538      	push	{r3, r4, r5, lr}
    4582:	4c07      	ldr	r4, [pc, #28]	; (45a0 <_write_r+0x20>)
    4584:	4605      	mov	r5, r0
    4586:	4608      	mov	r0, r1
    4588:	4611      	mov	r1, r2
    458a:	2200      	movs	r2, #0
    458c:	6022      	str	r2, [r4, #0]
    458e:	461a      	mov	r2, r3
    4590:	f7ff f828 	bl	35e4 <_write>
    4594:	1c43      	adds	r3, r0, #1
    4596:	d102      	bne.n	459e <_write_r+0x1e>
    4598:	6823      	ldr	r3, [r4, #0]
    459a:	b103      	cbz	r3, 459e <_write_r+0x1e>
    459c:	602b      	str	r3, [r5, #0]
    459e:	bd38      	pop	{r3, r4, r5, pc}
    45a0:	2000174c 	.word	0x2000174c

000045a4 <_close_r>:
    45a4:	b538      	push	{r3, r4, r5, lr}
    45a6:	4c06      	ldr	r4, [pc, #24]	; (45c0 <_close_r+0x1c>)
    45a8:	2300      	movs	r3, #0
    45aa:	4605      	mov	r5, r0
    45ac:	4608      	mov	r0, r1
    45ae:	6023      	str	r3, [r4, #0]
    45b0:	f7fd f8a0 	bl	16f4 <_close>
    45b4:	1c43      	adds	r3, r0, #1
    45b6:	d102      	bne.n	45be <_close_r+0x1a>
    45b8:	6823      	ldr	r3, [r4, #0]
    45ba:	b103      	cbz	r3, 45be <_close_r+0x1a>
    45bc:	602b      	str	r3, [r5, #0]
    45be:	bd38      	pop	{r3, r4, r5, pc}
    45c0:	2000174c 	.word	0x2000174c

000045c4 <_fstat_r>:
    45c4:	b538      	push	{r3, r4, r5, lr}
    45c6:	4c07      	ldr	r4, [pc, #28]	; (45e4 <_fstat_r+0x20>)
    45c8:	2300      	movs	r3, #0
    45ca:	4605      	mov	r5, r0
    45cc:	4608      	mov	r0, r1
    45ce:	4611      	mov	r1, r2
    45d0:	6023      	str	r3, [r4, #0]
    45d2:	f7fd f89b 	bl	170c <_fstat>
    45d6:	1c43      	adds	r3, r0, #1
    45d8:	d102      	bne.n	45e0 <_fstat_r+0x1c>
    45da:	6823      	ldr	r3, [r4, #0]
    45dc:	b103      	cbz	r3, 45e0 <_fstat_r+0x1c>
    45de:	602b      	str	r3, [r5, #0]
    45e0:	bd38      	pop	{r3, r4, r5, pc}
    45e2:	bf00      	nop
    45e4:	2000174c 	.word	0x2000174c

000045e8 <_lseek_r>:
    45e8:	b538      	push	{r3, r4, r5, lr}
    45ea:	4c07      	ldr	r4, [pc, #28]	; (4608 <_lseek_r+0x20>)
    45ec:	4605      	mov	r5, r0
    45ee:	4608      	mov	r0, r1
    45f0:	4611      	mov	r1, r2
    45f2:	2200      	movs	r2, #0
    45f4:	6022      	str	r2, [r4, #0]
    45f6:	461a      	mov	r2, r3
    45f8:	f7fd f898 	bl	172c <_lseek>
    45fc:	1c43      	adds	r3, r0, #1
    45fe:	d102      	bne.n	4606 <_lseek_r+0x1e>
    4600:	6823      	ldr	r3, [r4, #0]
    4602:	b103      	cbz	r3, 4606 <_lseek_r+0x1e>
    4604:	602b      	str	r3, [r5, #0]
    4606:	bd38      	pop	{r3, r4, r5, pc}
    4608:	2000174c 	.word	0x2000174c

0000460c <__malloc_lock>:
    460c:	4770      	bx	lr

0000460e <__malloc_unlock>:
    460e:	4770      	bx	lr

00004610 <_read_r>:
    4610:	b538      	push	{r3, r4, r5, lr}
    4612:	4c07      	ldr	r4, [pc, #28]	; (4630 <_read_r+0x20>)
    4614:	4605      	mov	r5, r0
    4616:	4608      	mov	r0, r1
    4618:	4611      	mov	r1, r2
    461a:	2200      	movs	r2, #0
    461c:	6022      	str	r2, [r4, #0]
    461e:	461a      	mov	r2, r3
    4620:	f7fe ffc0 	bl	35a4 <_read>
    4624:	1c43      	adds	r3, r0, #1
    4626:	d102      	bne.n	462e <_read_r+0x1e>
    4628:	6823      	ldr	r3, [r4, #0]
    462a:	b103      	cbz	r3, 462e <_read_r+0x1e>
    462c:	602b      	str	r3, [r5, #0]
    462e:	bd38      	pop	{r3, r4, r5, pc}
    4630:	2000174c 	.word	0x2000174c

00004634 <steering_positions>:
    4634:	00000000 3f800000 40000000              .......?...@

00004640 <steering_voltages>:
    4640:	00000000 3fd33333 40533333 682f2e2e     ....33.?33S@../h
    4650:	702f6c70 2f74726f 5f6c7068 6f697067     pl/port/hpl_gpio
    4660:	7361625f 00682e65 6c6c6548 6f57206f     _base.h.Hello Wo
    4670:	21646c72 00000000 652f2e2e 72656874     rld!....../ether
    4680:	5f74656e 2f796870 65687465 74656e72     net_phy/ethernet
    4690:	7968705f 0000632e 682f2e2e 732f6c61     _phy.c..../hal/s
    46a0:	682f6372 615f6c61 735f6364 2e636e79     rc/hal_adc_sync.
    46b0:	00000063 682f2e2e 732f6c61 682f6372     c...../hal/src/h
    46c0:	635f6c61 615f6e61 636e7973 0000632e     al_can_async.c..
    46d0:	682f2e2e 732f6c61 682f6372 695f6c61     ../hal/src/hal_i
    46e0:	00632e6f 682f2e2e 732f6c61 682f6372     o.c.../hal/src/h
    46f0:	6d5f6c61 615f6361 636e7973 0000632e     al_mac_async.c..
    4700:	682f2e2e 732f6c61 682f6372 755f6c61     ../hal/src/hal_u
    4710:	74726173 6e79735f 00632e63              sart_sync.c.

0000471c <_adcs>:
    471c:	00000001 00000000 00000000 00000000     ................
	...
    4734:	682f2e2e 612f6c70 682f6364 615f6c70     ../hpl/adc/hpl_a
    4744:	632e6364 00000000 682f2e2e 732f6c70     dc.c....../hpl/s
    4754:	6f637265 70682f6d 65735f6c 6d6f6372     ercom/hpl_sercom
    4764:	0000632e 40003000 40003400 41012000     .c...0.@.4.@. .A
    4774:	41014000 43000000 43000400 43000800     .@.A...C...C...C
    4784:	43000c00                                ...C

00004788 <sercomspi_regs>:
	...

0000479c <_global_impure_ptr>:
    479c:	20000034                                4.. 

000047a0 <__sf_fake_stderr>:
	...

000047c0 <__sf_fake_stdin>:
	...

000047e0 <__sf_fake_stdout>:
	...

00004800 <_init>:
    4800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4802:	bf00      	nop
    4804:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4806:	bc08      	pop	{r3}
    4808:	469e      	mov	lr, r3
    480a:	4770      	bx	lr

0000480c <__init_array_start>:
    480c:	00000289 	.word	0x00000289

00004810 <_fini>:
    4810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4812:	bf00      	nop
    4814:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4816:	bc08      	pop	{r3}
    4818:	469e      	mov	lr, r3
    481a:	4770      	bx	lr

0000481c <__fini_array_start>:
    481c:	00000265 	.word	0x00000265
